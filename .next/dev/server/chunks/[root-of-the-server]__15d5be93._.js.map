{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/business-config/targeting.ts"],"sourcesContent":["/**\n * Targeting Rules Evaluation Engine\n * Evaluates targeting rules against user/device context\n */\n\nexport interface TargetingContext {\n  user?: {\n    id?: string\n    email?: string\n    [key: string]: any // Custom user attributes\n  }\n  device?: {\n    platform?: string // 'ios' | 'android'\n    osVersion?: string\n    appVersion?: string\n    deviceModel?: string\n    [key: string]: any // Custom device attributes\n  }\n  app?: {\n    version?: string\n    buildNumber?: string\n    [key: string]: any // Custom app attributes\n  }\n}\n\nexport interface TargetingCondition {\n  property: string // e.g., \"user.email\", \"device.platform\", \"app.version\"\n  operator: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'in' | 'notIn' | 'exists' | 'notExists'\n  value: any // Value to compare against\n  caseSensitive?: boolean\n}\n\nexport interface TargetingRule {\n  conditions: TargetingCondition[]\n  logic: 'AND' | 'OR' // Logic to combine conditions\n  value: any // Value to return if rule matches\n}\n\nexport interface TargetingRules {\n  rules: TargetingRule[]\n  defaultValue: any // Fallback value if no rules match\n}\n\n/**\n * Evaluate targeting rules against context\n * Returns the matching value or defaultValue\n */\nexport function evaluateTargeting(\n  targetingRules: TargetingRules | null,\n  context: TargetingContext,\n  defaultValue: any\n): any {\n  // If no targeting rules, return default value\n  if (!targetingRules || !targetingRules.rules || targetingRules.rules.length === 0) {\n    return defaultValue\n  }\n\n  // Evaluate each rule\n  for (const rule of targetingRules.rules) {\n    if (evaluateRule(rule, context)) {\n      return rule.value\n    }\n  }\n\n  // No rules matched, return default\n  return targetingRules.defaultValue !== undefined ? targetingRules.defaultValue : defaultValue\n}\n\n/**\n * Evaluate a single targeting rule\n */\nfunction evaluateRule(rule: TargetingRule, context: TargetingContext): boolean {\n  if (!rule.conditions || rule.conditions.length === 0) {\n    return true // Empty rule always matches\n  }\n\n  const results = rule.conditions.map(condition => evaluateCondition(condition, context))\n\n  // Combine results based on logic\n  if (rule.logic === 'AND') {\n    return results.every(r => r === true)\n  } else {\n    return results.some(r => r === true)\n  }\n}\n\n/**\n * Evaluate a single condition\n */\nfunction evaluateCondition(condition: TargetingCondition, context: TargetingContext): boolean {\n  const { property, operator, value, caseSensitive = false } = condition\n\n  // Get property value from context\n  const propertyValue = getPropertyValue(property, context)\n\n  // Handle exists/notExists operators\n  if (operator === 'exists') {\n    return propertyValue !== undefined && propertyValue !== null\n  }\n  if (operator === 'notExists') {\n    return propertyValue === undefined || propertyValue === null\n  }\n\n  // If property doesn't exist and operator requires a value, return false\n  if (propertyValue === undefined || propertyValue === null) {\n    return false\n  }\n\n  // Normalize values for comparison\n  const normalizedPropertyValue = normalizeValue(propertyValue, caseSensitive)\n  const normalizedCompareValue = normalizeValue(value, caseSensitive)\n\n  // Evaluate based on operator\n  switch (operator) {\n    case 'equals':\n      return normalizedPropertyValue === normalizedCompareValue\n\n    case 'contains':\n      if (typeof normalizedPropertyValue === 'string' && typeof normalizedCompareValue === 'string') {\n        return normalizedPropertyValue.includes(normalizedCompareValue)\n      }\n      return false\n\n    case 'startsWith':\n      if (typeof normalizedPropertyValue === 'string' && typeof normalizedCompareValue === 'string') {\n        return normalizedPropertyValue.startsWith(normalizedCompareValue)\n      }\n      return false\n\n    case 'endsWith':\n      if (typeof normalizedPropertyValue === 'string' && typeof normalizedCompareValue === 'string') {\n        return normalizedPropertyValue.endsWith(normalizedCompareValue)\n      }\n      return false\n\n    case 'greaterThan':\n      return compareNumbers(normalizedPropertyValue, normalizedCompareValue) > 0\n\n    case 'lessThan':\n      return compareNumbers(normalizedPropertyValue, normalizedCompareValue) < 0\n\n    case 'in':\n      if (Array.isArray(normalizedCompareValue)) {\n        return normalizedCompareValue.includes(normalizedPropertyValue)\n      }\n      return false\n\n    case 'notIn':\n      if (Array.isArray(normalizedCompareValue)) {\n        return !normalizedCompareValue.includes(normalizedPropertyValue)\n      }\n      return false\n\n    default:\n      return false\n  }\n}\n\n/**\n * Get property value from context using dot notation\n * e.g., \"user.email\" -> context.user.email\n */\nfunction getPropertyValue(property: string, context: TargetingContext): any {\n  const parts = property.split('.')\n  let value: any = context\n\n  for (const part of parts) {\n    if (value === undefined || value === null) {\n      return undefined\n    }\n    value = value[part]\n  }\n\n  return value\n}\n\n/**\n * Normalize value for comparison\n */\nfunction normalizeValue(value: any, caseSensitive: boolean): any {\n  if (typeof value === 'string' && !caseSensitive) {\n    return value.toLowerCase()\n  }\n  return value\n}\n\n/**\n * Compare two values as numbers\n */\nfunction compareNumbers(a: any, b: any): number {\n  const numA = typeof a === 'number' ? a : parseFloat(String(a))\n  const numB = typeof b === 'number' ? b : parseFloat(String(b))\n\n  if (isNaN(numA) || isNaN(numB)) {\n    return 0\n  }\n\n  return numA - numB\n}\n\n/**\n * Check if user should receive config based on rollout percentage\n * Uses consistent hashing based on userId or deviceId\n */\nexport function shouldReceiveRollout(\n  rolloutPercentage: number,\n  context: TargetingContext\n): boolean {\n  if (rolloutPercentage >= 100) {\n    return true\n  }\n  if (rolloutPercentage <= 0) {\n    return false\n  }\n\n  // Use userId or deviceId for consistent assignment\n  const identifier = context.user?.id || context.device?.deviceId || 'default'\n  \n  // Simple hash function for consistent assignment\n  const hash = simpleHash(identifier)\n  const percentage = (hash % 100) + 1 // 1-100\n\n  return percentage <= rolloutPercentage\n}\n\n/**\n * Simple hash function for consistent user assignment\n */\nfunction simpleHash(str: string): number {\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + char\n    hash = hash & hash // Convert to 32-bit integer\n  }\n  return Math.abs(hash)\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/business-config/events.ts"],"sourcesContent":["/**\n * Config Update Event Broadcasting System\n * \n * This module handles broadcasting config updates to connected SSE clients\n * In production, this could be replaced with Redis Pub/Sub or similar\n */\n\ninterface ConfigUpdateEvent {\n  projectId: string\n  configKey: string\n  version: number\n  updatedAt: Date\n}\n\n// In-memory store for active SSE connections\n// In production, use Redis or similar for distributed systems\nconst activeConnections = new Map<string, Set<(event: ConfigUpdateEvent) => void>>()\n\n/**\n * Register a callback for config updates for a project\n */\nexport function subscribeToConfigUpdates(\n  projectId: string,\n  callback: (event: ConfigUpdateEvent) => void\n): () => void {\n  if (!activeConnections.has(projectId)) {\n    activeConnections.set(projectId, new Set())\n  }\n\n  const callbacks = activeConnections.get(projectId)!\n  callbacks.add(callback)\n\n  // Return unsubscribe function\n  return () => {\n    callbacks.delete(callback)\n    if (callbacks.size === 0) {\n      activeConnections.delete(projectId)\n    }\n  }\n}\n\n/**\n * Broadcast config update to all subscribers\n */\nexport function broadcastConfigUpdate(event: ConfigUpdateEvent) {\n  const callbacks = activeConnections.get(event.projectId)\n  if (callbacks) {\n    callbacks.forEach(callback => {\n      try {\n        callback(event)\n      } catch (error) {\n        console.error('Error broadcasting config update:', error)\n      }\n    })\n  }\n}\n\n/**\n * Get number of active subscribers for a project\n */\nexport function getSubscriberCount(projectId: string): number {\n  return activeConnections.get(projectId)?.size || 0\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;AASD,6CAA6C;AAC7C,8DAA8D;AAC9D,MAAM,oBAAoB,IAAI;AAKvB,SAAS,yBACd,SAAiB,EACjB,QAA4C;IAE5C,IAAI,CAAC,kBAAkB,GAAG,CAAC,YAAY;QACrC,kBAAkB,GAAG,CAAC,WAAW,IAAI;IACvC;IAEA,MAAM,YAAY,kBAAkB,GAAG,CAAC;IACxC,UAAU,GAAG,CAAC;IAEd,8BAA8B;IAC9B,OAAO;QACL,UAAU,MAAM,CAAC;QACjB,IAAI,UAAU,IAAI,KAAK,GAAG;YACxB,kBAAkB,MAAM,CAAC;QAC3B;IACF;AACF;AAKO,SAAS,sBAAsB,KAAwB;IAC5D,MAAM,YAAY,kBAAkB,GAAG,CAAC,MAAM,SAAS;IACvD,IAAI,WAAW;QACb,UAAU,OAAO,CAAC,CAAA;YAChB,IAAI;gBACF,SAAS;YACX,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,qCAAqC;YACrD;QACF;IACF;AACF;AAKO,SAAS,mBAAmB,SAAiB;IAClD,OAAO,kBAAkB,GAAG,CAAC,YAAY,QAAQ;AACnD"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/business-config/validation.ts"],"sourcesContent":["/**\n * Config Value Validation Engine\n * Validates config values against schema and constraints\n */\n\nexport interface ValidationSchema {\n  type?: 'string' | 'integer' | 'boolean' | 'decimal' | 'json' | 'image'\n  min?: number\n  max?: number\n  minLength?: number\n  maxLength?: number\n  pattern?: string // Regex pattern\n  allowedValues?: any[] // Array of allowed values\n  required?: boolean\n  properties?: Record<string, ValidationSchema> // For JSON objects\n  items?: ValidationSchema // For JSON arrays\n}\n\nexport interface ValidationResult {\n  valid: boolean\n  errors: string[]\n}\n\n/**\n * Validate a config value against schema and constraints\n */\nexport function validateConfigValue(\n  value: any,\n  valueType: string,\n  schema?: ValidationSchema | null,\n  constraints?: {\n    minValue?: number | null\n    maxValue?: number | null\n    minLength?: number | null\n    maxLength?: number | null\n    pattern?: string | null\n    allowedValues?: any[] | null\n  }\n): ValidationResult {\n  const errors: string[] = []\n\n  // Type validation\n  if (schema?.type && !validateType(value, schema.type)) {\n    errors.push(`Value must be of type ${schema.type}`)\n  }\n\n  // Value constraints\n  if (constraints?.minValue !== null && constraints?.minValue !== undefined) {\n    const numValue = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(numValue) || numValue < constraints.minValue!) {\n      errors.push(`Value must be at least ${constraints.minValue}`)\n    }\n  }\n\n  if (constraints?.maxValue !== null && constraints?.maxValue !== undefined) {\n    const numValue = typeof value === 'number' ? value : parseFloat(String(value))\n    if (isNaN(numValue) || numValue > constraints.maxValue!) {\n      errors.push(`Value must be at most ${constraints.maxValue}`)\n    }\n  }\n\n  // Length constraints (for strings)\n  if (typeof value === 'string') {\n    if (constraints?.minLength !== null && constraints?.minLength !== undefined) {\n      if (value.length < constraints.minLength!) {\n        errors.push(`Value must be at least ${constraints.minLength} characters`)\n      }\n    }\n\n    if (constraints?.maxLength !== null && constraints?.maxLength !== undefined) {\n      if (value.length > constraints.maxLength!) {\n        errors.push(`Value must be at most ${constraints.maxLength} characters`)\n      }\n    }\n\n    // Pattern validation\n    if (constraints?.pattern) {\n      try {\n        const regex = new RegExp(constraints.pattern)\n        if (!regex.test(value)) {\n          errors.push(`Value does not match required pattern`)\n        }\n      } catch (e) {\n        errors.push(`Invalid pattern: ${constraints.pattern}`)\n      }\n    }\n  }\n\n  // Allowed values\n  if (constraints?.allowedValues && constraints.allowedValues.length > 0) {\n    if (!constraints.allowedValues.includes(value)) {\n      errors.push(`Value must be one of: ${constraints.allowedValues.join(', ')}`)\n    }\n  }\n\n  // Schema validation (for JSON)\n  if (valueType === 'json' && schema) {\n    const jsonErrors = validateJsonSchema(value, schema)\n    errors.push(...jsonErrors)\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  }\n}\n\n/**\n * Validate value type\n */\nfunction validateType(value: any, expectedType: string): boolean {\n  switch (expectedType) {\n    case 'string':\n      return typeof value === 'string'\n    case 'integer':\n      return Number.isInteger(value) || (typeof value === 'string' && /^-?\\d+$/.test(value))\n    case 'boolean':\n      return typeof value === 'boolean' || value === 'true' || value === 'false' || value === 1 || value === 0\n    case 'decimal':\n      return typeof value === 'number' || !isNaN(parseFloat(String(value)))\n    case 'json':\n      return typeof value === 'object' && value !== null\n    case 'image':\n      return typeof value === 'string' && (value.startsWith('http') || value.startsWith('/'))\n    default:\n      return true\n  }\n}\n\n/**\n * Validate JSON schema (simplified)\n */\nfunction validateJsonSchema(value: any, schema: ValidationSchema): string[] {\n  const errors: string[] = []\n\n  if (typeof value !== 'object' || value === null) {\n    return ['Value must be a JSON object']\n  }\n\n  // Validate properties\n  if (schema.properties) {\n    for (const [key, propSchema] of Object.entries(schema.properties)) {\n      if (propSchema.required && !(key in value)) {\n        errors.push(`Missing required property: ${key}`)\n      }\n      if (key in value) {\n        const propErrors = validateConfigValue(value[key], propSchema.type || 'string', propSchema, {\n          minValue: propSchema.min,\n          maxValue: propSchema.max,\n          minLength: propSchema.minLength,\n          maxLength: propSchema.maxLength,\n          pattern: propSchema.pattern,\n          allowedValues: propSchema.allowedValues\n        })\n        errors.push(...propErrors.errors.map(e => `${key}: ${e}`))\n      }\n    }\n  }\n\n  // Validate array items\n  if (schema.items && Array.isArray(value)) {\n    value.forEach((item, index) => {\n      const itemErrors = validateConfigValue(item, schema.items!.type || 'string', schema.items!, {\n        minValue: schema.items!.min,\n        maxValue: schema.items!.max,\n        minLength: schema.items!.minLength,\n        maxLength: schema.items!.maxLength,\n        pattern: schema.items!.pattern,\n        allowedValues: schema.items!.allowedValues\n      })\n      errors.push(...itemErrors.errors.map(e => `[${index}]: ${e}`))\n    })\n  }\n\n  return errors\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/app/api/business-config/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { verifyToken, getAuthUser } from '@/lib/auth'\nimport { evaluateTargeting, shouldReceiveRollout, TargetingContext } from '@/lib/business-config/targeting'\nimport { broadcastConfigUpdate } from '@/lib/business-config/events'\nimport { validateConfigValue } from '@/lib/business-config/validation'\n\n// Valid value types\nconst VALUE_TYPES = ['string', 'integer', 'boolean', 'decimal', 'json', 'image'] as const\ntype ValueType = (typeof VALUE_TYPES)[number]\n\n// Helper to extract the value based on type\nfunction extractValue(config: {\n  valueType: string\n  stringValue: string | null\n  integerValue: number | null\n  booleanValue: boolean | null\n  decimalValue: number | null\n  jsonValue: unknown\n  imageUrl: string | null\n}) {\n  switch (config.valueType) {\n    case 'string':\n      return config.stringValue\n    case 'integer':\n      return config.integerValue\n    case 'boolean':\n      return config.booleanValue\n    case 'decimal':\n      return config.decimalValue\n    case 'json':\n      return config.jsonValue\n    case 'image':\n      return config.imageUrl\n    default:\n      return null\n  }\n}\n\n// GET - List all business configs for a project (dashboard) or fetch configs for SDK\nexport async function GET(request: NextRequest) {\n  try {\n    const apiKey = request.headers.get('x-api-key')\n    const authHeader = request.headers.get('authorization')\n    const projectId = request.nextUrl.searchParams.get('projectId')\n    const category = request.nextUrl.searchParams.get('category')\n    const key = request.nextUrl.searchParams.get('key')\n\n    // SDK request - return configs for mobile app (simplified format for caching)\n    if (apiKey) {\n      const project = await prisma.project.findUnique({\n        where: { apiKey }\n      })\n\n      if (!project) {\n        return NextResponse.json({ error: 'Invalid API key' }, { status: 401 })\n      }\n\n      // Validate subscription and feature access\n      const { validateSubscription } = await import('@/lib/subscription-validation')\n      const validation = await validateSubscription(project.userId)\n      if (!validation.valid) {\n        return NextResponse.json({\n          configs: [],\n          error: validation.error || 'Subscription invalid',\n          message: validation.error || 'Please upgrade to continue using DevBridge.'\n        }, { status: 403 })\n      }\n\n      // Get user/device context from request (optional)\n      const contextHeader = request.headers.get('x-devbridge-context')\n      let context: TargetingContext = {}\n      if (contextHeader) {\n        try {\n          context = JSON.parse(contextHeader)\n        } catch (e) {\n          console.warn('Invalid context header:', e)\n        }\n      }\n\n      // Build where clause\n      const where: Record<string, unknown> = {\n        projectId: project.id,\n        isEnabled: true\n      }\n      if (category) where.category = category\n      if (key) where.key = key\n\n      const configs = await prisma.businessConfig.findMany({\n        where,\n        select: {\n          key: true,\n          valueType: true,\n          stringValue: true,\n          integerValue: true,\n          booleanValue: true,\n          decimalValue: true,\n          jsonValue: true,\n          imageUrl: true,\n          category: true,\n          version: true,\n          updatedAt: true,\n          metadata: true\n        },\n        orderBy: { key: 'asc' }\n      })\n\n      // Transform to simplified key-value format for SDK with targeting evaluation\n      const configMap: Record<string, unknown> = {}\n      const configMeta: Record<string, { type: string; category: string | null; version: number; updatedAt: string }> = {}\n\n      for (const config of configs) {\n        // Extract advanced fields from metadata\n        const metadata = config.metadata as Record<string, unknown> | null\n        const rolloutPercentage = metadata?.rolloutPercentage as number | undefined || 100\n        const targetingRules = metadata?.targetingRules\n        const defaultValueFromMeta = metadata?.defaultValue\n        \n        // Check rollout percentage first\n        const receivesRollout = shouldReceiveRollout(rolloutPercentage, context)\n        if (!receivesRollout) {\n          // Track that user didn't receive config due to rollout\n          trackConfigUsage(project.id, config.key, {\n            deviceId: context.device?.deviceId,\n            userId: context.user?.id,\n            rolloutReceived: false,\n            targetingMatched: false,\n            cacheHit: false\n          })\n          continue // Skip this config if user is not in rollout\n        }\n\n        // Get default value (use metadata defaultValue if available, otherwise extract from config)\n        const defaultValue = defaultValueFromMeta !== undefined ? defaultValueFromMeta : extractValue(config)\n\n        // Check for active experiments on this config\n        const activeExperiment = await prisma.experiment.findFirst({\n          where: {\n            configId: config.id,\n            status: 'running',\n            AND: [\n              {\n                OR: [\n                  { startDate: null },\n                  { startDate: { lte: new Date() } }\n                ]\n              },\n              {\n                OR: [\n                  { endDate: null },\n                  { endDate: { gte: new Date() } }\n                ]\n              }\n            ]\n          },\n          orderBy: { createdAt: 'desc' }\n        })\n\n        let finalValue = defaultValue\n        let targetingMatched = false\n\n        // If experiment exists, assign user to variant\n        if (activeExperiment) {\n          try {\n            const { assignToVariant } = await import('@/lib/business-config/experiments')\n            const assignment = assignToVariant(\n              {\n                id: activeExperiment.id,\n                variants: activeExperiment.variants as any,\n                assignmentType: activeExperiment.assignmentType as any,\n                targetingRules: activeExperiment.targetingRules as any\n              },\n              {\n                deviceId: context.device?.deviceId,\n                userId: context.user?.id,\n                ...context\n              }\n            )\n\n            if (assignment) {\n              // Store assignment if not exists\n              await prisma.experimentAssignment.upsert({\n                where: {\n                  experimentId_deviceId_userId: {\n                    experimentId: activeExperiment.id,\n                    deviceId: context.device?.deviceId || null,\n                    userId: context.user?.id || null\n                  }\n                },\n                update: {\n                  lastSeenAt: new Date()\n                },\n                create: {\n                  experimentId: activeExperiment.id,\n                  deviceId: context.device?.deviceId || null,\n                  userId: context.user?.id || null,\n                  variantIndex: assignment.variantIndex,\n                  variantName: assignment.variant.name\n                }\n              })\n\n              // Use experiment variant value\n              finalValue = assignment.variant.value\n            }\n          } catch (error) {\n            console.error('Experiment assignment error:', error)\n            // Fallback to targeting/default\n          }\n        }\n\n        // If no experiment or experiment assignment failed, evaluate targeting rules\n        if (finalValue === defaultValue && targetingRules) {\n          try {\n            const targetedValue = evaluateTargeting(\n              targetingRules as any,\n              context,\n              defaultValueFromMeta !== undefined ? defaultValueFromMeta : defaultValue\n            )\n            targetingMatched = targetedValue !== defaultValue\n            finalValue = targetedValue\n          } catch (error) {\n            console.error('Targeting evaluation error:', error)\n            // Fallback to default value on error\n            finalValue = defaultValue\n          }\n        }\n\n        // Track config usage\n        trackConfigUsage(project.id, config.key, {\n          deviceId: context.device?.deviceId,\n          userId: context.user?.id,\n          rolloutReceived: true,\n          targetingMatched,\n          cacheHit: false // TODO: Implement cache detection\n        })\n\n        configMap[config.key] = finalValue\n        configMeta[config.key] = {\n          type: config.valueType,\n          category: config.category,\n          version: config.version,\n          updatedAt: config.updatedAt.toISOString()\n        }\n      }\n\n      return NextResponse.json({\n        configs: configMap,\n        meta: configMeta,\n        fetchedAt: new Date().toISOString()\n      })\n    }\n\n    // Dashboard request - return full configs\n    if (authHeader && projectId) {\n      const token = authHeader.replace('Bearer ', '')\n      const payload = verifyToken(token)\n\n      if (!payload) {\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n      }\n\n      // Verify project ownership\n      const project = await prisma.project.findFirst({\n        where: {\n          id: projectId,\n          userId: payload.userId\n        }\n      })\n\n      if (!project) {\n        return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n      }\n\n      // Build where clause\n      const where: Record<string, unknown> = { projectId }\n      if (category) where.category = category\n\n      const configs = await prisma.businessConfig.findMany({\n        where,\n        orderBy: [{ category: 'asc' }, { key: 'asc' }]\n      })\n\n      // Get unique categories\n      const categories = await prisma.businessConfig.findMany({\n        where: { projectId },\n        select: { category: true },\n        distinct: ['category']\n      })\n\n      return NextResponse.json({\n        configs,\n        categories: categories.map(c => c.category).filter(Boolean)\n      })\n    }\n\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  } catch (error) {\n    console.error('BusinessConfig GET error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// POST - Create a new business config\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { \n      projectId, \n      key, \n      label, \n      description, \n      valueType, \n      value, \n      category, \n      isEnabled, \n      metadata,\n      targetingRules,\n      defaultValue,\n      rolloutPercentage,\n      validationSchema,\n      minValue,\n      maxValue,\n      minLength,\n      maxLength,\n      pattern,\n      allowedValues,\n      deploymentStrategy,\n      deploymentConfig\n    } = body\n\n    if (!projectId || !key || !valueType) {\n      return NextResponse.json({ error: 'Missing required fields: projectId, key, valueType' }, { status: 400 })\n    }\n\n    if (!VALUE_TYPES.includes(valueType)) {\n      return NextResponse.json({ error: `Invalid valueType. Must be one of: ${VALUE_TYPES.join(', ')}` }, { status: 400 })\n    }\n\n    // Validate value if validation schema/constraints provided\n    const constraints = {\n      minValue,\n      maxValue,\n      minLength,\n      maxLength,\n      pattern,\n      allowedValues\n    }\n\n    if (validationSchema || Object.values(constraints).some(v => v !== undefined && v !== null)) {\n      const validation = validateConfigValue(value, valueType, validationSchema, constraints)\n      if (!validation.valid) {\n        return NextResponse.json(\n          { error: 'Validation failed', details: validation.errors },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Verify project ownership\n    const project = await prisma.project.findFirst({\n      where: {\n        id: projectId,\n        userId: payload.userId\n      }\n    })\n\n    if (!project) {\n      return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n    }\n\n    // Check business config keys quota\n    const { checkThrottling } = await import('@/lib/throttling')\n    const throttling = await checkThrottling(project.userId, 'businessConfigKeys')\n    if (throttling.throttled || (throttling.usage && throttling.usage.limit !== null && throttling.usage.used >= throttling.usage.limit)) {\n      return NextResponse.json(\n        {\n          error: throttling.error || `Business config keys limit reached. You have used ${throttling.usage?.used || 0} of ${throttling.usage?.limit || 0} keys. Please upgrade your plan to create more keys.`,\n          usage: throttling.usage,\n        },\n        {\n          status: throttling.throttled ? 429 : 403,\n          headers: throttling.retryAfter\n            ? { 'Retry-After': throttling.retryAfter.toString() }\n            : {},\n        }\n      )\n    }\n\n    // Prepare value fields based on type\n    const valueFields = getValueFields(valueType as ValueType, value)\n\n    // Store advanced fields in metadata JSON\n    const advancedMetadata: Record<string, unknown> = {}\n    if (targetingRules) advancedMetadata.targetingRules = targetingRules\n    if (defaultValue !== undefined) advancedMetadata.defaultValue = defaultValue\n    if (rolloutPercentage !== undefined) advancedMetadata.rolloutPercentage = Math.max(0, Math.min(100, rolloutPercentage))\n    if (validationSchema) advancedMetadata.validationSchema = validationSchema\n    if (minValue !== undefined) advancedMetadata.minValue = minValue\n    if (maxValue !== undefined) advancedMetadata.maxValue = maxValue\n    if (minLength !== undefined) advancedMetadata.minLength = minLength\n    if (maxLength !== undefined) advancedMetadata.maxLength = maxLength\n    if (pattern) advancedMetadata.pattern = pattern\n    if (allowedValues) advancedMetadata.allowedValues = allowedValues\n    if (deploymentStrategy) advancedMetadata.deploymentStrategy = deploymentStrategy\n    if (deploymentConfig) advancedMetadata.deploymentConfig = deploymentConfig\n    \n    // Merge with existing metadata\n    const finalMetadata = metadata || {}\n    const combinedMetadata = { ...finalMetadata, ...advancedMetadata }\n\n    const config = await prisma.businessConfig.create({\n      data: {\n        projectId,\n        key,\n        label: label || null,\n        description: description || null,\n        valueType,\n        ...valueFields,\n        category: category || null,\n        isEnabled: isEnabled !== false,\n        metadata: Object.keys(combinedMetadata).length > 0 ? combinedMetadata : null\n      }\n    })\n\n    // Log change\n    await logConfigChange(config.id, projectId, payload.userId, 'create', null, extractValue(config), body)\n\n    // Broadcast update to SSE subscribers\n    broadcastConfigUpdate({\n      projectId,\n      configKey: config.key,\n      version: config.version,\n      updatedAt: config.updatedAt\n    })\n\n    return NextResponse.json({ config })\n  } catch (error: unknown) {\n    console.error('BusinessConfig POST error:', error)\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'P2002') {\n      return NextResponse.json({ error: 'A config with this key already exists in this project' }, { status: 409 })\n    }\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// PUT - Update a business config\nexport async function PUT(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { \n      id, \n      key, \n      label, \n      description, \n      valueType, \n      value, \n      category, \n      isEnabled, \n      metadata,\n      targetingRules,\n      defaultValue,\n      rolloutPercentage,\n      validationSchema,\n      minValue,\n      maxValue,\n      minLength,\n      maxLength,\n      pattern,\n      allowedValues,\n      deploymentStrategy,\n      deploymentConfig\n    } = body\n\n    if (!id) {\n      return NextResponse.json({ error: 'Missing config ID' }, { status: 400 })\n    }\n\n    // Verify config ownership\n    const existingConfig = await prisma.businessConfig.findUnique({\n      where: { id },\n      include: { project: true }\n    })\n\n    if (!existingConfig || existingConfig.project.userId !== payload.userId) {\n      return NextResponse.json({ error: 'Config not found' }, { status: 404 })\n    }\n\n    // Prepare update data\n    const updateData: Record<string, unknown> = {}\n\n    if (key !== undefined) updateData.key = key\n    if (label !== undefined) updateData.label = label || null\n    if (description !== undefined) updateData.description = description || null\n    if (category !== undefined) updateData.category = category || null\n    if (isEnabled !== undefined) updateData.isEnabled = isEnabled\n    if (metadata !== undefined) updateData.metadata = metadata\n    if (targetingRules !== undefined) updateData.targetingRules = targetingRules || null\n    if (defaultValue !== undefined) updateData.defaultValue = defaultValue !== null ? defaultValue : null\n    if (rolloutPercentage !== undefined) updateData.rolloutPercentage = Math.max(0, Math.min(100, rolloutPercentage))\n    if (validationSchema !== undefined) updateData.validationSchema = validationSchema || null\n    if (minValue !== undefined) updateData.minValue = minValue !== null ? minValue : null\n    if (maxValue !== undefined) updateData.maxValue = maxValue !== null ? maxValue : null\n    if (minLength !== undefined) updateData.minLength = minLength !== null ? minLength : null\n    if (maxLength !== undefined) updateData.maxLength = maxLength !== null ? maxLength : null\n    if (pattern !== undefined) updateData.pattern = pattern || null\n    if (allowedValues !== undefined) updateData.allowedValues = allowedValues || null\n    if (deploymentStrategy !== undefined) updateData.deploymentStrategy = deploymentStrategy || null\n    if (deploymentConfig !== undefined) updateData.deploymentConfig = deploymentConfig || null\n\n    // Validate value if validation constraints are being updated\n    if (value !== undefined && (\n      validationSchema !== undefined ||\n      minValue !== undefined || maxValue !== undefined ||\n      minLength !== undefined || maxLength !== undefined ||\n      pattern !== undefined || allowedValues !== undefined\n    )) {\n      const finalValue = valueType !== undefined ? value : extractValue(existingConfig)\n      const finalType = valueType !== undefined ? valueType : existingConfig.valueType\n      const finalSchema = validationSchema !== undefined ? validationSchema : existingConfig.validationSchema\n      const finalConstraints = {\n        minValue: minValue !== undefined ? minValue : existingConfig.minValue,\n        maxValue: maxValue !== undefined ? maxValue : existingConfig.maxValue,\n        minLength: minLength !== undefined ? minLength : existingConfig.minLength,\n        maxLength: maxLength !== undefined ? maxLength : existingConfig.maxLength,\n        pattern: pattern !== undefined ? pattern : existingConfig.pattern,\n        allowedValues: allowedValues !== undefined ? allowedValues : existingConfig.allowedValues\n      }\n\n      const validation = validateConfigValue(finalValue, finalType, finalSchema, finalConstraints)\n      if (!validation.valid) {\n        return NextResponse.json(\n          { error: 'Validation failed', details: validation.errors },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Handle value type and value changes\n    if (valueType !== undefined) {\n      if (!VALUE_TYPES.includes(valueType)) {\n        return NextResponse.json({ error: `Invalid valueType. Must be one of: ${VALUE_TYPES.join(', ')}` }, { status: 400 })\n      }\n      updateData.valueType = valueType\n\n      // Clear all value fields and set new one\n      updateData.stringValue = null\n      updateData.integerValue = null\n      updateData.booleanValue = null\n      updateData.decimalValue = null\n      updateData.jsonValue = null\n      updateData.imageUrl = null\n\n      if (value !== undefined) {\n        const valueFields = getValueFields(valueType as ValueType, value)\n        Object.assign(updateData, valueFields)\n      }\n    } else if (value !== undefined) {\n      // Update value using existing type\n      const valueFields = getValueFields(existingConfig.valueType as ValueType, value)\n      Object.assign(updateData, valueFields)\n    }\n\n    // Increment version on any update\n    updateData.version = existingConfig.version + 1\n\n    // Store before value for change log\n    const beforeValue = extractValue(existingConfig)\n\n    const config = await prisma.businessConfig.update({\n      where: { id },\n      data: updateData\n    })\n\n    // Log change\n    const afterValue = extractValue(config)\n    await logConfigChange(config.id, config.projectId, payload.userId, 'update', beforeValue, afterValue, body)\n\n    // Broadcast update to SSE subscribers\n    broadcastConfigUpdate({\n      projectId: config.projectId,\n      configKey: config.key,\n      version: config.version,\n      updatedAt: config.updatedAt\n    })\n\n    return NextResponse.json({ config })\n  } catch (error: unknown) {\n    console.error('BusinessConfig PUT error:', error)\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'P2002') {\n      return NextResponse.json({ error: 'A config with this key already exists in this project' }, { status: 409 })\n    }\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// DELETE - Delete a business config\nexport async function DELETE(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const configId = request.nextUrl.searchParams.get('id')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    if (!configId) {\n      return NextResponse.json({ error: 'Missing config ID' }, { status: 400 })\n    }\n\n    // Verify config ownership\n    const existingConfig = await prisma.businessConfig.findUnique({\n      where: { id: configId },\n      include: { project: true }\n    })\n\n    if (!existingConfig || existingConfig.project.userId !== payload.userId) {\n      return NextResponse.json({ error: 'Config not found' }, { status: 404 })\n    }\n\n    // Log change before deletion\n    const beforeValue = extractValue(existingConfig)\n    await logConfigChange(existingConfig.id, existingConfig.projectId, payload.userId, 'delete', beforeValue, null, {})\n\n    // Broadcast update to SSE subscribers\n    broadcastConfigUpdate({\n      projectId: existingConfig.projectId,\n      configKey: existingConfig.key,\n      version: existingConfig.version,\n      updatedAt: new Date()\n    })\n\n    await prisma.businessConfig.delete({\n      where: { id: configId }\n    })\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('BusinessConfig DELETE error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// Helper function to prepare value fields based on type\nfunction getValueFields(valueType: ValueType, value: unknown): Record<string, unknown> {\n  const fields: Record<string, unknown> = {\n    stringValue: null,\n    integerValue: null,\n    booleanValue: null,\n    decimalValue: null,\n    jsonValue: null,\n    imageUrl: null\n  }\n\n  if (value === null || value === undefined) {\n    return fields\n  }\n\n  switch (valueType) {\n    case 'string':\n      fields.stringValue = String(value)\n      break\n    case 'integer':\n      fields.integerValue = parseInt(String(value), 10) || 0\n      break\n    case 'boolean':\n      fields.booleanValue = value === true || value === 'true' || value === 1\n      break\n    case 'decimal':\n      fields.decimalValue = parseFloat(String(value)) || 0\n      break\n    case 'json':\n      try {\n        fields.jsonValue = typeof value === 'string' ? JSON.parse(value) : value\n      } catch (e) {\n        // If JSON parsing fails, treat as invalid and return null fields\n        throw new Error(`Invalid JSON value: ${e instanceof Error ? e.message : 'Unknown error'}`)\n      }\n      break\n    case 'image':\n      fields.imageUrl = String(value)\n      break\n  }\n\n  return fields\n}\n\n/**\n * Log config changes to audit trail\n */\nasync function logConfigChange(\n  configId: string,\n  projectId: string,\n  userId: string,\n  action: 'create' | 'update' | 'delete',\n  beforeValue: any,\n  afterValue: any,\n  changes: any\n) {\n  try {\n    // Get user name for display\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: { name: true, email: true }\n    })\n\n    await prisma.configChangeLog.create({\n      data: {\n        configId,\n        projectId,\n        userId,\n        userName: user?.name || user?.email || 'Unknown',\n        action,\n        beforeValue: beforeValue !== undefined ? beforeValue : null,\n        afterValue: afterValue !== undefined ? afterValue : null,\n        changes: changes || null\n      }\n    })\n  } catch (error) {\n    console.error('Failed to log config change:', error)\n    // Don't fail the request if logging fails\n  }\n}\n\n/**\n * Track config usage metrics\n */\nasync function trackConfigUsage(\n  projectId: string,\n  configKey: string,\n  metrics: {\n    deviceId?: string\n    userId?: string\n    rolloutReceived: boolean\n    targetingMatched: boolean\n    cacheHit: boolean\n  }\n) {\n  try {\n    const uniqueKey = `${projectId}:${configKey}:${metrics.deviceId || 'none'}:${metrics.userId || 'none'}`\n    \n    await prisma.configUsageMetric.upsert({\n      where: {\n        projectId_configKey_deviceId_userId: {\n          projectId,\n          configKey,\n          deviceId: metrics.deviceId || null,\n          userId: metrics.userId || null\n        }\n      },\n      update: {\n        fetchCount: { increment: 1 },\n        cacheHit: metrics.cacheHit,\n        targetingMatched: metrics.targetingMatched,\n        rolloutReceived: metrics.rolloutReceived,\n        lastFetchedAt: new Date()\n      },\n      create: {\n        projectId,\n        configKey,\n        deviceId: metrics.deviceId || null,\n        userId: metrics.userId || null,\n        fetchCount: 1,\n        cacheHit: metrics.cacheHit,\n        targetingMatched: metrics.targetingMatched,\n        rolloutReceived: metrics.rolloutReceived\n      }\n    })\n  } catch (error) {\n    console.error('Failed to track config usage:', error)\n    // Don't fail the request if tracking fails\n  }\n}\n"],"names":[],"mappings":"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"}}]
}