{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/plan.ts"],"sourcesContent":["import { prisma } from './prisma'\n\nexport type Plan = {\n  id: string\n  name: string\n  displayName: string\n  description: string | null\n  price: number\n  currency: string\n  interval: string\n  isActive: boolean\n  isPublic: boolean\n  maxProjects: number | null\n  maxDevices: number | null\n  maxApiTraces: number | null\n  maxLogs: number | null\n  maxSessions: number | null\n  maxCrashes: number | null\n  retentionDays: number | null\n  allowApiTracking: boolean\n  allowScreenTracking: boolean\n  allowCrashReporting: boolean\n  allowLogging: boolean\n  allowBusinessConfig: boolean\n  allowLocalization: boolean\n  allowCustomDomains: boolean\n  allowWebhooks: boolean\n  allowTeamMembers: boolean\n  allowPrioritySupport: boolean\n  features: any | null\n  createdAt: Date\n  updatedAt: Date\n}\n\n/**\n * Get a plan by ID\n */\nexport async function getPlan(planId: string): Promise<Plan | null> {\n  return prisma.plan.findUnique({\n    where: { id: planId },\n  })\n}\n\n/**\n * Get a plan by name (e.g., \"free\", \"pro\", \"team\")\n */\nexport async function getPlanByName(name: string): Promise<Plan | null> {\n  return prisma.plan.findUnique({\n    where: { name },\n  })\n}\n\n/**\n * Get all public plans (for pricing page)\n */\nexport async function getPublicPlans(): Promise<Plan[]> {\n  return prisma.plan.findMany({\n    where: {\n      isPublic: true,\n    },\n    orderBy: {\n      price: 'asc',\n    },\n  })\n}\n\n/**\n * Get plan limits for a given plan ID\n */\nexport async function getPlanLimits(planId: string) {\n  const plan = await getPlan(planId)\n  if (!plan) return null\n\n  return {\n    maxProjects: plan.maxProjects,\n    maxDevices: plan.maxDevices,\n    maxApiTraces: plan.maxApiTraces,\n    maxLogs: plan.maxLogs,\n    maxSessions: plan.maxSessions,\n    maxCrashes: plan.maxCrashes,\n    retentionDays: plan.retentionDays,\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAqCO,eAAe,QAAQ,MAAc;IAC1C,OAAO,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE,IAAI;QAAO;IACtB;AACF;AAKO,eAAe,cAAc,IAAY;IAC9C,OAAO,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE;QAAK;IAChB;AACF;AAKO,eAAe;IACpB,OAAO,gIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B,OAAO;YACL,UAAU;QACZ;QACA,SAAS;YACP,OAAO;QACT;IACF;AACF;AAKO,eAAe,cAAc,MAAc;IAChD,MAAM,OAAO,MAAM,QAAQ;IAC3B,IAAI,CAAC,MAAM,OAAO;IAElB,OAAO;QACL,aAAa,KAAK,WAAW;QAC7B,YAAY,KAAK,UAAU;QAC3B,cAAc,KAAK,YAAY;QAC/B,SAAS,KAAK,OAAO;QACrB,aAAa,KAAK,WAAW;QAC7B,YAAY,KAAK,UAAU;QAC3B,eAAe,KAAK,aAAa;IACnC;AACF"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/subscription.ts"],"sourcesContent":["import { prisma } from './prisma'\nimport { getPlan } from './plan'\n\nexport type Subscription = {\n  id: string\n  userId: string\n  planId: string\n  status: string\n  enabled: boolean\n  trialStartDate: Date\n  trialEndDate: Date\n  currentPeriodStart: Date\n  currentPeriodEnd: Date\n  cancelledAt: Date | null\n  cancelledReason: string | null\n  disabledBy: string | null\n  disabledAt: Date | null\n  enabledBy: string | null\n  enabledAt: Date | null\n  createdAt: Date\n  updatedAt: Date\n  plan?: any\n}\n\n/**\n * Create a new subscription for a user\n */\nexport async function createSubscription(\n  userId: string,\n  planName: string = 'free'\n): Promise<Subscription> {\n  const plan = await prisma.plan.findUnique({\n    where: { name: planName },\n  })\n\n  if (!plan) {\n    throw new Error(`Plan \"${planName}\" not found`)\n  }\n\n  const trialStartDate = new Date()\n  \n  // Use plan's retentionDays as trial period, or default to 30 days\n  // For free plans, retentionDays typically represents the trial period\n  const trialDays = plan.retentionDays || 30\n  const trialEndDate = new Date(trialStartDate)\n  trialEndDate.setDate(trialEndDate.getDate() + trialDays)\n\n  const currentPeriodEnd = new Date(trialEndDate)\n\n  return prisma.subscription.create({\n    data: {\n      userId,\n      planId: plan.id,\n      status: 'active',\n      trialStartDate,\n      trialEndDate,\n      currentPeriodStart: trialStartDate,\n      currentPeriodEnd,\n    },\n    include: {\n      plan: true,\n    },\n  })\n}\n\n/**\n * Get user's subscription\n */\nexport async function getSubscription(userId: string): Promise<Subscription | null> {\n  const sub = await prisma.subscription.findUnique({\n    where: { userId },\n    include: {\n      plan: true,\n    },\n  })\n  // Type assertion to include admin fields\n  return sub as Subscription | null\n}\n\n/**\n * Check if trial is still active\n */\nexport async function isTrialActive(subscription: Subscription | null): Promise<boolean> {\n  if (!subscription) return false\n  \n  // Check if admin disabled the subscription\n  if (subscription.enabled === false) return false\n  \n  // Check if trial expired\n  if (subscription.status === 'expired') return false\n  if (subscription.status !== 'active') return false\n  \n  const now = new Date()\n  return subscription.trialEndDate > now\n}\n\n/**\n * Check if subscription allows a specific feature\n */\nexport async function isFeatureAllowed(\n  subscription: Subscription | null,\n  feature: string\n): Promise<boolean> {\n  if (!subscription) return false\n  \n  // If trial expired, no features allowed\n  if (!(await isTrialActive(subscription))) {\n    return false\n  }\n\n  const plan = await getPlan(subscription.planId)\n  if (!plan) return false\n\n  // Map feature names to plan flags\n  const featureMap: Record<string, keyof typeof plan> = {\n    deviceTracking: 'allowScreenTracking', // Device registration uses screen tracking flag\n    sessionTracking: 'allowScreenTracking', // Sessions use screen tracking flag\n    apiTracking: 'allowApiTracking',\n    screenTracking: 'allowScreenTracking',\n    crashReporting: 'allowCrashReporting',\n    logging: 'allowLogging',\n    businessConfig: 'allowBusinessConfig',\n    localization: 'allowLocalization',\n    customDomains: 'allowCustomDomains',\n    webhooks: 'allowWebhooks',\n    teamMembers: 'allowTeamMembers',\n    prioritySupport: 'allowPrioritySupport',\n  }\n\n  const planFlag = featureMap[feature]\n  if (!planFlag) return false\n\n  return plan[planFlag] === true\n}\n\n/**\n * Get usage statistics for a subscription\n */\nexport async function getUsageStats(userId: string) {\n  const subscription = await getSubscription(userId)\n  if (!subscription) {\n    return null\n  }\n\n  const plan = await getPlan(subscription.planId)\n  if (!plan) {\n    return null\n  }\n\n  // Use quota overrides if set, otherwise use plan defaults\n  const getLimit = (quotaOverride: number | null | undefined, planLimit: number | null) => {\n    return quotaOverride !== undefined && quotaOverride !== null ? quotaOverride : planLimit\n  }\n\n  const maxProjects = getLimit((subscription as any).quotaMaxProjects, plan.maxProjects)\n  const maxDevices = getLimit((subscription as any).quotaMaxDevices, plan.maxDevices)\n  const maxMockEndpoints = getLimit((subscription as any).quotaMaxMockEndpoints, plan.maxMockEndpoints)\n  const maxApiEndpoints = getLimit((subscription as any).quotaMaxApiEndpoints, plan.maxApiEndpoints)\n  const maxApiRequests = getLimit((subscription as any).quotaMaxApiRequests, plan.maxApiRequests)\n  const maxLogs = getLimit((subscription as any).quotaMaxLogs, plan.maxLogs)\n  const maxSessions = getLimit((subscription as any).quotaMaxSessions, plan.maxSessions)\n  const maxCrashes = getLimit((subscription as any).quotaMaxCrashes, plan.maxCrashes)\n  const maxBusinessConfigKeys = getLimit((subscription as any).quotaMaxBusinessConfigKeys, plan.maxBusinessConfigKeys)\n  const maxLocalizationLanguages = getLimit((subscription as any).quotaMaxLocalizationLanguages, plan.maxLocalizationLanguages)\n  const maxLocalizationKeys = getLimit((subscription as any).quotaMaxLocalizationKeys, plan.maxLocalizationKeys)\n\n  // FIXED: Use currentPeriodStart/currentPeriodEnd instead of trialStartDate/trialEndDate\n  const periodStart = subscription.currentPeriodStart\n  const periodEnd = subscription.currentPeriodEnd\n\n  // Count usage for current billing period\n  const [mockEndpoints, logs, sessions, crashes, devices, projects, apiEndpoints, apiRequests, businessConfigKeys, localizationLanguages, localizationKeys] = await Promise.all([\n    // Mock Endpoints: Lifetime meter (never reset)\n    prisma.mockEndpoint.count({\n      where: {\n        environment: {\n          project: { userId },\n        },\n      },\n    }),\n    prisma.log.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    prisma.session.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    prisma.crash.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // FIXED: Devices now period-based (resets monthly)\n    prisma.device.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // Projects: Lifetime meter (never reset)\n    prisma.project.count({\n      where: { userId },\n    }),\n    // API Endpoints: Unique endpoints in current period\n    prisma.apiTrace.groupBy({\n      by: ['url'],\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }).then(result => result.length),\n    // API Requests: Total requests in current period\n    prisma.apiTrace.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // Business Config Keys: Lifetime meter (never reset)\n    prisma.businessConfig.count({\n      where: { project: { userId } },\n    }),\n    // Localization Languages: Lifetime meter (never reset)\n    prisma.language.count({\n      where: { project: { userId } },\n    }),\n    // Localization Keys: Lifetime meter (never reset)\n    prisma.localizationKey.count({\n      where: { project: { userId } },\n    }),\n  ])\n\n  return {\n    mockEndpoints: {\n      used: mockEndpoints,\n      limit: maxMockEndpoints,\n      percentage: maxMockEndpoints ? (mockEndpoints / maxMockEndpoints) * 100 : 0,\n    },\n    apiEndpoints: {\n      used: apiEndpoints,\n      limit: maxApiEndpoints,\n      percentage: maxApiEndpoints ? (apiEndpoints / maxApiEndpoints) * 100 : 0,\n    },\n    apiRequests: {\n      used: apiRequests,\n      limit: maxApiRequests,\n      percentage: maxApiRequests ? (apiRequests / maxApiRequests) * 100 : 0,\n    },\n    logs: {\n      used: logs,\n      limit: maxLogs,\n      percentage: maxLogs ? (logs / maxLogs) * 100 : 0,\n    },\n    sessions: {\n      used: sessions,\n      limit: maxSessions,\n      percentage: maxSessions ? (sessions / maxSessions) * 100 : 0,\n    },\n    crashes: {\n      used: crashes,\n      limit: maxCrashes,\n      percentage: maxCrashes ? (crashes / maxCrashes) * 100 : 0,\n    },\n    devices: {\n      used: devices,\n      limit: maxDevices,\n      percentage: maxDevices ? (devices / maxDevices) * 100 : 0,\n    },\n    projects: {\n      used: projects,\n      limit: maxProjects,\n      percentage: maxProjects ? (projects / maxProjects) * 100 : 0,\n    },\n    businessConfigKeys: {\n      used: businessConfigKeys,\n      limit: maxBusinessConfigKeys,\n      percentage: maxBusinessConfigKeys ? (businessConfigKeys / maxBusinessConfigKeys) * 100 : 0,\n    },\n    localizationLanguages: {\n      used: localizationLanguages,\n      limit: maxLocalizationLanguages,\n      percentage: maxLocalizationLanguages ? (localizationLanguages / maxLocalizationLanguages) * 100 : 0,\n    },\n    localizationKeys: {\n      used: localizationKeys,\n      limit: maxLocalizationKeys,\n      percentage: maxLocalizationKeys ? (localizationKeys / maxLocalizationKeys) * 100 : 0,\n    },\n    trialActive: await isTrialActive(subscription),\n    trialEndDate: subscription.trialEndDate,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    daysRemaining: Math.max(\n      0,\n      Math.ceil((subscription.currentPeriodEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24))\n    ),\n  }\n}\n\n/**\n * Update subscription status to expired\n */\nexport async function expireSubscription(subscriptionId: string): Promise<void> {\n  await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'expired',\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 591, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/subscription-analytics.ts"],"sourcesContent":["import { prisma } from './prisma'\nimport { getUsageStats } from './subscription'\n\nexport type UsageSegment = 'low' | 'medium' | 'high' | 'exceeded'\nexport type PlanDistribution = {\n  planName: string\n  planDisplayName: string\n  count: number\n  percentage: number\n  totalRevenue: number\n}\n\nexport type UsageSegmentStats = {\n  segment: UsageSegment\n  label: string\n  count: number\n  percentage: number\n  users: Array<{\n    userId: string\n    email: string\n    planName: string\n    usagePercentage: number\n    meters: Record<string, { used: number; limit: number | null; percentage: number }>\n  }>\n}\n\nexport type SubscriptionAnalytics = {\n  planDistribution: PlanDistribution[]\n  usageSegmentation: {\n    devices: UsageSegmentStats[]\n    apiTraces: UsageSegmentStats[]\n    logs: UsageSegmentStats[]\n    sessions: UsageSegmentStats[]\n  }\n  atRiskUsers: Array<{\n    userId: string\n    email: string\n    planName: string\n    highestUsage: { meter: string; percentage: number }\n    allMeters: Record<string, { used: number; limit: number | null; percentage: number }>\n  }>\n  atLimitUsers: Array<{\n    userId: string\n    email: string\n    planName: string\n    exceededMeters: string[]\n    allMeters: Record<string, { used: number; limit: number | null; percentage: number }>\n  }>\n  conversionOpportunities: Array<{\n    userId: string\n    email: string\n    currentPlan: string\n    recommendedPlan: string\n    reason: string\n    usagePercentage: number\n  }>\n  summary: {\n    totalUsers: number\n    totalActiveSubscriptions: number\n    averageUsagePercentage: number\n    usersAtRisk: number\n    usersAtLimit: number\n    conversionOpportunities: number\n  }\n}\n\n/**\n * Get subscription analytics with usage segmentation\n */\nexport async function getSubscriptionAnalytics(): Promise<SubscriptionAnalytics> {\n  // Get all active subscriptions with users and plans\n  const subscriptions = await prisma.subscription.findMany({\n    where: {\n      status: 'active',\n      enabled: true,\n    },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          name: true,\n        },\n      },\n      plan: {\n        select: {\n          id: true,\n          name: true,\n          displayName: true,\n          price: true,\n        },\n      },\n    },\n  })\n\n  // Plan distribution\n  const planCounts: Record<string, { count: number; revenue: number }> = {}\n  subscriptions.forEach((sub) => {\n    const planName = sub.plan.name\n    if (!planCounts[planName]) {\n      planCounts[planName] = { count: 0, revenue: 0 }\n    }\n    planCounts[planName].count++\n    planCounts[planName].revenue += sub.plan.price\n  })\n\n  const totalSubscriptions = subscriptions.length\n  const planDistribution: PlanDistribution[] = Object.entries(planCounts).map(\n    ([planName, data]) => {\n      const plan = subscriptions.find((s) => s.plan.name === planName)?.plan\n      return {\n        planName,\n        planDisplayName: plan?.displayName || planName,\n        count: data.count,\n        percentage: totalSubscriptions > 0 ? (data.count / totalSubscriptions) * 100 : 0,\n        totalRevenue: data.revenue,\n      }\n    }\n  )\n\n  // Usage segmentation\n  const usageData: Array<{\n    userId: string\n    email: string\n    planName: string\n    usage: Awaited<ReturnType<typeof getUsageStats>>\n  }> = []\n\n  for (const sub of subscriptions) {\n    try {\n      const usage = await getUsageStats(sub.userId)\n      if (usage) {\n        usageData.push({\n          userId: sub.userId,\n          email: sub.user.email,\n          planName: sub.plan.name,\n          usage,\n        })\n      }\n    } catch (error) {\n      console.error(`Error getting usage for user ${sub.userId}:`, error)\n    }\n  }\n\n  // Segment users by usage percentage\n  function segmentByUsage(\n    meterKey: 'devices' | 'apiTraces' | 'logs' | 'sessions'\n  ): UsageSegmentStats[] {\n    const segments: Record<UsageSegment, typeof usageData> = {\n      low: [],\n      medium: [],\n      high: [],\n      exceeded: [],\n    }\n\n    usageData.forEach((data) => {\n      const meter = data.usage[meterKey]\n      if (!meter) return\n\n      const percentage = meter.percentage\n      let segment: UsageSegment\n\n      if (meter.limit === null) {\n        // Unlimited - consider as low usage\n        segment = 'low'\n      } else if (percentage >= 100) {\n        segment = 'exceeded'\n      } else if (percentage >= 80) {\n        segment = 'high'\n      } else if (percentage >= 50) {\n        segment = 'medium'\n      } else {\n        segment = 'low'\n      }\n\n      segments[segment].push(data)\n    })\n\n    return [\n      {\n        segment: 'low',\n        label: 'Low Usage (0-50%)',\n        count: segments.low.length,\n        percentage: usageData.length > 0 ? (segments.low.length / usageData.length) * 100 : 0,\n        users: segments.low.map((d) => ({\n          userId: d.userId,\n          email: d.email,\n          planName: d.planName,\n          usagePercentage: d.usage[meterKey]?.percentage || 0,\n          meters: {\n            devices: d.usage.devices,\n            apiTraces: d.usage.apiTraces,\n            logs: d.usage.logs,\n            sessions: d.usage.sessions,\n          },\n        })),\n      },\n      {\n        segment: 'medium',\n        label: 'Medium Usage (50-80%)',\n        count: segments.medium.length,\n        percentage: usageData.length > 0 ? (segments.medium.length / usageData.length) * 100 : 0,\n        users: segments.medium.map((d) => ({\n          userId: d.userId,\n          email: d.email,\n          planName: d.planName,\n          usagePercentage: d.usage[meterKey]?.percentage || 0,\n          meters: {\n            devices: d.usage.devices,\n            apiTraces: d.usage.apiTraces,\n            logs: d.usage.logs,\n            sessions: d.usage.sessions,\n          },\n        })),\n      },\n      {\n        segment: 'high',\n        label: 'High Usage (80-100%)',\n        count: segments.high.length,\n        percentage: usageData.length > 0 ? (segments.high.length / usageData.length) * 100 : 0,\n        users: segments.high.map((d) => ({\n          userId: d.userId,\n          email: d.email,\n          planName: d.planName,\n          usagePercentage: d.usage[meterKey]?.percentage || 0,\n          meters: {\n            devices: d.usage.devices,\n            apiTraces: d.usage.apiTraces,\n            logs: d.usage.logs,\n            sessions: d.usage.sessions,\n          },\n        })),\n      },\n      {\n        segment: 'exceeded',\n        label: 'Exceeded Limit (100%+)',\n        count: segments.exceeded.length,\n        percentage: usageData.length > 0 ? (segments.exceeded.length / usageData.length) * 100 : 0,\n        users: segments.exceeded.map((d) => ({\n          userId: d.userId,\n          email: d.email,\n          planName: d.planName,\n          usagePercentage: d.usage[meterKey]?.percentage || 0,\n          meters: {\n            devices: d.usage.devices,\n            apiTraces: d.usage.apiTraces,\n            logs: d.usage.logs,\n            sessions: d.usage.sessions,\n          },\n        })),\n      },\n    ]\n  }\n\n  // At-risk users (80%+ usage on any meter)\n  const atRiskUsers = usageData\n    .filter((d) => {\n      const meters = [d.usage.devices, d.usage.apiTraces, d.usage.logs, d.usage.sessions]\n      return meters.some((m) => m && m.limit !== null && m.percentage >= 80 && m.percentage < 100)\n    })\n    .map((d) => {\n      const meters = {\n        devices: d.usage.devices,\n        apiTraces: d.usage.apiTraces,\n        logs: d.usage.logs,\n        sessions: d.usage.sessions,\n      }\n      const highestUsage = Object.entries(meters)\n        .map(([key, meter]) => ({ meter: key, percentage: meter.percentage }))\n        .sort((a, b) => b.percentage - a.percentage)[0]\n\n      return {\n        userId: d.userId,\n        email: d.email,\n        planName: d.planName,\n        highestUsage,\n        allMeters: meters,\n      }\n    })\n    .sort((a, b) => b.highestUsage.percentage - a.highestUsage.percentage)\n\n  // At-limit users (100%+ usage on any meter)\n  const atLimitUsers = usageData\n    .filter((d) => {\n      const meters = [d.usage.devices, d.usage.apiTraces, d.usage.logs, d.usage.sessions]\n      return meters.some((m) => m && m.limit !== null && m.percentage >= 100)\n    })\n    .map((d) => {\n      const meters = {\n        devices: d.usage.devices,\n        apiTraces: d.usage.apiTraces,\n        logs: d.usage.logs,\n        sessions: d.usage.sessions,\n      }\n      const exceededMeters = Object.entries(meters)\n        .filter(([_, meter]) => meter.limit !== null && meter.percentage >= 100)\n        .map(([key]) => key)\n\n      return {\n        userId: d.userId,\n        email: d.email,\n        planName: d.planName,\n        exceededMeters,\n        allMeters: meters,\n      }\n    })\n\n  // Conversion opportunities (users on lower plans with high usage)\n  const conversionOpportunities: SubscriptionAnalytics['conversionOpportunities'] = []\n  const planHierarchy = ['free', 'pro', 'team', 'enterprise']\n  \n  usageData.forEach((d) => {\n    const currentPlanIndex = planHierarchy.indexOf(d.planName)\n    if (currentPlanIndex === -1 || currentPlanIndex === planHierarchy.length - 1) return\n\n    const meters = [d.usage.devices, d.usage.apiTraces, d.usage.logs, d.usage.sessions]\n    const maxUsage = Math.max(...meters.map((m) => m?.percentage || 0))\n\n    if (maxUsage >= 80) {\n      const recommendedPlan = planHierarchy[currentPlanIndex + 1]\n      conversionOpportunities.push({\n        userId: d.userId,\n        email: d.email,\n        currentPlan: d.planName,\n        recommendedPlan,\n        reason: `Usage at ${maxUsage.toFixed(1)}% - Consider upgrading to ${recommendedPlan}`,\n        usagePercentage: maxUsage,\n      })\n    }\n  })\n\n  // Calculate summary\n  const totalUsagePercentages = usageData.map((d) => {\n    const meters = [d.usage.devices, d.usage.apiTraces, d.usage.logs, d.usage.sessions]\n    return Math.max(...meters.map((m) => m?.percentage || 0))\n  })\n  const averageUsagePercentage =\n    totalUsagePercentages.length > 0\n      ? totalUsagePercentages.reduce((a, b) => a + b, 0) / totalUsagePercentages.length\n      : 0\n\n  return {\n    planDistribution,\n    usageSegmentation: {\n      devices: segmentByUsage('devices'),\n      apiTraces: segmentByUsage('apiTraces'),\n      logs: segmentByUsage('logs'),\n      sessions: segmentByUsage('sessions'),\n    },\n    atRiskUsers,\n    atLimitUsers,\n    conversionOpportunities: conversionOpportunities.sort((a, b) => b.usagePercentage - a.usagePercentage),\n    summary: {\n      totalUsers: subscriptions.length,\n      totalActiveSubscriptions: subscriptions.length,\n      averageUsagePercentage,\n      usersAtRisk: atRiskUsers.length,\n      usersAtLimit: atLimitUsers.length,\n      conversionOpportunities: conversionOpportunities.length,\n    },\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/app/api/admin/analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { validateAdmin } from '@/lib/auth'\nimport { getSubscriptionAnalytics } from '@/lib/subscription-analytics'\n\n/**\n * GET /api/admin/analytics\n * Get comprehensive subscription analytics\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const admin = await validateAdmin(request)\n    if (!admin) {\n      return NextResponse.json({ error: 'Unauthorized - Admin access required' }, { status: 403 })\n    }\n\n    const analytics = await getSubscriptionAnalytics()\n\n    return NextResponse.json({ analytics })\n  } catch (error) {\n    console.error('Get analytics error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,qIAAa,EAAC;QAClC,IAAI,CAAC,OAAO;YACV,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAuC,GAAG;gBAAE,QAAQ;YAAI;QAC5F;QAEA,MAAM,YAAY,MAAM,IAAA,qKAAwB;QAEhD,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE;QAAU;IACvC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,iTAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAyB,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAAgB,GACpG;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}