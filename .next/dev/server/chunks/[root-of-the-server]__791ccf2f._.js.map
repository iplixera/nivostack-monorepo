{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/mock.ts"],"sourcesContent":["import { prisma } from './prisma'\n\n/**\n * Check if an endpoint should be mocked based on environment mode\n */\nfunction shouldMockEndpoint(\n  path: string,\n  method: string,\n  environment: {\n    mode: string\n    whitelist: string[]\n    blacklist: string[]\n  },\n  endpointExists: boolean\n): boolean {\n  if (environment.mode === 'selective') {\n    // Only mock if endpoint exists in environment\n    return endpointExists\n  } else if (environment.mode === 'global') {\n    // Check all endpoints (will check if mock exists)\n    return true\n  } else if (environment.mode === 'whitelist') {\n    // Only mock if in whitelist\n    return environment.whitelist.some((pattern) => matchesPattern(path, pattern))\n  } else if (environment.mode === 'blacklist') {\n    // Mock all except blacklist\n    return !environment.blacklist.some((pattern) => matchesPattern(path, pattern))\n  }\n  return false\n}\n\n/**\n * Match path against pattern (supports wildcards and path params)\n */\nfunction matchesPattern(path: string, pattern: string): boolean {\n  // Convert pattern to regex\n  // e.g., \"/api/users/*\" → \"^/api/users/.*$\"\n  // e.g., \"/api/users/:id\" → \"^/api/users/[^/]+$\"\n  let regexPattern = pattern\n    .replace(/\\*/g, '.*') // Wildcard\n    .replace(/:[^/]+/g, '[^/]+') // Path params\n  regexPattern = `^${regexPattern}$`\n  \n  const regex = RegExp(regexPattern)\n  return regex.test(path)\n}\n\n/**\n * Match endpoint path pattern against request path\n */\nfunction matchEndpointPath(pattern: string, requestPath: string): {\n  matched: boolean\n  pathParams: Record<string, string>\n} {\n  const patternParts = pattern.split('/')\n  const requestParts = requestPath.split('/')\n  \n  if (patternParts.length !== requestParts.length) {\n    // Check for wildcard at end\n    if (pattern.endsWith('/*')) {\n      const basePattern = pattern.slice(0, -2)\n      if (requestPath.startsWith(basePattern)) {\n        return { matched: true, pathParams: {} }\n      }\n    }\n    return { matched: false, pathParams: {} }\n  }\n  \n  const pathParams: Record<string, string> = {}\n  let matched = true\n  \n  for (let i = 0; i < patternParts.length; i++) {\n    const patternPart = patternParts[i]\n    const requestPart = requestParts[i]\n    \n    if (patternPart.startsWith(':')) {\n      // Path parameter\n      const paramName = patternPart.slice(1)\n      pathParams[paramName] = requestPart\n    } else if (patternPart === '*') {\n      // Wildcard - matches anything\n      continue\n    } else if (patternPart !== requestPart) {\n      matched = false\n      break\n    }\n  }\n  \n  return { matched, pathParams }\n}\n\n/**\n * Evaluate condition against request data\n */\nfunction evaluateCondition(\n  condition: {\n    type: string\n    key: string\n    operator: string\n    value: string | null\n    isCaseSensitive: boolean\n  },\n  request: {\n    pathParams: Record<string, string>\n    query: Record<string, string>\n    headers: Record<string, string>\n    body: unknown\n  }\n): boolean {\n  let valueToCheck: string | null = null\n  \n  // Get value based on condition type\n  if (condition.type === 'path_param') {\n    valueToCheck = request.pathParams[condition.key] || null\n  } else if (condition.type === 'query_param') {\n    valueToCheck = request.query[condition.key] || null\n  } else if (condition.type === 'header') {\n    const headerKey = condition.isCaseSensitive\n      ? condition.key\n      : Object.keys(request.headers).find(k => k.toLowerCase() === condition.key.toLowerCase())\n    valueToCheck = headerKey ? request.headers[headerKey] || null : null\n  } else if (condition.type === 'body_json_path') {\n    // Simple JSON path evaluation (supports $.key.key)\n    try {\n      const body = typeof request.body === 'string' ? JSON.parse(request.body) : request.body\n      const path = condition.key.replace(/^\\$\\./, '').split('.')\n      let current: any = body\n      for (const key of path) {\n        if (current && typeof current === 'object' && key in current) {\n          current = current[key]\n        } else {\n          current = null\n          break\n        }\n      }\n      valueToCheck = current !== null && current !== undefined ? String(current) : null\n    } catch {\n      valueToCheck = null\n    }\n  }\n  \n  // Evaluate operator\n  if (condition.operator === 'exists') {\n    return valueToCheck !== null && valueToCheck !== undefined\n  } else if (condition.operator === 'not_exists') {\n    return valueToCheck === null || valueToCheck === undefined\n  }\n  \n  if (valueToCheck === null) {\n    return false\n  }\n  \n  const checkValue = condition.isCaseSensitive ? valueToCheck : valueToCheck.toLowerCase()\n  const matchValue = condition.value\n    ? (condition.isCaseSensitive ? condition.value : condition.value.toLowerCase())\n    : null\n  \n  switch (condition.operator) {\n    case 'equals':\n      return checkValue === matchValue\n    case 'contains':\n      return matchValue ? checkValue.includes(matchValue) : false\n    case 'matches':\n      // Regex match\n      try {\n        const regex = RegExp(matchValue || '')\n        return regex.test(checkValue)\n      } catch {\n        return false\n      }\n    case 'greater_than':\n      const num1 = parseFloat(checkValue)\n      const num2 = matchValue ? parseFloat(matchValue) : NaN\n      return !isNaN(num1) && !isNaN(num2) && num1 > num2\n    case 'less_than':\n      const num3 = parseFloat(checkValue)\n      const num4 = matchValue ? parseFloat(matchValue) : NaN\n      return !isNaN(num3) && !isNaN(num4) && num3 < num4\n    default:\n      return false\n  }\n}\n\n/**\n * Get mock response for a request\n */\nexport async function getMockResponse(\n  projectId: string,\n  environmentId: string | null,\n  path: string,\n  method: string,\n  query: Record<string, string> = {},\n  headers: Record<string, string> = {},\n  body: unknown = null\n): Promise<{\n  mockFound: boolean\n  statusCode?: number\n  headers?: Record<string, string>\n  body?: unknown\n  delay?: number\n  endpointId?: string\n  responseId?: string\n} | null> {\n  // Get environment (use default if not provided)\n  let environment\n  if (environmentId) {\n    environment = await prisma.mockEnvironment.findFirst({\n      where: {\n        id: environmentId,\n        projectId,\n        isEnabled: true,\n      },\n    })\n  } else {\n    environment = await prisma.mockEnvironment.findFirst({\n      where: {\n        projectId,\n        isEnabled: true,\n        isDefault: true,\n      },\n    })\n  }\n  \n  if (!environment) {\n    return { mockFound: false }\n  }\n  \n  // Get all enabled endpoints for this environment\n  const endpoints = await prisma.mockEndpoint.findMany({\n    where: {\n      environmentId: environment.id,\n      isEnabled: true,\n      method: method.toUpperCase(),\n    },\n    include: {\n      responses: {\n        where: { isEnabled: true },\n        include: {\n          conditions: {\n            orderBy: { order: 'asc' },\n          },\n        },\n        orderBy: [{ order: 'asc' }, { isDefault: 'desc' }],\n      },\n      conditions: {\n        orderBy: { order: 'asc' },\n      },\n    },\n    orderBy: { order: 'asc' },\n  })\n  \n  // Find matching endpoint\n  for (const endpoint of endpoints) {\n    const { matched, pathParams } = matchEndpointPath(endpoint.path, path)\n    \n    if (!matched) {\n      continue\n    }\n    \n    // Check endpoint-level conditions\n    let endpointMatches = true\n    if (endpoint.conditions.length > 0) {\n      for (const condition of endpoint.conditions) {\n        if (!evaluateCondition(condition, { pathParams, query, headers, body })) {\n          endpointMatches = false\n          break\n        }\n      }\n    }\n    \n    if (!endpointMatches) {\n      continue\n    }\n    \n    // Check if should mock based on environment mode\n    const shouldMock = shouldMockEndpoint(path, method, environment, true)\n    if (!shouldMock) {\n      return { mockFound: false }\n    }\n    \n    // Find matching response\n    for (const response of endpoint.responses) {\n      // Check response-level conditions\n      let responseMatches = true\n      if (response.conditions.length > 0) {\n        for (const condition of response.conditions) {\n          if (!evaluateCondition(condition, { pathParams, query, headers, body })) {\n            responseMatches = false\n            break\n          }\n        }\n      } else {\n        // No conditions = default response\n        responseMatches = true\n      }\n      \n      if (responseMatches) {\n        return {\n          mockFound: true,\n          statusCode: response.statusCode,\n          headers: (response.responseHeaders as Record<string, string>) || {},\n          body: response.responseBody,\n          delay: response.delay,\n          endpointId: endpoint.id,\n          responseId: response.id,\n        }\n      }\n    }\n    \n    // If no response matched, check for default response\n    const defaultResponse = endpoint.responses.find((r) => r.isDefault)\n    if (defaultResponse) {\n      return {\n        mockFound: true,\n        statusCode: defaultResponse.statusCode,\n        headers: (defaultResponse.responseHeaders as Record<string, string>) || {},\n        body: defaultResponse.responseBody,\n        delay: defaultResponse.delay,\n        endpointId: endpoint.id,\n        responseId: defaultResponse.id,\n      }\n    }\n  }\n  \n  // Check mode to determine if we should return mockFound: false\n  // In selective mode, if no endpoint matched, return false\n  // In global mode, if no endpoint matched, return false (SDK will forward to real API)\n  const endpointExists = endpoints.length > 0\n  const shouldMock = shouldMockEndpoint(path, method, environment, endpointExists)\n  \n  if (!shouldMock) {\n    return { mockFound: false }\n  }\n  \n  // No mock found, but should check mocks\n  return { mockFound: false }\n}\n\n/**\n * Create mock environment\n */\nexport async function createMockEnvironment(\n  projectId: string,\n  userId: string,\n  data: {\n    name: string\n    description?: string\n    basePath?: string\n    mode?: string\n    whitelist?: string[]\n    blacklist?: string[]\n    isDefault?: boolean\n  }\n) {\n  // If setting as default, unset other defaults\n  if (data.isDefault) {\n    await prisma.mockEnvironment.updateMany({\n      where: { projectId, isDefault: true },\n      data: { isDefault: false },\n    })\n  }\n  \n  return prisma.mockEnvironment.create({\n    data: {\n      projectId,\n      name: data.name,\n      description: data.description,\n      basePath: data.basePath,\n      mode: data.mode || 'selective',\n      whitelist: data.whitelist || [],\n      blacklist: data.blacklist || [],\n      isDefault: data.isDefault || false,\n      createdBy: userId,\n    },\n  })\n}\n\n/**\n * Get mock environments for a project\n */\nexport async function getMockEnvironments(projectId: string) {\n  return prisma.mockEnvironment.findMany({\n    where: { projectId },\n    include: {\n      _count: {\n        select: {\n          endpoints: true,\n        },\n      },\n    },\n    orderBy: [{ isDefault: 'desc' }, { createdAt: 'desc' }],\n  })\n}\n\n/**\n * Get mock environment by ID\n */\nexport async function getMockEnvironment(environmentId: string) {\n  return prisma.mockEnvironment.findUnique({\n    where: { id: environmentId },\n    include: {\n      endpoints: {\n        include: {\n          responses: {\n            include: {\n              conditions: true,\n            },\n            orderBy: [{ order: 'asc' }, { isDefault: 'desc' }],\n          },\n          conditions: true,\n        },\n        orderBy: { order: 'asc' },\n      },\n    },\n  })\n}\n\n/**\n * Create mock endpoint\n */\nexport async function createMockEndpoint(\n  environmentId: string,\n  data: {\n    path: string\n    method: string\n    description?: string\n    order?: number\n  }\n) {\n  return prisma.mockEndpoint.create({\n    data: {\n      environmentId,\n      path: data.path,\n      method: data.method.toUpperCase(),\n      description: data.description,\n      order: data.order || 0,\n    },\n  })\n}\n\n/**\n * Create mock response\n */\nexport async function createMockResponse(\n  endpointId: string,\n  data: {\n    statusCode: number\n    name?: string\n    description?: string\n    responseBody?: unknown\n    responseHeaders?: Record<string, string>\n    delay?: number\n    isDefault?: boolean\n    order?: number\n  }\n) {\n  // If setting as default, unset other defaults for this endpoint\n  if (data.isDefault) {\n    await prisma.mockResponse.updateMany({\n      where: { endpointId, isDefault: true },\n      data: { isDefault: false },\n    })\n  }\n  \n  return prisma.mockResponse.create({\n    data: {\n      endpointId,\n      statusCode: data.statusCode,\n      name: data.name,\n      description: data.description,\n      responseBody: data.responseBody as any,\n      responseHeaders: data.responseHeaders as any,\n      delay: data.delay || 0,\n      isDefault: data.isDefault || false,\n      order: data.order || 0,\n    },\n  })\n}\n\n/**\n * Create mock condition\n */\nexport async function createMockCondition(\n  data: {\n    responseId?: string\n    endpointId?: string\n    type: string\n    key: string\n    operator: string\n    value?: string\n    isCaseSensitive?: boolean\n    order?: number\n  }\n) {\n  return prisma.mockCondition.create({\n    data: {\n      responseId: data.responseId,\n      endpointId: data.endpointId,\n      type: data.type,\n      key: data.key,\n      operator: data.operator,\n      value: data.value,\n      isCaseSensitive: data.isCaseSensitive || false,\n      order: data.order || 0,\n    },\n  })\n}\n\n/**\n * Update mock environment\n */\nexport async function updateMockEnvironment(\n  environmentId: string,\n  data: {\n    name?: string\n    description?: string\n    basePath?: string\n    mode?: string\n    whitelist?: string[]\n    blacklist?: string[]\n    isEnabled?: boolean\n    isDefault?: boolean\n  }\n) {\n  // If setting as default, unset other defaults\n  if (data.isDefault) {\n    const env = await prisma.mockEnvironment.findUnique({\n      where: { id: environmentId },\n      select: { projectId: true },\n    })\n    if (env) {\n      await prisma.mockEnvironment.updateMany({\n        where: { projectId: env.projectId, isDefault: true, id: { not: environmentId } },\n        data: { isDefault: false },\n      })\n    }\n  }\n  \n  return prisma.mockEnvironment.update({\n    where: { id: environmentId },\n    data,\n  })\n}\n\n/**\n * Delete mock environment\n */\nexport async function deleteMockEnvironment(environmentId: string) {\n  return prisma.mockEnvironment.delete({\n    where: { id: environmentId },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/app/api/mocks/environments/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthUser } from '@/lib/auth'\nimport { createMockEnvironment, getMockEnvironments } from '@/lib/mock'\nimport { prisma } from '@/lib/prisma'\n\n/**\n * POST /api/mocks/environments - Create mock environment\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getAuthUser(request)\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { projectId, name, description, basePath, mode, whitelist, blacklist, isDefault } =\n      await request.json()\n\n    if (!projectId || !name) {\n      return NextResponse.json(\n        { error: 'projectId and name are required' },\n        { status: 400 }\n      )\n    }\n\n    // Verify project ownership\n    const project = await prisma.project.findFirst({\n      where: {\n        id: projectId,\n        userId: user.id,\n      },\n    })\n\n    if (!project) {\n      return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n    }\n\n    const environment = await createMockEnvironment(projectId, user.id, {\n      name,\n      description,\n      basePath,\n      mode: mode || 'selective',\n      whitelist: whitelist || [],\n      blacklist: blacklist || [],\n      isDefault: isDefault || false,\n    })\n\n    return NextResponse.json({ environment })\n  } catch (error) {\n    console.error('Create mock environment error:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * GET /api/mocks/environments - List mock environments\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const user = await getAuthUser(request)\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const projectId = searchParams.get('projectId')\n\n    if (!projectId) {\n      return NextResponse.json({ error: 'projectId is required' }, { status: 400 })\n    }\n\n    // Verify project ownership\n    const project = await prisma.project.findFirst({\n      where: {\n        id: projectId,\n        userId: user.id,\n      },\n    })\n\n    if (!project) {\n      return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n    }\n\n    const environments = await getMockEnvironments(projectId)\n\n    return NextResponse.json({ environments })\n  } catch (error) {\n    console.error('Get mock environments error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAKO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,mIAAW,EAAC;QAC/B,IAAI,CAAC,MAAM;YACT,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,GACrF,MAAM,QAAQ,IAAI;QAEpB,IAAI,CAAC,aAAa,CAAC,MAAM;YACvB,OAAO,iTAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,2BAA2B;QAC3B,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,SAAS,CAAC;YAC7C,OAAO;gBACL,IAAI;gBACJ,QAAQ,KAAK,EAAE;YACjB;QACF;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,MAAM,cAAc,MAAM,IAAA,6IAAqB,EAAC,WAAW,KAAK,EAAE,EAAE;YAClE;YACA;YACA;YACA,MAAM,QAAQ;YACd,WAAW,aAAa,EAAE;YAC1B,WAAW,aAAa,EAAE;YAC1B,WAAW,aAAa;QAC1B;QAEA,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE;QAAY;IACzC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,iTAAY,CAAC,IAAI,CACtB;YAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAAwB,GAC1E;YAAE,QAAQ;QAAI;IAElB;AACF;AAKO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,mIAAW,EAAC;QAC/B,IAAI,CAAC,MAAM;YACT,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,YAAY,aAAa,GAAG,CAAC;QAEnC,IAAI,CAAC,WAAW;YACd,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAwB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,2BAA2B;QAC3B,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,SAAS,CAAC;YAC7C,OAAO;gBACL,IAAI;gBACJ,QAAQ,KAAK,EAAE;YACjB;QACF;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,MAAM,eAAe,MAAM,IAAA,2IAAmB,EAAC;QAE/C,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE;QAAa;IAC1C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF"}}]
}