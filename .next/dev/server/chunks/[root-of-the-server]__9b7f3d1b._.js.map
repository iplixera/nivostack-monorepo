{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,gIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/devbridge/src/app/api/config/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { verifyToken } from '@/lib/auth'\n\n// GET - List all API configs for a project (dashboard) or get configs for device\nexport async function GET(request: NextRequest) {\n  try {\n    const apiKey = request.headers.get('x-api-key')\n    const authHeader = request.headers.get('authorization')\n    const projectId = request.nextUrl.searchParams.get('projectId')\n\n    // Device request - return configs for SDK\n    if (apiKey) {\n      const project = await prisma.project.findUnique({\n        where: { apiKey }\n      })\n\n      if (!project) {\n        return NextResponse.json({ error: 'Invalid API key' }, { status: 401 })\n      }\n\n      const configs = await prisma.apiConfig.findMany({\n        where: {\n          projectId: project.id,\n          isEnabled: true\n        },\n        select: {\n          endpoint: true,\n          method: true,\n          costPerRequest: true,\n          name: true\n        }\n      })\n\n      return NextResponse.json({ configs })\n    }\n\n    // Dashboard request - return full configs\n    if (authHeader && projectId) {\n      const token = authHeader.replace('Bearer ', '')\n      const payload = verifyToken(token)\n\n      if (!payload) {\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n      }\n\n      // Verify project ownership\n      const project = await prisma.project.findFirst({\n        where: {\n          id: projectId,\n          userId: payload.userId\n        }\n      })\n\n      if (!project) {\n        return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n      }\n\n      const configs = await prisma.apiConfig.findMany({\n        where: { projectId },\n        orderBy: { createdAt: 'desc' }\n      })\n\n      // Get unique endpoints from traces that don't have configs yet\n      const tracedEndpoints = await prisma.apiTrace.findMany({\n        where: { projectId },\n        select: {\n          url: true,\n          method: true\n        },\n        distinct: ['url', 'method']\n      })\n\n      // Extract endpoint paths from full URLs\n      const suggestedEndpoints = tracedEndpoints.map(t => {\n        try {\n          const url = new URL(t.url)\n          return {\n            endpoint: url.pathname,\n            method: t.method,\n            fullUrl: t.url\n          }\n        } catch {\n          return {\n            endpoint: t.url,\n            method: t.method,\n            fullUrl: t.url\n          }\n        }\n      }).filter(e => !configs.some(c =>\n        c.endpoint === e.endpoint && (c.method === null || c.method === e.method)\n      ))\n\n      return NextResponse.json({ configs, suggestedEndpoints })\n    }\n\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  } catch (error) {\n    console.error('Config GET error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// POST - Create a new API config\nexport async function POST(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    console.log('Config POST body:', JSON.stringify(body))\n    const { projectId, endpoint, method, name, description, costPerRequest, isEnabled } = body\n\n    if (!projectId || !endpoint) {\n      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })\n    }\n\n    // Verify project ownership\n    const project = await prisma.project.findFirst({\n      where: {\n        id: projectId,\n        userId: payload.userId\n      }\n    })\n\n    if (!project) {\n      return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n    }\n\n    const configCost = Number(costPerRequest) || 0\n    console.log('Config POST creating with cost:', configCost)\n\n    const config = await prisma.apiConfig.create({\n      data: {\n        projectId,\n        endpoint,\n        method: method || null,\n        name: name || null,\n        description: description || null,\n        costPerRequest: configCost,\n        isEnabled: isEnabled !== false\n      }\n    })\n\n    console.log('Config POST result:', JSON.stringify(config))\n\n    // Apply cost to existing traces that match this endpoint\n    if (configCost > 0 && config.isEnabled) {\n      const endpointPattern = config.endpoint.endsWith('/*')\n        ? config.endpoint.slice(0, -2)\n        : config.endpoint\n\n      const tracesToUpdate = await prisma.apiTrace.findMany({\n        where: {\n          projectId: config.projectId,\n          url: { contains: endpointPattern }\n        },\n        select: { id: true, url: true, method: true }\n      })\n\n      let updatedCount = 0\n      for (const trace of tracesToUpdate) {\n        try {\n          const urlObj = new URL(trace.url)\n          const tracePath = urlObj.pathname\n\n          const isMatch = config.endpoint.endsWith('/*')\n            ? tracePath.startsWith(endpointPattern)\n            : tracePath === config.endpoint\n\n          const methodMatch = !config.method || config.method === trace.method\n\n          if (isMatch && methodMatch) {\n            await prisma.apiTrace.update({\n              where: { id: trace.id },\n              data: { cost: config.costPerRequest }\n            })\n            updatedCount++\n          }\n        } catch {\n          // URL parsing failed, skip\n        }\n      }\n      console.log(`Config POST: Updated ${updatedCount} traces with new cost`)\n    }\n\n    return NextResponse.json({ config })\n  } catch (error: unknown) {\n    console.error('Config POST error:', error)\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'P2002') {\n      return NextResponse.json({ error: 'Config for this endpoint already exists' }, { status: 409 })\n    }\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// PUT - Update an API config\nexport async function PUT(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    console.log('Config PUT body:', JSON.stringify(body))\n    const { id, endpoint, method, name, description, costPerRequest, isEnabled } = body\n\n    if (!id) {\n      return NextResponse.json({ error: 'Missing config ID' }, { status: 400 })\n    }\n\n    // Verify config ownership\n    const existingConfig = await prisma.apiConfig.findUnique({\n      where: { id },\n      include: { project: true }\n    })\n\n    if (!existingConfig || existingConfig.project.userId !== payload.userId) {\n      return NextResponse.json({ error: 'Config not found' }, { status: 404 })\n    }\n\n    // Prepare update data - use explicit null check to allow setting to null/0\n    const updateData: Record<string, unknown> = {}\n    if (endpoint !== undefined) updateData.endpoint = endpoint\n    if (method !== undefined) updateData.method = method || null\n    if (name !== undefined) updateData.name = name || null\n    if (description !== undefined) updateData.description = description || null\n    if (costPerRequest !== undefined) updateData.costPerRequest = Number(costPerRequest) || 0\n    if (isEnabled !== undefined) updateData.isEnabled = isEnabled\n\n    console.log('Config PUT updateData:', JSON.stringify(updateData))\n\n    const config = await prisma.apiConfig.update({\n      where: { id },\n      data: updateData\n    })\n\n    console.log('Config PUT result:', JSON.stringify(config))\n\n    // Recalculate costs for existing traces that match this endpoint\n    if (costPerRequest !== undefined && config.isEnabled) {\n      const endpointPattern = config.endpoint.endsWith('/*')\n        ? config.endpoint.slice(0, -2)\n        : config.endpoint\n\n      // Update traces that match this endpoint pattern\n      const tracesToUpdate = await prisma.apiTrace.findMany({\n        where: {\n          projectId: config.projectId,\n          url: { contains: endpointPattern }\n        },\n        select: { id: true, url: true, method: true }\n      })\n\n      for (const trace of tracesToUpdate) {\n        try {\n          const urlObj = new URL(trace.url)\n          const tracePath = urlObj.pathname\n\n          // Check if this trace matches the config\n          const isMatch = config.endpoint.endsWith('/*')\n            ? tracePath.startsWith(endpointPattern)\n            : tracePath === config.endpoint\n\n          const methodMatch = !config.method || config.method === trace.method\n\n          if (isMatch && methodMatch) {\n            await prisma.apiTrace.update({\n              where: { id: trace.id },\n              data: { cost: config.costPerRequest }\n            })\n          }\n        } catch {\n          // URL parsing failed, skip\n        }\n      }\n    }\n\n    return NextResponse.json({ config })\n  } catch (error) {\n    console.error('Config PUT error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n// DELETE - Delete an API config\nexport async function DELETE(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    const configId = request.nextUrl.searchParams.get('id')\n\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.replace('Bearer ', '')\n    const payload = verifyToken(token)\n\n    if (!payload) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    if (!configId) {\n      return NextResponse.json({ error: 'Missing config ID' }, { status: 400 })\n    }\n\n    // Verify config ownership\n    const existingConfig = await prisma.apiConfig.findUnique({\n      where: { id: configId },\n      include: { project: true }\n    })\n\n    if (!existingConfig || existingConfig.project.userId !== payload.userId) {\n      return NextResponse.json({ error: 'Config not found' }, { status: 404 })\n    }\n\n    await prisma.apiConfig.delete({\n      where: { id: configId }\n    })\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('Config DELETE error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":"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"}}]
}