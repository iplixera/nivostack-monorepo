{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\n/**\n * Primary Prisma Client (Read/Write)\n * \n * Use this client for all write operations and when read replica is not needed.\n * This connects to the primary database.\n */\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n  \n  // In development, ensure Prisma client is properly initialized\n  if (typeof prisma.user === 'undefined') {\n    console.warn('⚠️  Prisma client models not available. Restart dev server after running: pnpm prisma generate')\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;;;CAKC,GAED,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;IAEzB,+DAA+D;IAC/D,IAAI,OAAO,OAAO,IAAI,KAAK,aAAa;QACtC,QAAQ,IAAI,CAAC;IACf;AACF"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,6IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/team-access.ts"],"sourcesContent":["/**\n * Team Access Control Utilities\n * \n * Helper functions for checking user roles and permissions in projects\n */\n\nimport { prisma } from './prisma'\n\nexport type ProjectRole = 'owner' | 'admin' | 'member' | 'viewer'\n\nexport interface ProjectMemberWithUser {\n  id: string\n  role: ProjectRole\n  user: {\n    id: string\n    email: string\n    name: string | null\n  }\n  invitedBy: string | null\n  invitedAt: Date\n  joinedAt: Date | null\n}\n\n/**\n * Get user's role in a project\n */\nexport async function getUserProjectRole(\n  userId: string,\n  projectId: string\n): Promise<ProjectRole | null> {\n  const member = await prisma.projectMember.findUnique({\n    where: {\n      projectId_userId: {\n        projectId,\n        userId,\n      },\n    },\n    select: {\n      role: true,\n    },\n  })\n\n  return member?.role as ProjectRole | null\n}\n\n/**\n * Check if user has a specific role (or higher) in a project\n * Role hierarchy: owner > admin > member > viewer\n */\nexport async function hasProjectRole(\n  userId: string,\n  projectId: string,\n  requiredRole: ProjectRole\n): Promise<boolean> {\n  const userRole = await getUserProjectRole(userId, projectId)\n\n  if (!userRole) {\n    // Check if user is the project owner (backward compatibility)\n    const project = await prisma.project.findUnique({\n      where: { id: projectId },\n      select: { userId: true },\n    })\n\n    if (project?.userId === userId) {\n      // User is owner via legacy userId field\n      return requiredRole === 'owner' || requiredRole === 'admin' || requiredRole === 'member' || requiredRole === 'viewer'\n    }\n\n    return false\n  }\n\n  const roleHierarchy: Record<ProjectRole, number> = {\n    owner: 4,\n    admin: 3,\n    member: 2,\n    viewer: 1,\n  }\n\n  return roleHierarchy[userRole] >= roleHierarchy[requiredRole]\n}\n\n/**\n * Check if user can perform an action based on role\n */\nexport async function canPerformAction(\n  userId: string,\n  projectId: string,\n  action: 'invite' | 'remove_member' | 'change_role' | 'transfer_ownership' | 'delete_project' | 'manage_settings' | 'edit_config' | 'view'\n): Promise<boolean> {\n  const role = await getUserProjectRole(userId, projectId)\n\n  // If no role, check if user is project owner (backward compatibility)\n  if (!role) {\n    const project = await prisma.project.findUnique({\n      where: { id: projectId },\n      select: { userId: true },\n    })\n\n    if (project?.userId === userId) {\n      // Legacy owner - can do everything\n      return true\n    }\n\n    return false\n  }\n\n  // Role-based permissions\n  const permissions: Record<ProjectRole, string[]> = {\n    owner: [\n      'invite',\n      'remove_member',\n      'change_role',\n      'transfer_ownership',\n      'delete_project',\n      'manage_settings',\n      'edit_config',\n      'view',\n    ],\n    admin: [\n      'invite',\n      'remove_member',\n      'change_role',\n      'manage_settings',\n      'edit_config',\n      'view',\n    ],\n    member: [\n      'edit_config',\n      'view',\n    ],\n    viewer: [\n      'view',\n    ],\n  }\n\n  return permissions[role]?.includes(action) ?? false\n}\n\n/**\n * Get all members of a project\n */\nexport async function getProjectMembers(projectId: string): Promise<ProjectMemberWithUser[]> {\n  const members = await prisma.projectMember.findMany({\n    where: { projectId },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: [\n      { role: 'asc' }, // owner first, then admin, member, viewer\n      { joinedAt: 'asc' },\n    ],\n  })\n\n  return members.map((m) => ({\n    id: m.id,\n    role: m.role as ProjectRole,\n    user: m.user,\n    invitedBy: m.invitedBy,\n    invitedAt: m.invitedAt,\n    joinedAt: m.joinedAt,\n  }))\n}\n\n/**\n * Check seat limits for a plan\n */\nexport async function checkSeatLimit(projectId: string): Promise<{ allowed: boolean; current: number; limit: number | null }> {\n  // Get project owner's subscription\n  const project = await prisma.project.findUnique({\n    where: { id: projectId },\n    include: {\n      user: {\n        include: {\n          subscription: {\n            include: {\n              plan: true,\n            },\n          },\n        },\n      },\n    },\n  })\n\n  if (!project) {\n    return { allowed: false, current: 0, limit: null }\n  }\n\n  const plan = project.user.subscription?.plan\n  const maxSeats = plan?.maxTeamMembers ?? plan?.maxSeats ?? null\n\n  // Count current members\n  const currentMembers = await prisma.projectMember.count({\n    where: { projectId },\n  })\n\n  // If no limit, allow unlimited\n  if (maxSeats === null) {\n    return { allowed: true, current: currentMembers, limit: null }\n  }\n\n  return {\n    allowed: currentMembers < maxSeats,\n    current: currentMembers,\n    limit: maxSeats,\n  }\n}\n\n/**\n * Get invitation expiry days from system configuration\n */\nexport async function getInvitationExpiryDays(): Promise<number> {\n  const config = await prisma.systemConfiguration.findUnique({\n    where: {\n      category_key: {\n        category: 'notifications',\n        key: 'invitation_expiry_days',\n      },\n    },\n  })\n\n  if (config?.value) {\n    const days = parseInt(config.value, 10)\n    if (!isNaN(days) && days > 0) {\n      return days\n    }\n  }\n\n  return 7 // Default: 7 days\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 447, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/notifications.ts"],"sourcesContent":["/**\n * Notification Utilities\n * \n * Helper functions for creating and managing user notifications\n */\n\nimport { prisma } from './prisma'\n\nexport type NotificationType = 'invitation' | 'project_update' | 'alert' | 'system'\n\nexport interface CreateNotificationParams {\n  userId: string\n  type: NotificationType\n  title: string\n  message: string\n  data?: Record<string, any>\n  actionUrl?: string\n}\n\n/**\n * Create a notification for a user\n */\nexport async function createNotification(params: CreateNotificationParams) {\n  return await prisma.userNotification.create({\n    data: {\n      userId: params.userId,\n      type: params.type,\n      title: params.title,\n      message: params.message,\n      data: params.data || null,\n      actionUrl: params.actionUrl || null,\n    },\n  })\n}\n\n/**\n * Create invitation notification\n */\nexport async function createInvitationNotification(\n  userId: string,\n  projectId: string,\n  invitationId: string,\n  projectName: string,\n  inviterName: string,\n  role: string,\n  invitationToken?: string\n) {\n  return await createNotification({\n    userId,\n    type: 'invitation',\n    title: `You've been invited to join ${projectName}`,\n    message: `${inviterName} has invited you to join the \"${projectName}\" project as a ${role}.`,\n    data: {\n      projectId,\n      invitationId,\n      role,\n      token: invitationToken, // Include token for direct acceptance\n    },\n    actionUrl: `/team?project=${projectId}`, // Link to team page where they can accept\n  })\n}\n\n/**\n * Mark notification as read\n */\nexport async function markNotificationAsRead(notificationId: string, userId: string) {\n  return await prisma.userNotification.updateMany({\n    where: {\n      id: notificationId,\n      userId, // Ensure user owns the notification\n    },\n    data: {\n      read: true,\n      readAt: new Date(),\n    },\n  })\n}\n\n/**\n * Mark all notifications as read for a user\n */\nexport async function markAllNotificationsAsRead(userId: string) {\n  return await prisma.userNotification.updateMany({\n    where: {\n      userId,\n      read: false,\n    },\n    data: {\n      read: true,\n      readAt: new Date(),\n    },\n  })\n}\n\n/**\n * Get user's unread notification count\n */\nexport async function getUnreadNotificationCount(userId: string): Promise<number> {\n  return await prisma.userNotification.count({\n    where: {\n      userId,\n      read: false,\n    },\n  })\n}\n\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;;;AAED;;AAgBO,eAAe,mBAAmB,MAAgC;IACvE,OAAO,MAAM,6IAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC;QAC1C,MAAM;YACJ,QAAQ,OAAO,MAAM;YACrB,MAAM,OAAO,IAAI;YACjB,OAAO,OAAO,KAAK;YACnB,SAAS,OAAO,OAAO;YACvB,MAAM,OAAO,IAAI,IAAI;YACrB,WAAW,OAAO,SAAS,IAAI;QACjC;IACF;AACF;AAKO,eAAe,6BACpB,MAAc,EACd,SAAiB,EACjB,YAAoB,EACpB,WAAmB,EACnB,WAAmB,EACnB,IAAY,EACZ,eAAwB;IAExB,OAAO,MAAM,mBAAmB;QAC9B;QACA,MAAM;QACN,OAAO,CAAC,4BAA4B,EAAE,aAAa;QACnD,SAAS,GAAG,YAAY,8BAA8B,EAAE,YAAY,eAAe,EAAE,KAAK,CAAC,CAAC;QAC5F,MAAM;YACJ;YACA;YACA;YACA,OAAO;QACT;QACA,WAAW,CAAC,cAAc,EAAE,WAAW;IACzC;AACF;AAKO,eAAe,uBAAuB,cAAsB,EAAE,MAAc;IACjF,OAAO,MAAM,6IAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC;QAC9C,OAAO;YACL,IAAI;YACJ;QACF;QACA,MAAM;YACJ,MAAM;YACN,QAAQ,IAAI;QACd;IACF;AACF;AAKO,eAAe,2BAA2B,MAAc;IAC7D,OAAO,MAAM,6IAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC;QAC9C,OAAO;YACL;YACA,MAAM;QACR;QACA,MAAM;YACJ,MAAM;YACN,QAAQ,IAAI;QACd;IACF;AACF;AAKO,eAAe,2BAA2B,MAAc;IAC7D,OAAO,MAAM,6IAAM,CAAC,gBAAgB,CAAC,KAAK,CAAC;QACzC,OAAO;YACL;YACA,MAAM;QACR;IACF;AACF"}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/app/api/projects/%5Bid%5D/invitations/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getAuthUser } from '@/lib/auth'\nimport { canPerformAction, checkSeatLimit, getInvitationExpiryDays } from '@/lib/team-access'\nimport { createInvitationNotification } from '@/lib/notifications'\n\n/**\n * GET /api/projects/[id]/invitations\n * List all invitations for a project\n */\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const user = await getAuthUser(request)\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { id: projectId } = await params\n\n    // Check if user can view project (must be member)\n    const canView = await canPerformAction(user.id, projectId, 'view')\n    if (!canView) {\n      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\n    }\n\n    // Get invitations\n    const invitations = await prisma.projectInvitation.findMany({\n      where: { projectId },\n      include: {\n        inviter: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n        project: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n      orderBy: { invitedAt: 'desc' },\n    })\n\n    return NextResponse.json({\n      invitations: invitations.map((inv) => ({\n        id: inv.id,\n        email: inv.email,\n        role: inv.role,\n        invitedBy: {\n          id: inv.inviter.id,\n          name: inv.inviter.name,\n          email: inv.inviter.email,\n        },\n        invitedAt: inv.invitedAt.toISOString(),\n        expiresAt: inv.expiresAt.toISOString(),\n        status: inv.status,\n        emailSent: inv.emailSent,\n        emailSentAt: inv.emailSentAt?.toISOString() || null,\n        emailDelivered: inv.emailDelivered,\n        emailOpened: inv.emailOpened,\n        emailClicked: inv.emailClicked,\n        resendCount: inv.resendCount,\n        lastResentAt: inv.lastResentAt?.toISOString() || null,\n        lastResentBy: inv.lastResentBy || null,\n      })),\n    })\n  } catch (error) {\n    console.error('Get invitations error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * POST /api/projects/[id]/invitations\n * Send invitation by email\n */\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const user = await getAuthUser(request)\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { id: projectId } = await params\n    const { email, role = 'member', message } = await request.json()\n\n    if (!email) {\n      return NextResponse.json(\n        { error: 'Email is required' },\n        { status: 400 }\n      )\n    }\n\n    // Validate role\n    const validRoles = ['admin', 'member', 'viewer']\n    if (!validRoles.includes(role)) {\n      return NextResponse.json(\n        { error: `Invalid role. Must be one of: ${validRoles.join(', ')}` },\n        { status: 400 }\n      )\n    }\n\n    // Check if user can invite members\n    const canInvite = await canPerformAction(user.id, projectId, 'invite')\n    if (!canInvite) {\n      return NextResponse.json(\n        { error: 'You do not have permission to invite members' },\n        { status: 403 }\n      )\n    }\n\n    // Check seat limits\n    const seatCheck = await checkSeatLimit(projectId)\n    if (!seatCheck.allowed) {\n      return NextResponse.json(\n        {\n          error: `Seat limit reached. Current: ${seatCheck.current}, Limit: ${seatCheck.limit}`,\n          current: seatCheck.current,\n          limit: seatCheck.limit,\n        },\n        { status: 403 }\n      )\n    }\n\n    // Check if user is already a member\n    const existingMember = await prisma.projectMember.findFirst({\n      where: {\n        projectId,\n        user: {\n          email,\n        },\n      },\n    })\n\n    if (existingMember) {\n      return NextResponse.json(\n        { error: 'User is already a member of this project' },\n        { status: 400 }\n      )\n    }\n\n    // Check if there's a pending invitation for this email\n    const existingInvitation = await prisma.projectInvitation.findFirst({\n      where: {\n        projectId,\n        email,\n        status: 'pending',\n      },\n    })\n\n    if (existingInvitation) {\n      // Check if expired\n      if (existingInvitation.expiresAt < new Date()) {\n        // Update to expired\n        await prisma.projectInvitation.update({\n          where: { id: existingInvitation.id },\n          data: { status: 'expired' },\n        })\n      } else {\n        return NextResponse.json(\n          { error: 'A pending invitation already exists for this email' },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Get invitation expiry days\n    const expiryDays = await getInvitationExpiryDays()\n    const expiresAt = new Date()\n    expiresAt.setDate(expiresAt.getDate() + expiryDays)\n\n    // Generate invitation token\n    const token = `inv_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`\n\n    // Create invitation\n    let invitation: any\n    try {\n      invitation = await prisma.projectInvitation.create({\n        data: {\n          projectId,\n          email: email.toLowerCase(), // Normalize email to lowercase for consistent matching\n          role,\n          token,\n          invitedBy: user.id,\n          expiresAt,\n          status: 'pending',\n        },\n        include: {\n          project: {\n            select: {\n              id: true,\n              name: true,\n            },\n          },\n        },\n      })\n    } catch (err: any) {\n      console.error('Error creating invitation:', err)\n      if (err.message?.includes('undefined') || err.message?.includes('create')) {\n        return NextResponse.json(\n          { error: 'Team invitations feature not available. Please ensure database migrations are complete.' },\n          { status: 503 }\n        )\n      }\n      throw err\n    }\n\n    // Check if user exists (by email)\n    let invitedUser = null\n    try {\n      invitedUser = await prisma.user.findUnique({\n        where: { email },\n      })\n    } catch (err) {\n      console.warn('Could not check if user exists:', err)\n    }\n\n    // Create notification if user exists\n    if (invitedUser) {\n      try {\n        await createInvitationNotification(\n          invitedUser.id,\n          projectId,\n          invitation.id,\n          invitation.project.name,\n          user.name || user.email,\n          role,\n          invitation.token // Pass token for direct acceptance\n        )\n      } catch (notifErr) {\n        console.warn('Could not create notification:', notifErr)\n        // Don't fail the invitation if notification creation fails\n      }\n    }\n\n    // TODO: Phase 3 - Send email if email_enabled is true\n\n    return NextResponse.json({\n      invitation: {\n        id: invitation.id,\n        email: invitation.email,\n        role: invitation.role,\n        token: invitation.token,\n        expiresAt: invitation.expiresAt.toISOString(),\n        status: invitation.status,\n      },\n    })\n  } catch (error) {\n    console.error('Create invitation error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}