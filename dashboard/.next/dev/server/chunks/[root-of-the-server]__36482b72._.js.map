{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\n/**\n * Primary Prisma Client (Read/Write)\n * \n * Use this client for all write operations and when read replica is not needed.\n * This connects to the primary database.\n */\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n  \n  // In development, ensure Prisma client is properly initialized\n  if (typeof prisma.user === 'undefined') {\n    console.warn('⚠️  Prisma client models not available. Restart dev server after running: pnpm prisma generate')\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;;;CAKC,GAED,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;IAEzB,+DAA+D;IAC/D,IAAI,OAAO,OAAO,IAAI,KAAK,aAAa;QACtC,QAAQ,IAAI,CAAC;IACf;AACF"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,6IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/subscription-history.ts"],"sourcesContent":["import { prisma } from './prisma'\n\nexport type SubscriptionHistory = {\n  id: string\n  subscriptionId: string\n  userId: string\n  planId: string\n  periodStart: Date\n  periodEnd: Date\n  status: string\n  totalInvoiced: number\n  totalPaid: number | null\n  devicesRegistered: number\n  apiTracesCount: number\n  apiRequestsCount: number\n  logsCount: number\n  sessionsCount: number\n  crashesCount: number\n  createdAt: Date\n}\n\n/**\n * Create a history record for a completed billing period\n */\nexport async function createHistoryRecord(\n  subscriptionId: string,\n  data: {\n    userId: string\n    planId: string\n    periodStart: Date\n    periodEnd: Date\n    status: 'completed' | 'cancelled' | 'expired'\n    totalInvoiced: number\n    totalPaid?: number | null\n  }\n): Promise<SubscriptionHistory> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId },\n    include: { user: { include: { projects: { select: { id: true } } } } }\n  })\n\n  if (!subscription) {\n    throw new Error(`Subscription ${subscriptionId} not found`)\n  }\n\n  const projectIds = subscription.user.projects.map(p => p.id)\n\n  // Calculate usage statistics for this period\n  const [devicesRegistered, apiTracesCount, logsCount, sessionsCount, crashesCount] = await Promise.all([\n    prisma.device.count({\n      where: {\n        project: { userId: data.userId },\n        createdAt: { gte: data.periodStart, lt: data.periodEnd },\n      },\n    }),\n    prisma.apiTrace.count({\n      where: {\n        project: { userId: data.userId },\n        createdAt: { gte: data.periodStart, lt: data.periodEnd },\n      },\n    }),\n    prisma.log.count({\n      where: {\n        project: { userId: data.userId },\n        createdAt: { gte: data.periodStart, lt: data.periodEnd },\n      },\n    }),\n    prisma.session.count({\n      where: {\n        project: { userId: data.userId },\n        createdAt: { gte: data.periodStart, lt: data.periodEnd },\n      },\n    }),\n    prisma.crash.count({\n      where: {\n        project: { userId: data.userId },\n        createdAt: { gte: data.periodStart, lt: data.periodEnd },\n      },\n    }),\n  ])\n\n  // API requests count (same as apiTraces for now, can be enhanced later)\n  const apiRequestsCount = apiTracesCount\n\n  // TODO: SubscriptionHistory model needs to be added to Prisma schema\n  return (prisma as any).subscriptionHistory.create({\n    data: {\n      subscriptionId,\n      userId: data.userId,\n      planId: data.planId,\n      periodStart: data.periodStart,\n      periodEnd: data.periodEnd,\n      status: data.status,\n      totalInvoiced: data.totalInvoiced,\n      totalPaid: data.totalPaid || null,\n      devicesRegistered,\n      apiTracesCount,\n      apiRequestsCount,\n      logsCount,\n      sessionsCount,\n      crashesCount,\n    },\n  })\n}\n\n/**\n * Get subscription history for a user\n */\nexport async function getHistoryByUserId(userId: string): Promise<SubscriptionHistory[]> {\n  try {\n    // SubscriptionHistory model may not exist in schema yet\n    // Use type assertion and catch any errors\n    return (prisma as any).subscriptionHistory.findMany({\n      where: { userId },\n      orderBy: { periodStart: 'desc' },\n      include: {\n        plan: {\n          select: {\n            id: true,\n            name: true,\n            displayName: true,\n            price: true,\n          },\n        },\n      },\n    })\n  } catch (error: any) {\n    // If model doesn't exist, Prisma will throw an error\n    // Return empty array gracefully\n    if (error?.message?.includes('subscriptionHistory') || \n        error?.code === 'P2001' || \n        error?.name === 'PrismaClientKnownRequestError' ||\n        error?.message?.includes('Unknown model')) {\n      console.warn('SubscriptionHistory model not found in Prisma schema, returning empty array')\n      return []\n    }\n    console.error('Error fetching subscription history:', error)\n    // Return empty array on any error to prevent 500s\n    return []\n  }\n}\n\n/**\n * Get subscription history for a subscription\n */\nexport async function getHistoryBySubscriptionId(subscriptionId: string): Promise<SubscriptionHistory[]> {\n  return (prisma as any).subscriptionHistory.findMany({\n    where: { subscriptionId },\n    orderBy: { periodStart: 'desc' },\n    include: {\n      plan: {\n        select: {\n          id: true,\n          name: true,\n          displayName: true,\n          price: true,\n        },\n      },\n    },\n  })\n}\n\n/**\n * Get subscription count for a user (number of completed periods)\n */\nexport async function getSubscriptionCount(userId: string): Promise<number> {\n  return (prisma as any).subscriptionHistory.count({\n    where: {\n      userId,\n      status: 'completed',\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/app/api/subscription/history/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { verifyToken } from '@/lib/auth'\nimport { getHistoryByUserId } from '@/lib/subscription-history'\n\n/**\n * GET /api/subscription/history\n * Get subscription history for the authenticated user\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get('authorization')\n    if (!authHeader?.startsWith('Bearer ')) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const token = authHeader.split(' ')[1]\n    const payload = await verifyToken(token)\n    if (!payload) {\n      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })\n    }\n\n    const history = await getHistoryByUserId(payload.userId)\n\n    return NextResponse.json({ history })\n  } catch (error) {\n    console.error('Get subscription history error:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QACvC,IAAI,CAAC,YAAY,WAAW,YAAY;YACtC,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,QAAQ,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE;QACtC,MAAM,UAAU,MAAM,IAAA,gJAAW,EAAC;QAClC,IAAI,CAAC,SAAS;YACZ,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACrE;QAEA,MAAM,UAAU,MAAM,IAAA,0KAAkB,EAAC,QAAQ,MAAM;QAEvD,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE;QAAQ;IACrC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF"}}]
}