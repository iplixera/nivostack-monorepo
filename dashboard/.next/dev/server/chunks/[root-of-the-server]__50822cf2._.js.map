{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\n/**\n * Primary Prisma Client (Read/Write)\n * \n * Use this client for all write operations and when read replica is not needed.\n * This connects to the primary database.\n */\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n  \n  // In development, ensure Prisma client is properly initialized\n  if (typeof prisma.user === 'undefined') {\n    console.warn('⚠️  Prisma client models not available. Restart dev server after running: pnpm prisma generate')\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;;;CAKC,GAED,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;IAEzB,+DAA+D;IAC/D,IAAI,OAAO,OAAO,IAAI,KAAK,aAAa;QACtC,QAAQ,IAAI,CAAC;IACf;AACF"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport jwt from 'jsonwebtoken'\nimport bcrypt from 'bcryptjs'\nimport { prisma } from './prisma'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'fallback-secret-change-me'\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 12)\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword)\n}\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: '7d' })\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as { userId: string }\n  } catch {\n    return null\n  }\n}\n\nexport async function validateToken(request: NextRequest): Promise<string | null> {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  return payload.userId\n}\n\nexport async function getAuthUser(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  return user\n}\n\n// Helper function to check if user is admin (for use with already-fetched user)\nexport function isAdminUser(user: { isAdmin?: boolean } | null): boolean {\n  return user?.isAdmin === true\n}\n\nexport async function getProjectByApiKey(apiKey: string) {\n  const project = await prisma.project.findUnique({\n    where: { apiKey }\n  })\n  return project\n}\n\nexport async function validateApiKey(request: NextRequest) {\n  const apiKey = request.headers.get('x-api-key')\n  if (!apiKey) {\n    return null\n  }\n  return getProjectByApiKey(apiKey)\n}\n\nexport async function validateAdmin(request: NextRequest) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null\n  }\n\n  const token = authHeader.slice(7)\n  const payload = verifyToken(token)\n  if (!payload) {\n    return null\n  }\n\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n    select: { id: true, email: true, name: true, isAdmin: true }\n  })\n\n  if (!user || !user.isAdmin) {\n    return null\n  }\n\n  return user\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,eAAe,aAAa,QAAgB;IACjD,OAAO,mMAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,cAAsB;IAC3E,OAAO,mMAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,MAAc;IAC1C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE,WAAW;IAAK;AAC5D;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,2MAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,OAAO,QAAQ,MAAM;AACvB;AAEO,eAAe,YAAY,OAAoB;IACpD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,OAAO;AACT;AAGO,SAAS,YAAY,IAAkC;IAC5D,OAAO,MAAM,YAAY;AAC3B;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,UAAU,MAAM,6IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9C,OAAO;YAAE;QAAO;IAClB;IACA,OAAO;AACT;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO,mBAAmB;AAC5B;AAEO,eAAe,cAAc,OAAoB;IACtD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,IAAI,CAAC,YAAY,WAAW,YAAY;QACtC,OAAO;IACT;IAEA,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS;QACZ,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;QAC5B,QAAQ;YAAE,IAAI;YAAM,OAAO;YAAM,MAAM;YAAM,SAAS;QAAK;IAC7D;IAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/plan.ts"],"sourcesContent":["import { prisma } from './prisma'\n\nexport type Plan = {\n  id: string\n  name: string\n  displayName: string\n  description: string | null\n  price: number\n  currency: string\n  interval: string\n  isActive: boolean\n  isPublic: boolean\n  maxProjects: number | null\n  maxDevices: number | null\n  maxApiTraces: number | null\n  maxLogs: number | null\n  maxSessions: number | null\n  maxCrashes: number | null\n  retentionDays: number | null\n  allowApiTracking: boolean\n  allowScreenTracking: boolean\n  allowCrashReporting: boolean\n  allowLogging: boolean\n  allowBusinessConfig: boolean\n  allowLocalization: boolean\n  allowCustomDomains: boolean\n  allowWebhooks: boolean\n  allowTeamMembers: boolean\n  allowPrioritySupport: boolean\n  features: any | null\n  createdAt: Date\n  updatedAt: Date\n}\n\n/**\n * Get a plan by ID\n */\nexport async function getPlan(planId: string): Promise<Plan | null> {\n  return prisma.plan.findUnique({\n    where: { id: planId },\n  }) as unknown as Promise<Plan | null>\n}\n\n/**\n * Get a plan by name (e.g., \"free\", \"pro\", \"team\")\n */\nexport async function getPlanByName(name: string): Promise<Plan | null> {\n  return prisma.plan.findUnique({\n    where: { name },\n  }) as unknown as Promise<Plan | null>\n}\n\n/**\n * Get all public plans (for pricing page)\n */\nexport async function getPublicPlans(): Promise<Plan[]> {\n  return prisma.plan.findMany({\n    where: {\n      isPublic: true,\n    },\n    orderBy: {\n      price: 'asc',\n    },\n  }) as unknown as Promise<Plan[]>\n}\n\n/**\n * Get plan limits for a given plan ID\n */\nexport async function getPlanLimits(planId: string) {\n  const plan = await getPlan(planId)\n  if (!plan) return null\n\n  return {\n    maxProjects: plan.maxProjects,\n    maxDevices: plan.maxDevices,\n    maxApiTraces: plan.maxApiTraces,\n    maxLogs: plan.maxLogs,\n    maxSessions: plan.maxSessions,\n    maxCrashes: plan.maxCrashes,\n    retentionDays: plan.retentionDays,\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAqCO,eAAe,QAAQ,MAAc;IAC1C,OAAO,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE,IAAI;QAAO;IACtB;AACF;AAKO,eAAe,cAAc,IAAY;IAC9C,OAAO,6IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QAC5B,OAAO;YAAE;QAAK;IAChB;AACF;AAKO,eAAe;IACpB,OAAO,6IAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B,OAAO;YACL,UAAU;QACZ;QACA,SAAS;YACP,OAAO;QACT;IACF;AACF;AAKO,eAAe,cAAc,MAAc;IAChD,MAAM,OAAO,MAAM,QAAQ;IAC3B,IAAI,CAAC,MAAM,OAAO;IAElB,OAAO;QACL,aAAa,KAAK,WAAW;QAC7B,YAAY,KAAK,UAAU;QAC3B,cAAc,KAAK,YAAY;QAC/B,SAAS,KAAK,OAAO;QACrB,aAAa,KAAK,WAAW;QAC7B,YAAY,KAAK,UAAU;QAC3B,eAAe,KAAK,aAAa;IACnC;AACF"}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/subscription.ts"],"sourcesContent":["import { prisma } from './prisma'\nimport { getPlan } from './plan'\n\nexport type Subscription = {\n  id: string\n  userId: string\n  planId: string\n  status: string\n  enabled: boolean\n  trialStartDate: Date\n  trialEndDate: Date\n  currentPeriodStart: Date\n  currentPeriodEnd: Date\n  cancelledAt: Date | null\n  cancelledReason: string | null\n  disabledBy: string | null\n  disabledAt: Date | null\n  enabledBy: string | null\n  enabledAt: Date | null\n  createdAt: Date\n  updatedAt: Date\n  plan?: any\n}\n\n/**\n * Create a new subscription for a user\n */\nexport async function createSubscription(\n  userId: string,\n  planName: string = 'free'\n): Promise<Subscription> {\n  const plan = await prisma.plan.findUnique({\n    where: { name: planName },\n  })\n\n  if (!plan) {\n    throw new Error(`Plan \"${planName}\" not found`)\n  }\n\n  const trialStartDate = new Date()\n  \n  // Use plan's retentionDays as trial period, or default to 30 days\n  // For free plans, retentionDays typically represents the trial period\n  const trialDays = plan.retentionDays || 30\n  const trialEndDate = new Date(trialStartDate)\n  trialEndDate.setDate(trialEndDate.getDate() + trialDays)\n\n  const currentPeriodEnd = new Date(trialEndDate)\n\n  return prisma.subscription.create({\n    data: {\n      userId,\n      planId: plan.id,\n      status: 'active',\n      trialStartDate,\n      trialEndDate,\n      currentPeriodStart: trialStartDate,\n      currentPeriodEnd,\n    },\n    include: {\n      plan: true,\n    },\n  })\n}\n\n/**\n * Get user's subscription\n */\nexport async function getSubscription(userId: string): Promise<Subscription | null> {\n  const sub = await prisma.subscription.findUnique({\n    where: { userId },\n    include: {\n      plan: true,\n    },\n  })\n  // Type assertion to include admin fields\n  return sub as Subscription | null\n}\n\n/**\n * Check if trial is still active\n */\nexport async function isTrialActive(subscription: Subscription | null): Promise<boolean> {\n  if (!subscription) return false\n  \n  // Check if admin disabled the subscription\n  if (subscription.enabled === false) return false\n  \n  // Check if trial expired\n  if (subscription.status === 'expired') return false\n  if (subscription.status !== 'active') return false\n  \n  const now = new Date()\n  return subscription.trialEndDate > now\n}\n\n/**\n * Check if subscription allows a specific feature\n */\nexport async function isFeatureAllowed(\n  subscription: Subscription | null,\n  feature: string\n): Promise<boolean> {\n  if (!subscription) return false\n  \n  // If trial expired, no features allowed\n  if (!(await isTrialActive(subscription))) {\n    return false\n  }\n\n  const plan = await getPlan(subscription.planId)\n  if (!plan) return false\n\n  // Map feature names to plan flags\n  const featureMap: Record<string, keyof typeof plan> = {\n    deviceTracking: 'allowScreenTracking', // Device registration uses screen tracking flag\n    sessionTracking: 'allowScreenTracking', // Sessions use screen tracking flag\n    apiTracking: 'allowApiTracking',\n    screenTracking: 'allowScreenTracking',\n    crashReporting: 'allowCrashReporting',\n    logging: 'allowLogging',\n    businessConfig: 'allowBusinessConfig',\n    localization: 'allowLocalization',\n    customDomains: 'allowCustomDomains',\n    webhooks: 'allowWebhooks',\n    teamMembers: 'allowTeamMembers',\n    prioritySupport: 'allowPrioritySupport',\n  }\n\n  const planFlag = featureMap[feature]\n  if (!planFlag) return false\n\n  return plan[planFlag] === true\n}\n\n/**\n * Get usage statistics for a subscription\n */\nexport async function getUsageStats(userId: string) {\n  const subscription = await getSubscription(userId)\n  if (!subscription) {\n    return null\n  }\n\n  const plan = await getPlan(subscription.planId)\n  if (!plan) {\n    return null\n  }\n\n  // Use quota overrides if set, otherwise use plan defaults\n  const getLimit = (quotaOverride: number | null | undefined, planLimit: number | null) => {\n    return quotaOverride !== undefined && quotaOverride !== null ? quotaOverride : planLimit\n  }\n\n  const maxProjects = getLimit((subscription as any).quotaMaxProjects, plan.maxProjects)\n  const maxDevices = getLimit((subscription as any).quotaMaxDevices, plan.maxDevices)\n  const maxMockEndpoints = getLimit((subscription as any).quotaMaxMockEndpoints, plan.maxMockEndpoints)\n  const maxApiEndpoints = getLimit((subscription as any).quotaMaxApiEndpoints, plan.maxApiEndpoints)\n  const maxApiRequests = getLimit((subscription as any).quotaMaxApiRequests, plan.maxApiRequests)\n  const maxLogs = getLimit((subscription as any).quotaMaxLogs, plan.maxLogs)\n  const maxSessions = getLimit((subscription as any).quotaMaxSessions, plan.maxSessions)\n  const maxCrashes = getLimit((subscription as any).quotaMaxCrashes, plan.maxCrashes)\n  const maxBusinessConfigKeys = getLimit((subscription as any).quotaMaxBusinessConfigKeys, plan.maxBusinessConfigKeys)\n  const maxLocalizationLanguages = getLimit((subscription as any).quotaMaxLocalizationLanguages, plan.maxLocalizationLanguages)\n  const maxLocalizationKeys = getLimit((subscription as any).quotaMaxLocalizationKeys, plan.maxLocalizationKeys)\n\n  // FIXED: Use currentPeriodStart/currentPeriodEnd instead of trialStartDate/trialEndDate\n  const periodStart = subscription.currentPeriodStart\n  const periodEnd = subscription.currentPeriodEnd\n\n  // Count usage for current billing period\n  const [mockEndpoints, logs, sessions, crashes, devices, projects, apiEndpoints, apiRequests, businessConfigKeys, localizationLanguages, localizationKeys] = await Promise.all([\n    // Mock Endpoints: Lifetime meter (never reset)\n    prisma.mockEndpoint.count({\n      where: {\n        environment: {\n          project: { userId },\n        },\n      },\n    }),\n    prisma.log.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    prisma.session.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    prisma.crash.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // FIXED: Devices now period-based (resets monthly)\n    prisma.device.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // Projects: Lifetime meter (never reset)\n    prisma.project.count({\n      where: { userId },\n    }),\n    // API Endpoints: Unique endpoints in current period\n    prisma.apiTrace.groupBy({\n      by: ['url'],\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }).then(result => result.length),\n    // API Requests: Total requests in current period\n    prisma.apiTrace.count({\n      where: {\n        project: { userId },\n        createdAt: { gte: periodStart, lt: periodEnd },\n      },\n    }),\n    // Business Config Keys: Lifetime meter (never reset)\n    prisma.businessConfig.count({\n      where: { project: { userId } },\n    }),\n    // Localization Languages: Lifetime meter (never reset)\n    prisma.language.count({\n      where: { project: { userId } },\n    }),\n    // Localization Keys: Lifetime meter (never reset)\n    prisma.localizationKey.count({\n      where: { project: { userId } },\n    }),\n  ])\n\n  return {\n    mockEndpoints: {\n      used: mockEndpoints,\n      limit: maxMockEndpoints,\n      percentage: maxMockEndpoints ? (mockEndpoints / maxMockEndpoints) * 100 : 0,\n    },\n    apiEndpoints: {\n      used: apiEndpoints,\n      limit: maxApiEndpoints,\n      percentage: maxApiEndpoints ? (apiEndpoints / maxApiEndpoints) * 100 : 0,\n    },\n    apiRequests: {\n      used: apiRequests,\n      limit: maxApiRequests,\n      percentage: maxApiRequests ? (apiRequests / maxApiRequests) * 100 : 0,\n    },\n    logs: {\n      used: logs,\n      limit: maxLogs,\n      percentage: maxLogs ? (logs / maxLogs) * 100 : 0,\n    },\n    sessions: {\n      used: sessions,\n      limit: maxSessions,\n      percentage: maxSessions ? (sessions / maxSessions) * 100 : 0,\n    },\n    crashes: {\n      used: crashes,\n      limit: maxCrashes,\n      percentage: maxCrashes ? (crashes / maxCrashes) * 100 : 0,\n    },\n    devices: {\n      used: devices,\n      limit: maxDevices,\n      percentage: maxDevices ? (devices / maxDevices) * 100 : 0,\n    },\n    projects: {\n      used: projects,\n      limit: maxProjects,\n      percentage: maxProjects ? (projects / maxProjects) * 100 : 0,\n    },\n    businessConfigKeys: {\n      used: businessConfigKeys,\n      limit: maxBusinessConfigKeys,\n      percentage: maxBusinessConfigKeys ? (businessConfigKeys / maxBusinessConfigKeys) * 100 : 0,\n    },\n    localizationLanguages: {\n      used: localizationLanguages,\n      limit: maxLocalizationLanguages,\n      percentage: maxLocalizationLanguages ? (localizationLanguages / maxLocalizationLanguages) * 100 : 0,\n    },\n    localizationKeys: {\n      used: localizationKeys,\n      limit: maxLocalizationKeys,\n      percentage: maxLocalizationKeys ? (localizationKeys / maxLocalizationKeys) * 100 : 0,\n    },\n    trialActive: await isTrialActive(subscription),\n    trialEndDate: subscription.trialEndDate,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    daysRemaining: Math.max(\n      0,\n      Math.ceil((subscription.currentPeriodEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24))\n    ),\n  }\n}\n\n/**\n * Update subscription status to expired\n */\nexport async function expireSubscription(subscriptionId: string): Promise<void> {\n  await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'expired',\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/subscription-validation.ts"],"sourcesContent":["import { getSubscription } from './subscription'\nimport { isTrialActive } from './subscription'\n\nexport type ValidationResult = {\n  valid: boolean\n  error?: string\n  subscription?: any\n}\n\n/**\n * Validate subscription for SDK access\n * Checks: enabled, status, trial expiration, grace period\n */\nexport async function validateSubscription(userId: string): Promise<ValidationResult> {\n  const subscription = await getSubscription(userId)\n\n  // Check 1: Subscription exists\n  if (!subscription) {\n    return {\n      valid: false,\n      error: 'No subscription found',\n    }\n  }\n\n  // Check 2: Subscription enabled (admin control)\n  if (!subscription.enabled) {\n    return {\n      valid: false,\n      error: 'Subscription disabled by admin',\n      subscription,\n    }\n  }\n\n  // Check 3: Subscription status\n  if (subscription.status !== 'active') {\n    return {\n      valid: false,\n      error: `Subscription ${subscription.status}`,\n      subscription,\n    }\n  }\n\n  // Check 4: Grace period expired (for paid plans)\n  if (subscription.gracePeriodEnd && subscription.gracePeriodEnd <= new Date()) {\n    return {\n      valid: false,\n      error: 'Subscription suspended due to payment failure',\n      subscription,\n    }\n  }\n\n  // Check 5: Trial expiration (for free plans or trial periods)\n  const trialActive = await isTrialActive(subscription)\n  if (!trialActive && subscription.status === 'active') {\n    // For free plans, if trial expired, subscription should be expired\n    // But check anyway for safety\n    return {\n      valid: false,\n      error: 'Trial expired',\n      subscription,\n    }\n  }\n\n  return {\n    valid: true,\n    subscription,\n  }\n}\n\n/**\n * Validate subscription and check if specific feature is allowed\n */\nexport async function validateFeature(\n  userId: string,\n  feature: string\n): Promise<ValidationResult & { featureAllowed?: boolean }> {\n  const validation = await validateSubscription(userId)\n\n  if (!validation.valid) {\n    return validation\n  }\n\n  // Import here to avoid circular dependency\n  const { isFeatureAllowed } = await import('./subscription')\n  const featureAllowed = await isFeatureAllowed(validation.subscription, feature)\n\n  if (!featureAllowed) {\n    return {\n      valid: false,\n      error: `Feature ${feature} not available in your plan`,\n      subscription: validation.subscription,\n      featureAllowed: false,\n    }\n  }\n\n  return {\n    ...validation,\n    featureAllowed: true,\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;;AAaO,eAAe,qBAAqB,MAAc;IACvD,MAAM,eAAe,MAAM,IAAA,4JAAe,EAAC;IAE3C,+BAA+B;IAC/B,IAAI,CAAC,cAAc;QACjB,OAAO;YACL,OAAO;YACP,OAAO;QACT;IACF;IAEA,gDAAgD;IAChD,IAAI,CAAC,aAAa,OAAO,EAAE;QACzB,OAAO;YACL,OAAO;YACP,OAAO;YACP;QACF;IACF;IAEA,+BAA+B;IAC/B,IAAI,aAAa,MAAM,KAAK,UAAU;QACpC,OAAO;YACL,OAAO;YACP,OAAO,CAAC,aAAa,EAAE,aAAa,MAAM,EAAE;YAC5C;QACF;IACF;IAEA,iDAAiD;IACjD,IAAI,aAAa,cAAc,IAAI,aAAa,cAAc,IAAI,IAAI,QAAQ;QAC5E,OAAO;YACL,OAAO;YACP,OAAO;YACP;QACF;IACF;IAEA,8DAA8D;IAC9D,MAAM,cAAc,MAAM,IAAA,0JAAa,EAAC;IACxC,IAAI,CAAC,eAAe,aAAa,MAAM,KAAK,UAAU;QACpD,mEAAmE;QACnE,8BAA8B;QAC9B,OAAO;YACL,OAAO;YACP,OAAO;YACP;QACF;IACF;IAEA,OAAO;QACL,OAAO;QACP;IACF;AACF;AAKO,eAAe,gBACpB,MAAc,EACd,OAAe;IAEf,MAAM,aAAa,MAAM,qBAAqB;IAE9C,IAAI,CAAC,WAAW,KAAK,EAAE;QACrB,OAAO;IACT;IAEA,2CAA2C;IAC3C,MAAM,EAAE,gBAAgB,EAAE,GAAG;IAC7B,MAAM,iBAAiB,MAAM,iBAAiB,WAAW,YAAY,EAAE;IAEvE,IAAI,CAAC,gBAAgB;QACnB,OAAO;YACL,OAAO;YACP,OAAO,CAAC,QAAQ,EAAE,QAAQ,2BAA2B,CAAC;YACtD,cAAc,WAAW,YAAY;YACrC,gBAAgB;QAClB;IACF;IAEA,OAAO;QACL,GAAG,UAAU;QACb,gBAAgB;IAClB;AACF"}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/enforcement.ts"],"sourcesContent":["import { prisma } from './prisma'\nimport { getUsageStats } from './subscription'\nimport { getSubscription } from './subscription'\n\nexport type EnforcementState = 'ACTIVE' | 'WARN' | 'GRACE' | 'DEGRADED' | 'SUSPENDED'\n\nexport type EnforcementConfig = {\n  warnThreshold?: number // Default: 80\n  hardThreshold?: number // Default: 100\n  gracePeriodHours?: number // Default: 48\n  overageBufferPercent?: number // Default: 0\n  moduleRules?: {\n    apiTraces?: {\n      samplingRate?: number // Sample 1 in N requests\n      dropResponseBodies?: boolean\n    }\n    logs?: {\n      prioritizeCrashes?: boolean\n      minRetentionDays?: number\n    }\n    sessions?: {\n      samplingRate?: number // Sample 1 in N sessions\n      capEventsPerSession?: number\n    }\n    businessConfig?: {\n      freezePublishing?: boolean\n      serveLastPublished?: boolean\n    }\n    localization?: {\n      freezePublishing?: boolean\n      serveLastPublished?: boolean\n    }\n  }\n}\n\nexport type EffectivePolicy = {\n  sampling: {\n    apiTraces: { rate: number; enabled: boolean }\n    sessions: { rate: number; enabled: boolean }\n    logs: { prioritizeCrashes: boolean; dropDebug: boolean }\n  }\n  retention: {\n    apiTraces: number\n    logs: number\n    sessions: number\n  }\n  freezes: {\n    businessConfig: boolean\n    localization: boolean\n  }\n}\n\nexport type EnforcementEvaluation = {\n  state: EnforcementState\n  triggeredMetrics: Array<{\n    metric: string\n    usage: number\n    limit: number | null\n    percentage: number\n  }>\n  effectivePolicy: EffectivePolicy\n  graceEndsAt?: Date\n  nextEvaluationAt: Date\n}\n\n/**\n * Get default enforcement config (used when plan doesn't have custom config)\n */\nexport function getDefaultEnforcementConfig(): EnforcementConfig {\n  return {\n    warnThreshold: 80,\n    hardThreshold: 100,\n    gracePeriodHours: 48,\n    overageBufferPercent: 0,\n    moduleRules: {\n      apiTraces: {\n        samplingRate: 10,\n        dropResponseBodies: true,\n      },\n      logs: {\n        prioritizeCrashes: true,\n        minRetentionDays: 7,\n      },\n      sessions: {\n        samplingRate: 10,\n        capEventsPerSession: 100,\n      },\n      businessConfig: {\n        freezePublishing: true,\n        serveLastPublished: true,\n      },\n      localization: {\n        freezePublishing: true,\n        serveLastPublished: true,\n      },\n    },\n  }\n}\n\n/**\n * Get enforcement config for a plan (with defaults)\n */\nexport function getEnforcementConfig(plan: { enforcementConfig: any } | null): EnforcementConfig {\n  if (!plan?.enforcementConfig) {\n    return getDefaultEnforcementConfig()\n  }\n\n  const config = plan.enforcementConfig as EnforcementConfig\n  const defaults = getDefaultEnforcementConfig()\n\n  return {\n    warnThreshold: config.warnThreshold ?? defaults.warnThreshold,\n    hardThreshold: config.hardThreshold ?? defaults.hardThreshold,\n    gracePeriodHours: config.gracePeriodHours ?? defaults.gracePeriodHours,\n    overageBufferPercent: config.overageBufferPercent ?? defaults.overageBufferPercent,\n    moduleRules: {\n      ...defaults.moduleRules,\n      ...config.moduleRules,\n    },\n  }\n}\n\n/**\n * Evaluate enforcement state for a subscription\n */\nexport async function evaluateEnforcementState(\n  userId: string\n): Promise<EnforcementEvaluation> {\n  const subscription = await getSubscription(userId)\n  if (!subscription) {\n    throw new Error('Subscription not found')\n  }\n\n  // Get plan with enforcement config\n  const plan = await prisma.plan.findUnique({\n    where: { id: subscription.planId },\n  })\n\n  if (!plan) {\n    throw new Error('Plan not found')\n  }\n\n  const config = getEnforcementConfig(plan)\n  const usage = await getUsageStats(userId)\n\n  if (!usage) {\n    // No usage data - default to ACTIVE\n    return {\n      state: 'ACTIVE',\n      triggeredMetrics: [],\n      effectivePolicy: getDefaultEffectivePolicy(),\n      nextEvaluationAt: new Date(Date.now() + 15 * 60 * 1000), // Re-evaluate in 15 minutes\n    }\n  }\n\n  // Check all meters for threshold violations\n  const triggeredMetrics: Array<{\n    metric: string\n    usage: number\n    limit: number | null\n    percentage: number\n  }> = []\n\n  const meters = [\n    'devices',\n    'apiRequests', // Changed from apiTraces to apiRequests\n    'logs',\n    'sessions',\n    'crashes',\n    'projects',\n  ] as const\n\n  let maxPercentage = 0\n  let hasHardThreshold = false\n\n  for (const meterKey of meters) {\n    const meter = (usage as any)[meterKey]\n    if (!meter || meter.limit === null) continue\n\n    const percentage = meter.percentage\n\n    if (percentage >= config.hardThreshold!) {\n      hasHardThreshold = true\n      triggeredMetrics.push({\n        metric: meterKey,\n        usage: meter.usage || meter.used || 0,\n        limit: meter.limit,\n        percentage,\n      })\n    } else if (percentage >= config.warnThreshold!) {\n      triggeredMetrics.push({\n        metric: meterKey,\n        usage: meter.usage || meter.used || 0,\n        limit: meter.limit,\n        percentage,\n      })\n    }\n\n    if (percentage > maxPercentage) {\n      maxPercentage = percentage\n    }\n  }\n\n  // Get current enforcement state from database\n  const currentState = await prisma.enforcementState.findUnique({\n    where: { subscriptionId: subscription.id },\n  })\n\n  // Determine new state\n  let newState: EnforcementState = 'ACTIVE'\n  let graceEndsAt: Date | undefined\n\n  if (subscription.status !== 'active' || !subscription.enabled) {\n    newState = 'SUSPENDED'\n  } else if (hasHardThreshold) {\n    // Check if we're in grace period\n    if (currentState?.state === 'GRACE' && currentState.graceEndsAt) {\n      if (new Date() < currentState.graceEndsAt) {\n        // Still in grace period\n        newState = 'GRACE'\n        graceEndsAt = currentState.graceEndsAt\n      } else {\n        // Grace period expired\n        newState = 'DEGRADED'\n      }\n    } else {\n      // Enter grace period\n      newState = 'GRACE'\n      const graceHours = config.gracePeriodHours || 48\n      graceEndsAt = new Date(Date.now() + graceHours * 60 * 60 * 1000)\n    }\n  } else if (maxPercentage >= config.warnThreshold!) {\n    newState = 'WARN'\n  }\n\n  // Generate effective policy based on state\n  const effectivePolicy = generateEffectivePolicy(newState, config, plan)\n\n  // Calculate next evaluation time (15 minutes for active/warn, 5 minutes for grace/degraded)\n  const evaluationInterval = newState === 'ACTIVE' || newState === 'WARN' ? 15 : 5\n  const nextEvaluationAt = new Date(Date.now() + evaluationInterval * 60 * 1000)\n\n  return {\n    state: newState,\n    triggeredMetrics,\n    effectivePolicy,\n    graceEndsAt,\n    nextEvaluationAt,\n  }\n}\n\n/**\n * Generate effective policy based on enforcement state\n */\nfunction generateEffectivePolicy(\n  state: EnforcementState,\n  config: EnforcementConfig,\n  plan: { retentionDays: number | null }\n): EffectivePolicy {\n  const defaultPolicy = getDefaultEffectivePolicy()\n\n  if (state === 'ACTIVE' || state === 'WARN' || state === 'GRACE') {\n    // No degradation - use plan defaults\n    const retentionDays = plan.retentionDays || 30\n    return {\n      sampling: {\n        apiTraces: { rate: 1, enabled: false },\n        sessions: { rate: 1, enabled: false },\n        logs: { prioritizeCrashes: false, dropDebug: false },\n      },\n      retention: {\n        apiTraces: retentionDays,\n        logs: retentionDays,\n        sessions: retentionDays,\n      },\n      freezes: {\n        businessConfig: false,\n        localization: false,\n      },\n    }\n  }\n\n  if (state === 'DEGRADED') {\n    // Apply degradation rules\n    const moduleRules = config.moduleRules || {}\n    const retentionDays = plan.retentionDays || 30\n    const minRetention = moduleRules.logs?.minRetentionDays || 7\n\n    return {\n      sampling: {\n        apiTraces: {\n          rate: moduleRules.apiTraces?.samplingRate || 10,\n          enabled: true,\n        },\n        sessions: {\n          rate: moduleRules.sessions?.samplingRate || 10,\n          enabled: true,\n        },\n        logs: {\n          prioritizeCrashes: moduleRules.logs?.prioritizeCrashes ?? true,\n          dropDebug: true,\n        },\n      },\n      retention: {\n        apiTraces: Math.max(retentionDays - 7, 7),\n        logs: Math.max(minRetention, 7),\n        sessions: Math.max(retentionDays - 7, 7),\n      },\n      freezes: {\n        businessConfig: moduleRules.businessConfig?.freezePublishing ?? true,\n        localization: moduleRules.localization?.freezePublishing ?? true,\n      },\n    }\n  }\n\n  // SUSPENDED - minimal policy\n  return {\n    sampling: {\n      apiTraces: { rate: 1, enabled: false },\n      sessions: { rate: 1, enabled: false },\n      logs: { prioritizeCrashes: false, dropDebug: false },\n    },\n    retention: {\n      apiTraces: 0,\n      logs: 0,\n      sessions: 0,\n    },\n    freezes: {\n      businessConfig: true,\n      localization: true,\n    },\n  }\n}\n\n/**\n * Get default effective policy\n */\nfunction getDefaultEffectivePolicy(): EffectivePolicy {\n  return {\n    sampling: {\n      apiTraces: { rate: 1, enabled: false },\n      sessions: { rate: 1, enabled: false },\n      logs: { prioritizeCrashes: false, dropDebug: false },\n    },\n    retention: {\n      apiTraces: 30,\n      logs: 30,\n      sessions: 30,\n    },\n    freezes: {\n      businessConfig: false,\n      localization: false,\n    },\n  }\n}\n\n/**\n * Update enforcement state in database\n */\nexport async function updateEnforcementState(\n  subscriptionId: string,\n  evaluation: EnforcementEvaluation\n): Promise<void> {\n  const now = new Date()\n  const existing = await prisma.enforcementState.findUnique({\n    where: { subscriptionId },\n  })\n\n  await prisma.enforcementState.upsert({\n    where: { subscriptionId },\n    create: {\n      subscriptionId,\n      state: evaluation.state,\n      warnEnteredAt: evaluation.state === 'WARN' ? now : null,\n      graceEnteredAt: evaluation.state === 'GRACE' ? now : null,\n      graceEndsAt: evaluation.graceEndsAt || null,\n      degradedEnteredAt: evaluation.state === 'DEGRADED' ? now : null,\n      effectivePolicy: evaluation.effectivePolicy as any,\n      triggeredMetrics: evaluation.triggeredMetrics as any,\n      lastEvaluatedAt: now,\n      nextEvaluationAt: evaluation.nextEvaluationAt,\n    },\n    update: {\n      state: evaluation.state,\n      warnEnteredAt:\n        evaluation.state === 'WARN' && !existing?.warnEnteredAt\n          ? now\n          : existing?.warnEnteredAt,\n      graceEnteredAt:\n        evaluation.state === 'GRACE' && !existing?.graceEnteredAt\n          ? now\n          : existing?.graceEnteredAt,\n      graceEndsAt: evaluation.graceEndsAt || existing?.graceEndsAt || null,\n      degradedEnteredAt:\n        evaluation.state === 'DEGRADED' && !existing?.degradedEnteredAt\n          ? now\n          : existing?.degradedEnteredAt,\n      effectivePolicy: evaluation.effectivePolicy as any,\n      triggeredMetrics: evaluation.triggeredMetrics as any,\n      lastEvaluatedAt: now,\n      nextEvaluationAt: evaluation.nextEvaluationAt,\n    },\n  })\n}\n\n/**\n * Get current enforcement state for a subscription\n */\nexport async function getEnforcementState(subscriptionId: string) {\n  return prisma.enforcementState.findUnique({\n    where: { subscriptionId },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/throttling.ts"],"sourcesContent":["import { getUsageStats } from './subscription'\nimport { evaluateEnforcementState, updateEnforcementState, getEnforcementState } from './enforcement'\nimport { getSubscription } from './subscription'\n\nexport type ThrottlingResult = {\n  throttled: boolean\n  error?: string\n  retryAfter?: number // Seconds until retry allowed\n  usage?: {\n    used: number\n    limit: number | null\n    percentage: number\n  }\n  enforcementState?: 'ACTIVE' | 'WARN' | 'GRACE' | 'DEGRADED' | 'SUSPENDED'\n  effectivePolicy?: any\n}\n\n/**\n * Check if a meter is throttled (usage exceeded limit)\n * Now uses admin-configured enforcement thresholds\n */\nexport async function checkThrottling(\n  userId: string,\n  meterKey: 'devices' | 'apiTraces' | 'apiRequests' | 'apiEndpoints' | 'logs' | 'sessions' | 'crashes' | 'projects' | 'businessConfigKeys' | 'localizationLanguages' | 'localizationKeys' | 'mockEndpoints'\n): Promise<ThrottlingResult> {\n  const usage = await getUsageStats(userId)\n  \n  if (!usage) {\n    return {\n      throttled: false,\n      error: 'Usage stats not available',\n    }\n  }\n\n  const meter = usage[meterKey]\n  if (!meter) {\n    return {\n      throttled: false,\n      error: `Meter ${meterKey} not found`,\n    }\n  }\n\n  // If limit is null, it's unlimited - never throttle\n  if (meter.limit === null) {\n    return {\n      throttled: false,\n      usage: meter,\n      enforcementState: 'ACTIVE',\n    }\n  }\n\n  // Evaluate enforcement state (uses admin-configured thresholds)\n  const subscription = await getSubscription(userId)\n  if (!subscription) {\n    return {\n      throttled: false,\n      usage: meter,\n      enforcementState: 'ACTIVE',\n    }\n  }\n\n  // Get or evaluate enforcement state\n  let enforcement = await getEnforcementState(subscription.id)\n  \n  // Re-evaluate if needed\n  if (!enforcement || new Date() >= enforcement.nextEvaluationAt) {\n    const evaluation = await evaluateEnforcementState(userId)\n    await updateEnforcementState(subscription.id, evaluation)\n    enforcement = await getEnforcementState(subscription.id)\n  }\n\n  const state = enforcement?.state || 'ACTIVE'\n  const effectivePolicy = enforcement?.effectivePolicy\n\n  // CRITICAL: Check if this specific meter has exceeded its limit\n  // This should block regardless of enforcement state (except SUSPENDED which is handled below)\n  if (meter.limit !== null && meter.used >= meter.limit) {\n    // Quota exceeded - BLOCK immediately\n    // Note: Grace period is for overall subscription health, not for individual meter limits\n    return {\n      throttled: true,\n      error: `Quota exceeded: ${meter.used}/${meter.limit} ${meterKey}. Please upgrade your plan.`,\n      retryAfter: 3600, // 1 hour\n      usage: meter,\n      enforcementState: state,\n      effectivePolicy,\n    }\n  }\n\n  // SUSPENDED state - block all requests\n  if (state === 'SUSPENDED') {\n    return {\n      throttled: true,\n      error: 'Subscription suspended. Please contact support.',\n      usage: meter,\n      enforcementState: state,\n      effectivePolicy,\n    }\n  }\n\n  // DEGRADED state - apply sampling/degradation but don't block\n  if (state === 'DEGRADED') {\n    // Don't throttle - apply degradation instead (handled by effective policy)\n    return {\n      throttled: false, // Don't block, but degradation applies\n      usage: meter,\n      enforcementState: state,\n      effectivePolicy,\n    }\n  }\n\n  // GRACE state - allow full fidelity\n  if (state === 'GRACE') {\n    return {\n      throttled: false,\n      usage: meter,\n      enforcementState: state,\n      effectivePolicy,\n    }\n  }\n\n  // WARN or ACTIVE - normal operation\n  return {\n    throttled: false,\n    usage: meter,\n    enforcementState: state,\n    effectivePolicy,\n  }\n}\n\n/**\n * Check multiple meters at once\n */\nexport async function checkMultipleMeters(\n  userId: string,\n  meterKeys: Array<'devices' | 'apiTraces' | 'apiRequests' | 'apiEndpoints' | 'logs' | 'sessions' | 'crashes' | 'projects' | 'businessConfigKeys' | 'localizationLanguages' | 'localizationKeys' | 'mockEndpoints'>\n): Promise<{\n  throttled: boolean\n  errors: string[]\n  results: Record<string, ThrottlingResult>\n}> {\n  const results: Record<string, ThrottlingResult> = {}\n  const errors: string[] = []\n\n  for (const meterKey of meterKeys) {\n    const result = await checkThrottling(userId, meterKey)\n    results[meterKey] = result\n    \n    if (result.throttled) {\n      errors.push(result.error || `Quota exceeded for ${meterKey}`)\n    }\n  }\n\n  return {\n    throttled: errors.length > 0,\n    errors,\n    results,\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;AAoBO,eAAe,gBACpB,MAAc,EACd,QAAyM;IAEzM,MAAM,QAAQ,MAAM,IAAA,0JAAa,EAAC;IAElC,IAAI,CAAC,OAAO;QACV,OAAO;YACL,WAAW;YACX,OAAO;QACT;IACF;IAEA,MAAM,QAAQ,KAAK,CAAC,SAAS;IAC7B,IAAI,CAAC,OAAO;QACV,OAAO;YACL,WAAW;YACX,OAAO,CAAC,MAAM,EAAE,SAAS,UAAU,CAAC;QACtC;IACF;IAEA,oDAAoD;IACpD,IAAI,MAAM,KAAK,KAAK,MAAM;QACxB,OAAO;YACL,WAAW;YACX,OAAO;YACP,kBAAkB;QACpB;IACF;IAEA,gEAAgE;IAChE,MAAM,eAAe,MAAM,IAAA,4JAAe,EAAC;IAC3C,IAAI,CAAC,cAAc;QACjB,OAAO;YACL,WAAW;YACX,OAAO;YACP,kBAAkB;QACpB;IACF;IAEA,oCAAoC;IACpC,IAAI,cAAc,MAAM,IAAA,+JAAmB,EAAC,aAAa,EAAE;IAE3D,wBAAwB;IACxB,IAAI,CAAC,eAAe,IAAI,UAAU,YAAY,gBAAgB,EAAE;QAC9D,MAAM,aAAa,MAAM,IAAA,oKAAwB,EAAC;QAClD,MAAM,IAAA,kKAAsB,EAAC,aAAa,EAAE,EAAE;QAC9C,cAAc,MAAM,IAAA,+JAAmB,EAAC,aAAa,EAAE;IACzD;IAEA,MAAM,QAAQ,aAAa,SAAS;IACpC,MAAM,kBAAkB,aAAa;IAErC,gEAAgE;IAChE,8FAA8F;IAC9F,IAAI,MAAM,KAAK,KAAK,QAAQ,MAAM,IAAI,IAAI,MAAM,KAAK,EAAE;QACrD,qCAAqC;QACrC,yFAAyF;QACzF,OAAO;YACL,WAAW;YACX,OAAO,CAAC,gBAAgB,EAAE,MAAM,IAAI,CAAC,CAAC,EAAE,MAAM,KAAK,CAAC,CAAC,EAAE,SAAS,2BAA2B,CAAC;YAC5F,YAAY;YACZ,OAAO;YACP,kBAAkB;YAClB;QACF;IACF;IAEA,uCAAuC;IACvC,IAAI,UAAU,aAAa;QACzB,OAAO;YACL,WAAW;YACX,OAAO;YACP,OAAO;YACP,kBAAkB;YAClB;QACF;IACF;IAEA,8DAA8D;IAC9D,IAAI,UAAU,YAAY;QACxB,2EAA2E;QAC3E,OAAO;YACL,WAAW;YACX,OAAO;YACP,kBAAkB;YAClB;QACF;IACF;IAEA,oCAAoC;IACpC,IAAI,UAAU,SAAS;QACrB,OAAO;YACL,WAAW;YACX,OAAO;YACP,kBAAkB;YAClB;QACF;IACF;IAEA,oCAAoC;IACpC,OAAO;QACL,WAAW;QACX,OAAO;QACP,kBAAkB;QAClB;IACF;AACF;AAKO,eAAe,oBACpB,MAAc,EACd,SAAiN;IAMjN,MAAM,UAA4C,CAAC;IACnD,MAAM,SAAmB,EAAE;IAE3B,KAAK,MAAM,YAAY,UAAW;QAChC,MAAM,SAAS,MAAM,gBAAgB,QAAQ;QAC7C,OAAO,CAAC,SAAS,GAAG;QAEpB,IAAI,OAAO,SAAS,EAAE;YACpB,OAAO,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,mBAAmB,EAAE,UAAU;QAC9D;IACF;IAEA,OAAO;QACL,WAAW,OAAO,MAAM,GAAG;QAC3B;QACA;IACF;AACF"}},
    {"offset": {"line": 1151, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/lib/team-access.ts"],"sourcesContent":["/**\n * Team Access Control Utilities\n * \n * Helper functions for checking user roles and permissions in projects\n */\n\nimport { prisma } from './prisma'\n\nexport type ProjectRole = 'owner' | 'admin' | 'member' | 'viewer'\n\nexport interface ProjectMemberWithUser {\n  id: string\n  role: ProjectRole\n  user: {\n    id: string\n    email: string\n    name: string | null\n  }\n  invitedBy: string | null\n  invitedAt: Date\n  joinedAt: Date | null\n}\n\n/**\n * Get user's role in a project\n */\nexport async function getUserProjectRole(\n  userId: string,\n  projectId: string\n): Promise<ProjectRole | null> {\n  const member = await prisma.projectMember.findUnique({\n    where: {\n      projectId_userId: {\n        projectId,\n        userId,\n      },\n    },\n    select: {\n      role: true,\n    },\n  })\n\n  return member?.role as ProjectRole | null\n}\n\n/**\n * Check if user has a specific role (or higher) in a project\n * Role hierarchy: owner > admin > member > viewer\n */\nexport async function hasProjectRole(\n  userId: string,\n  projectId: string,\n  requiredRole: ProjectRole\n): Promise<boolean> {\n  const userRole = await getUserProjectRole(userId, projectId)\n\n  if (!userRole) {\n    // Check if user is the project owner (backward compatibility)\n    const project = await prisma.project.findUnique({\n      where: { id: projectId },\n      select: { userId: true },\n    })\n\n    if (project?.userId === userId) {\n      // User is owner via legacy userId field\n      return requiredRole === 'owner' || requiredRole === 'admin' || requiredRole === 'member' || requiredRole === 'viewer'\n    }\n\n    return false\n  }\n\n  const roleHierarchy: Record<ProjectRole, number> = {\n    owner: 4,\n    admin: 3,\n    member: 2,\n    viewer: 1,\n  }\n\n  return roleHierarchy[userRole] >= roleHierarchy[requiredRole]\n}\n\n/**\n * Check if user can perform an action based on role\n */\nexport async function canPerformAction(\n  userId: string,\n  projectId: string,\n  action: 'invite' | 'remove_member' | 'change_role' | 'transfer_ownership' | 'delete_project' | 'manage_settings' | 'edit_config' | 'view'\n): Promise<boolean> {\n  const role = await getUserProjectRole(userId, projectId)\n\n  // If no role, check if user is project owner (backward compatibility)\n  if (!role) {\n    const project = await prisma.project.findUnique({\n      where: { id: projectId },\n      select: { userId: true },\n    })\n\n    if (project?.userId === userId) {\n      // Legacy owner - can do everything\n      return true\n    }\n\n    return false\n  }\n\n  // Role-based permissions\n  const permissions: Record<ProjectRole, string[]> = {\n    owner: [\n      'invite',\n      'remove_member',\n      'change_role',\n      'transfer_ownership',\n      'delete_project',\n      'manage_settings',\n      'edit_config',\n      'view',\n    ],\n    admin: [\n      'invite',\n      'remove_member',\n      'change_role',\n      'manage_settings',\n      'edit_config',\n      'view',\n    ],\n    member: [\n      'edit_config',\n      'view',\n    ],\n    viewer: [\n      'view',\n    ],\n  }\n\n  return permissions[role]?.includes(action) ?? false\n}\n\n/**\n * Get all members of a project\n */\nexport async function getProjectMembers(projectId: string): Promise<ProjectMemberWithUser[]> {\n  const members = await prisma.projectMember.findMany({\n    where: { projectId },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: [\n      { role: 'asc' }, // owner first, then admin, member, viewer\n      { joinedAt: 'asc' },\n    ],\n  })\n\n  return members.map((m) => ({\n    id: m.id,\n    role: m.role as ProjectRole,\n    user: m.user,\n    invitedBy: m.invitedBy,\n    invitedAt: m.invitedAt,\n    joinedAt: m.joinedAt,\n  }))\n}\n\n/**\n * Check seat limits for a plan\n */\nexport async function checkSeatLimit(projectId: string): Promise<{ allowed: boolean; current: number; limit: number | null }> {\n  // Get project owner's subscription\n  const project = await prisma.project.findUnique({\n    where: { id: projectId },\n    include: {\n      user: {\n        include: {\n          subscription: {\n            include: {\n              plan: true,\n            },\n          },\n        },\n      },\n    },\n  })\n\n  if (!project) {\n    return { allowed: false, current: 0, limit: null }\n  }\n\n  const plan = project.user.subscription?.plan\n  const maxSeats = plan?.maxTeamMembers ?? plan?.maxSeats ?? null\n\n  // Count current members\n  const currentMembers = await prisma.projectMember.count({\n    where: { projectId },\n  })\n\n  // If no limit, allow unlimited\n  if (maxSeats === null) {\n    return { allowed: true, current: currentMembers, limit: null }\n  }\n\n  return {\n    allowed: currentMembers < maxSeats,\n    current: currentMembers,\n    limit: maxSeats,\n  }\n}\n\n/**\n * Get invitation expiry days from system configuration\n */\nexport async function getInvitationExpiryDays(): Promise<number> {\n  const config = await prisma.systemConfiguration.findUnique({\n    where: {\n      category_key: {\n        category: 'notifications',\n        key: 'invitation_expiry_days',\n      },\n    },\n  })\n\n  if (config?.value) {\n    const days = parseInt(config.value, 10)\n    if (!isNaN(days) && days > 0) {\n      return days\n    }\n  }\n\n  return 7 // Default: 7 days\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"sources":["file:///Users/karim-f/Code/nivostack-monorepo-checkout/dashboard/src/app/api/devices/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { validateApiKey, getAuthUser } from '@/lib/auth'\nimport { validateFeature } from '@/lib/subscription-validation'\nimport { checkThrottling } from '@/lib/throttling'\nimport { canPerformAction } from '@/lib/team-access'\n\n/**\n * Generate a short, human-readable device code\n * Format: XXXX-XXXX (8 alphanumeric characters with hyphen separator)\n * Example: \"A7B3-X9K2\"\n * Excludes confusing characters: 0/O, 1/l/I\n */\nfunction generateDeviceCode(): string {\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789' // No 0/O, 1/l/I\n  const random = () => chars[Math.floor(Math.random() * chars.length)]\n  const code = Array.from({ length: 8 }, random).join('')\n  return `${code.substring(0, 4)}-${code.substring(4)}`\n}\n\n// SDK endpoint: Register or update a device\nexport async function POST(request: NextRequest) {\n  try {\n    const project = await validateApiKey(request)\n    if (!project) {\n      return NextResponse.json({ error: 'Invalid API key' }, { status: 401 })\n    }\n\n    // Validate subscription and feature access\n    const validation = await validateFeature(project.userId, 'deviceTracking')\n    if (!validation.valid) {\n      return NextResponse.json(\n        { error: validation.error || 'Subscription invalid' },\n        { status: 403 }\n      )\n    }\n\n    const { \n      deviceId, \n      platform, \n      osVersion, \n      appVersion, \n      model, \n      manufacturer, \n      metadata, \n      deviceCode,\n      // Phase 1: Enhanced fingerprinting and health metrics\n      fingerprint,\n      batteryLevel,\n      storageFree,\n      memoryTotal,\n      networkType,\n      screenWidth,\n      screenHeight,\n      screenDensity,\n      cpuArchitecture,\n      // Firebase-like device properties\n      deviceCategory,\n      deviceBrand,\n      locale,\n      language,\n      timeZone,\n      timeZoneOffset,\n      advertisingId,\n      vendorId,\n      limitedAdTracking,\n      appId,\n      appInstanceId,\n      firstOpenAt,\n      firstPurchaseAt\n    } = await request.json()\n\n    // Check throttling for devices (only for new registrations)\n    // Check if device already exists (unique constraint removed, so use findFirst)\n    // Note: We check for any device with this projectId+deviceId, regardless of status\n    // If it exists but is deleted, we'll reactivate it\n    const existingDevice = await prisma.device.findFirst({\n      where: {\n        projectId: project.id,\n        deviceId\n      },\n      select: {\n        id: true,\n        deviceCode: true\n      }\n    })\n\n    // Check throttling for new device registrations\n    if (!existingDevice) {\n      const throttling = await checkThrottling(project.userId, 'devices')\n      if (throttling.throttled) {\n        console.log(`Device registration blocked: Quota exceeded for user ${project.userId}`, {\n          usage: throttling.usage,\n          retryAfter: throttling.retryAfter\n        })\n        return NextResponse.json(\n          {\n            error: throttling.error || 'Device quota exceeded',\n            usage: throttling.usage,\n            retryAfter: throttling.retryAfter,\n          },\n          {\n            status: 429,\n            headers: {\n              'Retry-After': throttling.retryAfter?.toString() || '3600',\n            },\n          }\n        )\n      }\n    }\n    \n    // Log device registration attempt\n    console.log(`Device registration: ${existingDevice ? 'UPDATE' : 'CREATE'}`, {\n      projectId: project.id,\n      deviceId,\n      platform,\n      existingDeviceId: existingDevice?.id,\n      existingDeviceCode: existingDevice?.deviceCode || 'NULL',\n      providedDeviceCode: deviceCode || 'NULL'\n    })\n\n    if (!deviceId || !platform) {\n      return NextResponse.json(\n        { error: 'deviceId and platform are required' },\n        { status: 400 }\n      )\n    }\n\n    // Build device data object\n    // Store extra fields that don't exist in Device model in metadata\n    const extraMetadata: any = {}\n    if (fingerprint !== undefined) extraMetadata.fingerprint = fingerprint\n    if (batteryLevel !== undefined) extraMetadata.batteryLevel = batteryLevel\n    if (storageFree !== undefined) extraMetadata.storageFree = storageFree\n    if (memoryTotal !== undefined) extraMetadata.memoryTotal = memoryTotal\n    if (networkType !== undefined) extraMetadata.networkType = networkType\n    if (screenWidth !== undefined) extraMetadata.screenWidth = screenWidth\n    if (screenHeight !== undefined) extraMetadata.screenHeight = screenHeight\n    if (screenDensity !== undefined) extraMetadata.screenDensity = screenDensity\n    if (cpuArchitecture !== undefined) extraMetadata.cpuArchitecture = cpuArchitecture\n    if (deviceCategory !== undefined) extraMetadata.deviceCategory = deviceCategory\n    if (deviceBrand !== undefined) extraMetadata.deviceBrand = deviceBrand\n    if (locale !== undefined) extraMetadata.locale = locale\n    if (language !== undefined) extraMetadata.language = language\n    if (timeZone !== undefined) extraMetadata.timeZone = timeZone\n    if (timeZoneOffset !== undefined) extraMetadata.timeZoneOffset = timeZoneOffset\n    if (advertisingId !== undefined) extraMetadata.advertisingId = advertisingId\n    if (vendorId !== undefined) extraMetadata.vendorId = vendorId\n    if (limitedAdTracking !== undefined) extraMetadata.limitedAdTracking = limitedAdTracking\n    if (appId !== undefined) extraMetadata.appId = appId\n    if (appInstanceId !== undefined) extraMetadata.appInstanceId = appInstanceId\n    if (firstOpenAt !== undefined) extraMetadata.firstOpenAt = firstOpenAt\n    if (firstPurchaseAt !== undefined) extraMetadata.firstPurchaseAt = firstPurchaseAt\n\n    // Merge provided metadata with extra fields\n    // Handle metadata as object or string\n    let finalMetadata: any = {}\n    if (metadata) {\n      if (typeof metadata === 'string') {\n        try {\n          finalMetadata = JSON.parse(metadata)\n        } catch {\n          finalMetadata = { raw: metadata }\n        }\n      } else if (typeof metadata === 'object') {\n        finalMetadata = metadata\n      }\n    }\n    const combinedMetadata = { ...finalMetadata, ...extraMetadata }\n\n    const deviceData: any = {\n      projectId: project.id,\n      deviceId,\n      platform,\n      status: 'active',\n      deletedAt: null,\n      lastSeenAt: new Date()\n    }\n\n    // Add optional fields only if they're provided (only fields that exist in schema)\n    if (osVersion) deviceData.osVersion = osVersion\n    if (appVersion) deviceData.appVersion = appVersion\n    if (model) deviceData.model = model\n    if (manufacturer) deviceData.manufacturer = manufacturer\n    if (Object.keys(combinedMetadata).length > 0) deviceData.metadata = combinedMetadata\n    if (deviceCode) deviceData.deviceCode = deviceCode\n\n    // Generate device code if not provided and device doesn't have one\n    let shouldGenerateCode = false\n    if (!deviceCode) {\n      if (!existingDevice) {\n        // New device - always generate code\n        shouldGenerateCode = true\n      } else if (!existingDevice.deviceCode) {\n        // Existing device without code - generate one\n        shouldGenerateCode = true\n      }\n    }\n    \n    if (shouldGenerateCode) {\n      deviceData.deviceCode = generateDeviceCode()\n      console.log(`Generated device code: ${deviceData.deviceCode} for device ${deviceId} (${existingDevice ? 'UPDATE' : 'CREATE'})`)\n    } else if (existingDevice && existingDevice.deviceCode) {\n      console.log(`Using existing device code: ${existingDevice.deviceCode} for device ${deviceId}`)\n      // Preserve existing code if not being updated\n      if (!deviceCode) {\n        deviceData.deviceCode = existingDevice.deviceCode\n      }\n    } else if (deviceCode) {\n      console.log(`Using provided device code: ${deviceCode} for device ${deviceId}`)\n    }\n\n    let device\n    if (existingDevice) {\n      // Update existing device\n      const { projectId: _, deviceId: __, ...updateData } = deviceData\n      // deviceCode is already set in deviceData (either generated, preserved, or provided)\n      // So it will be included in updateData automatically\n      console.log(`Updating device with deviceCode: ${updateData.deviceCode || 'NULL'}`)\n      device = await prisma.device.update({\n        where: { id: existingDevice.id },\n        data: updateData,\n        select: {\n          id: true,\n          deviceCode: true,\n          debugModeEnabled: true,\n          debugModeExpiresAt: true\n        }\n      })\n    } else {\n      // Create new device - ensure deviceCode is set\n      if (!deviceData.deviceCode) {\n        deviceData.deviceCode = generateDeviceCode()\n        console.log(`WARNING: Had to generate device code during CREATE: ${deviceData.deviceCode}`)\n      }\n      console.log(`Creating new device with deviceCode: ${deviceData.deviceCode}`)\n      device = await prisma.device.create({\n        data: deviceData,\n        select: {\n          id: true,\n          deviceCode: true,\n          debugModeEnabled: true,\n          debugModeExpiresAt: true\n        }\n      })\n      // Verify device code was saved\n      if (!device.deviceCode) {\n        console.error(`ERROR: Device ${device.id} created without device code!`)\n      }\n    }\n\n    // Check if debug mode is expired\n    const now = new Date()\n    const isDebugExpired = device.debugModeExpiresAt && device.debugModeExpiresAt < now\n    const effectiveDebugMode = device.debugModeEnabled && !isDebugExpired\n\n    // Ensure device code is set (should never be null at this point)\n    const finalDeviceCode = device.deviceCode || (existingDevice ? existingDevice.deviceCode : null)\n    if (!finalDeviceCode) {\n      console.error(`WARNING: Device ${device.id} has no device code after ${existingDevice ? 'UPDATE' : 'CREATE'}`)\n    }\n\n    console.log(`Device registration success: ${existingDevice ? 'UPDATED' : 'CREATED'}`, {\n      deviceId: device.id,\n      deviceCode: finalDeviceCode || 'NULL',\n      platform,\n      trackingEnabled: true,\n      wasGenerated: shouldGenerateCode\n    })\n\n    return NextResponse.json({\n      device: {\n        id: device.id,\n        deviceCode: finalDeviceCode, // Always return device code (never null)\n        debugModeEnabled: effectiveDebugMode,\n        debugModeExpiresAt: device.debugModeExpiresAt?.toISOString() || null,\n        trackingEnabled: true // This will be controlled by SDK settings trackingMode\n      }\n    })\n  } catch (error) {\n    console.error('Device registration error:', error)\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    const errorStack = error instanceof Error ? error.stack : undefined\n    console.error('Error details:', { errorMessage, errorStack })\n    return NextResponse.json({ \n      error: 'Internal server error',\n      details: process.env.NODE_ENV === 'development' ? errorMessage : undefined\n    }, { status: 500 })\n  }\n}\n\n// Dashboard endpoint: List devices for a project\nexport async function GET(request: NextRequest) {\n  try {\n    const user = await getAuthUser(request)\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const projectId = searchParams.get('projectId')\n    const platform = searchParams.get('platform') // 'android' | 'ios' | ''\n    const startDate = searchParams.get('startDate') // ISO date string\n    const endDate = searchParams.get('endDate') // ISO date string\n    const search = searchParams.get('search') // Search by deviceId, model\n    // Pagination parameters\n    const page = parseInt(searchParams.get('page') || '1')\n    const limit = parseInt(searchParams.get('limit') || '50')\n    const sortBy = searchParams.get('sortBy') || 'lastSeenAt'\n    const sortOrder = searchParams.get('sortOrder') || 'desc'\n\n    if (!projectId) {\n      return NextResponse.json({ error: 'projectId is required' }, { status: 400 })\n    }\n\n    // Check if user has access to project (owner or member)\n    const hasAccess = await canPerformAction(user.id, projectId, 'view')\n    if (!hasAccess) {\n      return NextResponse.json({ error: 'Project not found or access denied' }, { status: 404 })\n    }\n\n    // Verify project exists\n    const project = await prisma.project.findUnique({\n      where: { id: projectId }\n    })\n\n    if (!project) {\n      return NextResponse.json({ error: 'Project not found' }, { status: 404 })\n    }\n\n    // Build where clause with filters\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const where: any = { \n      projectId\n      // Note: Status filter temporarily removed until Prisma client recognizes the field\n      // TODO: Re-enable status filter after Prisma client is properly regenerated\n      // AND: [\n      //   {\n      //     OR: [\n      //       { status: 'active' },\n      //       { status: null } // Handle devices created before status field was added\n      //     ]\n      //   }\n      // ]\n    }\n\n    if (platform) {\n      where.platform = platform\n    }\n\n    if (startDate || endDate) {\n      where.createdAt = {}\n      if (startDate) {\n        where.createdAt.gte = new Date(startDate)\n      }\n      if (endDate) {\n        // Set to end of day\n        const end = new Date(endDate)\n        end.setHours(23, 59, 59, 999)\n        where.createdAt.lte = end\n      }\n    }\n\n    // Search by deviceId, model, deviceCode, user email\n    // Combine search with status filter using AND\n    if (search) {\n      where.AND = where.AND || []\n      where.AND.push({\n        OR: [\n          { deviceId: { contains: search, mode: 'insensitive' } },\n          { model: { contains: search, mode: 'insensitive' } },\n          { platform: { contains: search, mode: 'insensitive' } },\n          { deviceCode: { contains: search, mode: 'insensitive' } },\n          { userEmail: { contains: search, mode: 'insensitive' } },\n          { userName: { contains: search, mode: 'insensitive' } }\n        ]\n      })\n    }\n\n    // Calculate pagination offset\n    const skip = (page - 1) * limit\n\n    // Build orderBy clause\n    const orderBy: Record<string, string> = {}\n    orderBy[sortBy] = sortOrder\n\n    // Fetch devices with filters and pagination\n    // Note: Status filter will be added once Prisma client recognizes the status field\n    const [devices, filteredCount, totalCount, androidCount, iosCount, todayCount, thisWeekCount, thisMonthCount, debugModeCount] = await Promise.all([\n      prisma.device.findMany({\n        where,\n        orderBy,\n        skip,\n        take: limit,\n        select: {\n          id: true,\n          projectId: true,\n          deviceId: true,\n          deviceCode: true,\n          platform: true,\n          osVersion: true,\n          appVersion: true,\n          model: true,\n          manufacturer: true,\n          metadata: true,\n          userId: true,\n          userEmail: true,\n          userName: true,\n          debugModeEnabled: true,\n          debugModeEnabledAt: true,\n          debugModeExpiresAt: true,\n          lastSeenAt: true,\n          createdAt: true,\n          updatedAt: true\n        }\n      }),\n      // Count filtered results for pagination\n      prisma.device.count({ where }),\n      // Get aggregated stats (always for the full project, not filtered)\n      // Note: Status filter temporarily removed until Prisma client recognizes the field\n      prisma.device.count({ where: { projectId } }),\n      prisma.device.count({ where: { projectId, platform: 'android' } }),\n      prisma.device.count({ where: { projectId, platform: 'ios' } }),\n      prisma.device.count({\n        where: {\n          projectId,\n          createdAt: { gte: new Date(new Date().setHours(0, 0, 0, 0)) }\n        }\n      }),\n      prisma.device.count({\n        where: {\n          projectId,\n          createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }\n        }\n      }),\n      prisma.device.count({\n        where: {\n          projectId,\n          createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }\n        }\n      }),\n      prisma.device.count({\n        where: {\n          projectId,\n          debugModeEnabled: true\n        }\n      })\n    ])\n\n    const totalPages = Math.ceil(filteredCount / limit)\n\n    const stats = {\n      total: totalCount,\n      android: androidCount,\n      ios: iosCount,\n      today: todayCount,\n      thisWeek: thisWeekCount,\n      thisMonth: thisMonthCount,\n      debugModeCount\n    }\n\n    const pagination = {\n      page,\n      limit,\n      total: filteredCount,\n      totalPages,\n      hasNext: page < totalPages,\n      hasPrev: page > 1\n    }\n\n    return NextResponse.json({ devices, stats, pagination })\n  } catch (error) {\n    console.error('Get devices error:', error)\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    const errorStack = error instanceof Error ? error.stack : undefined\n    console.error('Error details:', { errorMessage, errorStack })\n    return NextResponse.json({ \n      error: 'Internal server error',\n      details: process.env.NODE_ENV === 'development' ? errorMessage : undefined\n    }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA;;;;;CAKC,GACD,SAAS;IACP,MAAM,QAAQ,mCAAmC,gBAAgB;;IACjE,MAAM,SAAS,IAAM,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM,MAAM,EAAE;IACpE,MAAM,OAAO,MAAM,IAAI,CAAC;QAAE,QAAQ;IAAE,GAAG,QAAQ,IAAI,CAAC;IACpD,OAAO,GAAG,KAAK,SAAS,CAAC,GAAG,GAAG,CAAC,EAAE,KAAK,SAAS,CAAC,IAAI;AACvD;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,mJAAc,EAAC;QACrC,IAAI,CAAC,SAAS;YACZ,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,2CAA2C;QAC3C,MAAM,aAAa,MAAM,IAAA,0KAAe,EAAC,QAAQ,MAAM,EAAE;QACzD,IAAI,CAAC,WAAW,KAAK,EAAE;YACrB,OAAO,iTAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,WAAW,KAAK,IAAI;YAAuB,GACpD;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,EACJ,QAAQ,EACR,QAAQ,EACR,SAAS,EACT,UAAU,EACV,KAAK,EACL,YAAY,EACZ,QAAQ,EACR,UAAU,EACV,sDAAsD;QACtD,WAAW,EACX,YAAY,EACZ,WAAW,EACX,WAAW,EACX,WAAW,EACX,WAAW,EACX,YAAY,EACZ,aAAa,EACb,eAAe,EACf,kCAAkC;QAClC,cAAc,EACd,WAAW,EACX,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,cAAc,EACd,aAAa,EACb,QAAQ,EACR,iBAAiB,EACjB,KAAK,EACL,aAAa,EACb,WAAW,EACX,eAAe,EAChB,GAAG,MAAM,QAAQ,IAAI;QAEtB,4DAA4D;QAC5D,+EAA+E;QAC/E,mFAAmF;QACnF,mDAAmD;QACnD,MAAM,iBAAiB,MAAM,6IAAM,CAAC,MAAM,CAAC,SAAS,CAAC;YACnD,OAAO;gBACL,WAAW,QAAQ,EAAE;gBACrB;YACF;YACA,QAAQ;gBACN,IAAI;gBACJ,YAAY;YACd;QACF;QAEA,gDAAgD;QAChD,IAAI,CAAC,gBAAgB;YACnB,MAAM,aAAa,MAAM,IAAA,0JAAe,EAAC,QAAQ,MAAM,EAAE;YACzD,IAAI,WAAW,SAAS,EAAE;gBACxB,QAAQ,GAAG,CAAC,CAAC,qDAAqD,EAAE,QAAQ,MAAM,EAAE,EAAE;oBACpF,OAAO,WAAW,KAAK;oBACvB,YAAY,WAAW,UAAU;gBACnC;gBACA,OAAO,iTAAY,CAAC,IAAI,CACtB;oBACE,OAAO,WAAW,KAAK,IAAI;oBAC3B,OAAO,WAAW,KAAK;oBACvB,YAAY,WAAW,UAAU;gBACnC,GACA;oBACE,QAAQ;oBACR,SAAS;wBACP,eAAe,WAAW,UAAU,EAAE,cAAc;oBACtD;gBACF;YAEJ;QACF;QAEA,kCAAkC;QAClC,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,iBAAiB,WAAW,UAAU,EAAE;YAC1E,WAAW,QAAQ,EAAE;YACrB;YACA;YACA,kBAAkB,gBAAgB;YAClC,oBAAoB,gBAAgB,cAAc;YAClD,oBAAoB,cAAc;QACpC;QAEA,IAAI,CAAC,YAAY,CAAC,UAAU;YAC1B,OAAO,iTAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAqC,GAC9C;gBAAE,QAAQ;YAAI;QAElB;QAEA,2BAA2B;QAC3B,kEAAkE;QAClE,MAAM,gBAAqB,CAAC;QAC5B,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,iBAAiB,WAAW,cAAc,YAAY,GAAG;QAC7D,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,iBAAiB,WAAW,cAAc,YAAY,GAAG;QAC7D,IAAI,kBAAkB,WAAW,cAAc,aAAa,GAAG;QAC/D,IAAI,oBAAoB,WAAW,cAAc,eAAe,GAAG;QACnE,IAAI,mBAAmB,WAAW,cAAc,cAAc,GAAG;QACjE,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,WAAW,WAAW,cAAc,MAAM,GAAG;QACjD,IAAI,aAAa,WAAW,cAAc,QAAQ,GAAG;QACrD,IAAI,aAAa,WAAW,cAAc,QAAQ,GAAG;QACrD,IAAI,mBAAmB,WAAW,cAAc,cAAc,GAAG;QACjE,IAAI,kBAAkB,WAAW,cAAc,aAAa,GAAG;QAC/D,IAAI,aAAa,WAAW,cAAc,QAAQ,GAAG;QACrD,IAAI,sBAAsB,WAAW,cAAc,iBAAiB,GAAG;QACvE,IAAI,UAAU,WAAW,cAAc,KAAK,GAAG;QAC/C,IAAI,kBAAkB,WAAW,cAAc,aAAa,GAAG;QAC/D,IAAI,gBAAgB,WAAW,cAAc,WAAW,GAAG;QAC3D,IAAI,oBAAoB,WAAW,cAAc,eAAe,GAAG;QAEnE,4CAA4C;QAC5C,sCAAsC;QACtC,IAAI,gBAAqB,CAAC;QAC1B,IAAI,UAAU;YACZ,IAAI,OAAO,aAAa,UAAU;gBAChC,IAAI;oBACF,gBAAgB,KAAK,KAAK,CAAC;gBAC7B,EAAE,OAAM;oBACN,gBAAgB;wBAAE,KAAK;oBAAS;gBAClC;YACF,OAAO,IAAI,OAAO,aAAa,UAAU;gBACvC,gBAAgB;YAClB;QACF;QACA,MAAM,mBAAmB;YAAE,GAAG,aAAa;YAAE,GAAG,aAAa;QAAC;QAE9D,MAAM,aAAkB;YACtB,WAAW,QAAQ,EAAE;YACrB;YACA;YACA,QAAQ;YACR,WAAW;YACX,YAAY,IAAI;QAClB;QAEA,kFAAkF;QAClF,IAAI,WAAW,WAAW,SAAS,GAAG;QACtC,IAAI,YAAY,WAAW,UAAU,GAAG;QACxC,IAAI,OAAO,WAAW,KAAK,GAAG;QAC9B,IAAI,cAAc,WAAW,YAAY,GAAG;QAC5C,IAAI,OAAO,IAAI,CAAC,kBAAkB,MAAM,GAAG,GAAG,WAAW,QAAQ,GAAG;QACpE,IAAI,YAAY,WAAW,UAAU,GAAG;QAExC,mEAAmE;QACnE,IAAI,qBAAqB;QACzB,IAAI,CAAC,YAAY;YACf,IAAI,CAAC,gBAAgB;gBACnB,oCAAoC;gBACpC,qBAAqB;YACvB,OAAO,IAAI,CAAC,eAAe,UAAU,EAAE;gBACrC,8CAA8C;gBAC9C,qBAAqB;YACvB;QACF;QAEA,IAAI,oBAAoB;YACtB,WAAW,UAAU,GAAG;YACxB,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,WAAW,UAAU,CAAC,YAAY,EAAE,SAAS,EAAE,EAAE,iBAAiB,WAAW,SAAS,CAAC,CAAC;QAChI,OAAO,IAAI,kBAAkB,eAAe,UAAU,EAAE;YACtD,QAAQ,GAAG,CAAC,CAAC,4BAA4B,EAAE,eAAe,UAAU,CAAC,YAAY,EAAE,UAAU;YAC7F,8CAA8C;YAC9C,IAAI,CAAC,YAAY;gBACf,WAAW,UAAU,GAAG,eAAe,UAAU;YACnD;QACF,OAAO,IAAI,YAAY;YACrB,QAAQ,GAAG,CAAC,CAAC,4BAA4B,EAAE,WAAW,YAAY,EAAE,UAAU;QAChF;QAEA,IAAI;QACJ,IAAI,gBAAgB;YAClB,yBAAyB;YACzB,MAAM,EAAE,WAAW,CAAC,EAAE,UAAU,EAAE,EAAE,GAAG,YAAY,GAAG;YACtD,qFAAqF;YACrF,qDAAqD;YACrD,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,WAAW,UAAU,IAAI,QAAQ;YACjF,SAAS,MAAM,6IAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gBAClC,OAAO;oBAAE,IAAI,eAAe,EAAE;gBAAC;gBAC/B,MAAM;gBACN,QAAQ;oBACN,IAAI;oBACJ,YAAY;oBACZ,kBAAkB;oBAClB,oBAAoB;gBACtB;YACF;QACF,OAAO;YACL,+CAA+C;YAC/C,IAAI,CAAC,WAAW,UAAU,EAAE;gBAC1B,WAAW,UAAU,GAAG;gBACxB,QAAQ,GAAG,CAAC,CAAC,oDAAoD,EAAE,WAAW,UAAU,EAAE;YAC5F;YACA,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,WAAW,UAAU,EAAE;YAC3E,SAAS,MAAM,6IAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gBAClC,MAAM;gBACN,QAAQ;oBACN,IAAI;oBACJ,YAAY;oBACZ,kBAAkB;oBAClB,oBAAoB;gBACtB;YACF;YACA,+BAA+B;YAC/B,IAAI,CAAC,OAAO,UAAU,EAAE;gBACtB,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,OAAO,EAAE,CAAC,6BAA6B,CAAC;YACzE;QACF;QAEA,iCAAiC;QACjC,MAAM,MAAM,IAAI;QAChB,MAAM,iBAAiB,OAAO,kBAAkB,IAAI,OAAO,kBAAkB,GAAG;QAChF,MAAM,qBAAqB,OAAO,gBAAgB,IAAI,CAAC;QAEvD,iEAAiE;QACjE,MAAM,kBAAkB,OAAO,UAAU,IAAI,CAAC,iBAAiB,eAAe,UAAU,GAAG,IAAI;QAC/F,IAAI,CAAC,iBAAiB;YACpB,QAAQ,KAAK,CAAC,CAAC,gBAAgB,EAAE,OAAO,EAAE,CAAC,0BAA0B,EAAE,iBAAiB,WAAW,UAAU;QAC/G;QAEA,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,iBAAiB,YAAY,WAAW,EAAE;YACpF,UAAU,OAAO,EAAE;YACnB,YAAY,mBAAmB;YAC/B;YACA,iBAAiB;YACjB,cAAc;QAChB;QAEA,OAAO,iTAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;gBACN,IAAI,OAAO,EAAE;gBACb,YAAY;gBACZ,kBAAkB;gBAClB,oBAAoB,OAAO,kBAAkB,EAAE,iBAAiB;gBAChE,iBAAiB,KAAK,uDAAuD;YAC/E;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QACrE,MAAM,aAAa,iBAAiB,QAAQ,MAAM,KAAK,GAAG;QAC1D,QAAQ,KAAK,CAAC,kBAAkB;YAAE;YAAc;QAAW;QAC3D,OAAO,iTAAY,CAAC,IAAI,CAAC;YACvB,OAAO;YACP,SAAS,uCAAyC,eAAe;QACnE,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,gJAAW,EAAC;QAC/B,IAAI,CAAC,MAAM;YACT,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,WAAW,aAAa,GAAG,CAAC,YAAY,yBAAyB;;QACvE,MAAM,YAAY,aAAa,GAAG,CAAC,aAAa,kBAAkB;;QAClE,MAAM,UAAU,aAAa,GAAG,CAAC,WAAW,kBAAkB;;QAC9D,MAAM,SAAS,aAAa,GAAG,CAAC,UAAU,4BAA4B;;QACtE,wBAAwB;QACxB,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAClD,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QACpD,MAAM,SAAS,aAAa,GAAG,CAAC,aAAa;QAC7C,MAAM,YAAY,aAAa,GAAG,CAAC,gBAAgB;QAEnD,IAAI,CAAC,WAAW;YACd,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAwB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,wDAAwD;QACxD,MAAM,YAAY,MAAM,IAAA,+JAAgB,EAAC,KAAK,EAAE,EAAE,WAAW;QAC7D,IAAI,CAAC,WAAW;YACd,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAqC,GAAG;gBAAE,QAAQ;YAAI;QAC1F;QAEA,wBAAwB;QACxB,MAAM,UAAU,MAAM,6IAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,IAAI;YAAU;QACzB;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,iTAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,kCAAkC;QAClC,8DAA8D;QAC9D,MAAM,QAAa;YACjB;QAWF;QAEA,IAAI,UAAU;YACZ,MAAM,QAAQ,GAAG;QACnB;QAEA,IAAI,aAAa,SAAS;YACxB,MAAM,SAAS,GAAG,CAAC;YACnB,IAAI,WAAW;gBACb,MAAM,SAAS,CAAC,GAAG,GAAG,IAAI,KAAK;YACjC;YACA,IAAI,SAAS;gBACX,oBAAoB;gBACpB,MAAM,MAAM,IAAI,KAAK;gBACrB,IAAI,QAAQ,CAAC,IAAI,IAAI,IAAI;gBACzB,MAAM,SAAS,CAAC,GAAG,GAAG;YACxB;QACF;QAEA,oDAAoD;QACpD,8CAA8C;QAC9C,IAAI,QAAQ;YACV,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,EAAE;YAC3B,MAAM,GAAG,CAAC,IAAI,CAAC;gBACb,IAAI;oBACF;wBAAE,UAAU;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACtD;wBAAE,OAAO;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACnD;wBAAE,UAAU;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACtD;wBAAE,YAAY;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACxD;wBAAE,WAAW;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;oBACvD;wBAAE,UAAU;4BAAE,UAAU;4BAAQ,MAAM;wBAAc;oBAAE;iBACvD;YACH;QACF;QAEA,8BAA8B;QAC9B,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;QAE1B,uBAAuB;QACvB,MAAM,UAAkC,CAAC;QACzC,OAAO,CAAC,OAAO,GAAG;QAElB,4CAA4C;QAC5C,mFAAmF;QACnF,MAAM,CAAC,SAAS,eAAe,YAAY,cAAc,UAAU,YAAY,eAAe,gBAAgB,eAAe,GAAG,MAAM,QAAQ,GAAG,CAAC;YAChJ,6IAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;gBACrB;gBACA;gBACA;gBACA,MAAM;gBACN,QAAQ;oBACN,IAAI;oBACJ,WAAW;oBACX,UAAU;oBACV,YAAY;oBACZ,UAAU;oBACV,WAAW;oBACX,YAAY;oBACZ,OAAO;oBACP,cAAc;oBACd,UAAU;oBACV,QAAQ;oBACR,WAAW;oBACX,UAAU;oBACV,kBAAkB;oBAClB,oBAAoB;oBACpB,oBAAoB;oBACpB,YAAY;oBACZ,WAAW;oBACX,WAAW;gBACb;YACF;YACA,wCAAwC;YACxC,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAAE;YAAM;YAC5B,mEAAmE;YACnE,mFAAmF;YACnF,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAAE,OAAO;oBAAE;gBAAU;YAAE;YAC3C,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAAE,OAAO;oBAAE;oBAAW,UAAU;gBAAU;YAAE;YAChE,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAAE,OAAO;oBAAE;oBAAW,UAAU;gBAAM;YAAE;YAC5D,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAClB,OAAO;oBACL;oBACA,WAAW;wBAAE,KAAK,IAAI,KAAK,IAAI,OAAO,QAAQ,CAAC,GAAG,GAAG,GAAG;oBAAI;gBAC9D;YACF;YACA,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAClB,OAAO;oBACL;oBACA,WAAW;wBAAE,KAAK,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK;oBAAM;gBACnE;YACF;YACA,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAClB,OAAO;oBACL;oBACA,WAAW;wBAAE,KAAK,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK;oBAAM;gBACpE;YACF;YACA,6IAAM,CAAC,MAAM,CAAC,KAAK,CAAC;gBAClB,OAAO;oBACL;oBACA,kBAAkB;gBACpB;YACF;SACD;QAED,MAAM,aAAa,KAAK,IAAI,CAAC,gBAAgB;QAE7C,MAAM,QAAQ;YACZ,OAAO;YACP,SAAS;YACT,KAAK;YACL,OAAO;YACP,UAAU;YACV,WAAW;YACX;QACF;QAEA,MAAM,aAAa;YACjB;YACA;YACA,OAAO;YACP;YACA,SAAS,OAAO;YAChB,SAAS,OAAO;QAClB;QAEA,OAAO,iTAAY,CAAC,IAAI,CAAC;YAAE;YAAS;YAAO;QAAW;IACxD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QACrE,MAAM,aAAa,iBAAiB,QAAQ,MAAM,KAAK,GAAG;QAC1D,QAAQ,KAAK,CAAC,kBAAkB;YAAE;YAAc;QAAW;QAC3D,OAAO,iTAAY,CAAC,IAAI,CAAC;YACvB,OAAO;YACP,SAAS,uCAAyC,eAAe;QACnE,GAAG;YAAE,QAAQ;QAAI;IACnB;AACF"}}]
}