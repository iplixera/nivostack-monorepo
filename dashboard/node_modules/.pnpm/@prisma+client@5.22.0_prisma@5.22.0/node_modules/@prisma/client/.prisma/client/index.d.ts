
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Crash
 * 
 */
export type Crash = $Result.DefaultSelection<Prisma.$CrashPayload>
/**
 * Model ApiTrace
 * 
 */
export type ApiTrace = $Result.DefaultSelection<Prisma.$ApiTracePayload>
/**
 * Model ApiConfig
 * 
 */
export type ApiConfig = $Result.DefaultSelection<Prisma.$ApiConfigPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model ApiAlert
 * 
 */
export type ApiAlert = $Result.DefaultSelection<Prisma.$ApiAlertPayload>
/**
 * Model MonitoredError
 * 
 */
export type MonitoredError = $Result.DefaultSelection<Prisma.$MonitoredErrorPayload>
/**
 * Model BusinessConfig
 * 
 */
export type BusinessConfig = $Result.DefaultSelection<Prisma.$BusinessConfigPayload>
/**
 * Model UploadedFile
 * 
 */
export type UploadedFile = $Result.DefaultSelection<Prisma.$UploadedFilePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model LocalizationKey
 * 
 */
export type LocalizationKey = $Result.DefaultSelection<Prisma.$LocalizationKeyPayload>
/**
 * Model Translation
 * 
 */
export type Translation = $Result.DefaultSelection<Prisma.$TranslationPayload>
/**
 * Model FeatureFlags
 * 
 */
export type FeatureFlags = $Result.DefaultSelection<Prisma.$FeatureFlagsPayload>
/**
 * Model SdkSettings
 * 
 */
export type SdkSettings = $Result.DefaultSelection<Prisma.$SdkSettingsPayload>
/**
 * Model ConfigCategory
 * 
 */
export type ConfigCategory = $Result.DefaultSelection<Prisma.$ConfigCategoryPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model EnforcementState
 * 
 */
export type EnforcementState = $Result.DefaultSelection<Prisma.$EnforcementStatePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Build
 * 
 */
export type Build = $Result.DefaultSelection<Prisma.$BuildPayload>
/**
 * Model BuildFeature
 * 
 */
export type BuildFeature = $Result.DefaultSelection<Prisma.$BuildFeaturePayload>
/**
 * Model BuildMode
 * 
 */
export type BuildMode = $Result.DefaultSelection<Prisma.$BuildModePayload>
/**
 * Model BuildChangeLog
 * 
 */
export type BuildChangeLog = $Result.DefaultSelection<Prisma.$BuildChangeLogPayload>
/**
 * Model MockEnvironment
 * 
 */
export type MockEnvironment = $Result.DefaultSelection<Prisma.$MockEnvironmentPayload>
/**
 * Model MockEndpoint
 * 
 */
export type MockEndpoint = $Result.DefaultSelection<Prisma.$MockEndpointPayload>
/**
 * Model MockResponse
 * 
 */
export type MockResponse = $Result.DefaultSelection<Prisma.$MockResponsePayload>
/**
 * Model MockCondition
 * 
 */
export type MockCondition = $Result.DefaultSelection<Prisma.$MockConditionPayload>
/**
 * Model ConfigAlert
 * 
 */
export type ConfigAlert = $Result.DefaultSelection<Prisma.$ConfigAlertPayload>
/**
 * Model ConfigAlertEvent
 * 
 */
export type ConfigAlertEvent = $Result.DefaultSelection<Prisma.$ConfigAlertEventPayload>
/**
 * Model ConfigApproval
 * 
 */
export type ConfigApproval = $Result.DefaultSelection<Prisma.$ConfigApprovalPayload>
/**
 * Model SystemConfiguration
 * 
 */
export type SystemConfiguration = $Result.DefaultSelection<Prisma.$SystemConfigurationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.crash`: Exposes CRUD operations for the **Crash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crashes
    * const crashes = await prisma.crash.findMany()
    * ```
    */
  get crash(): Prisma.CrashDelegate<ExtArgs>;

  /**
   * `prisma.apiTrace`: Exposes CRUD operations for the **ApiTrace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiTraces
    * const apiTraces = await prisma.apiTrace.findMany()
    * ```
    */
  get apiTrace(): Prisma.ApiTraceDelegate<ExtArgs>;

  /**
   * `prisma.apiConfig`: Exposes CRUD operations for the **ApiConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiConfigs
    * const apiConfigs = await prisma.apiConfig.findMany()
    * ```
    */
  get apiConfig(): Prisma.ApiConfigDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.apiAlert`: Exposes CRUD operations for the **ApiAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiAlerts
    * const apiAlerts = await prisma.apiAlert.findMany()
    * ```
    */
  get apiAlert(): Prisma.ApiAlertDelegate<ExtArgs>;

  /**
   * `prisma.monitoredError`: Exposes CRUD operations for the **MonitoredError** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonitoredErrors
    * const monitoredErrors = await prisma.monitoredError.findMany()
    * ```
    */
  get monitoredError(): Prisma.MonitoredErrorDelegate<ExtArgs>;

  /**
   * `prisma.businessConfig`: Exposes CRUD operations for the **BusinessConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessConfigs
    * const businessConfigs = await prisma.businessConfig.findMany()
    * ```
    */
  get businessConfig(): Prisma.BusinessConfigDelegate<ExtArgs>;

  /**
   * `prisma.uploadedFile`: Exposes CRUD operations for the **UploadedFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadedFiles
    * const uploadedFiles = await prisma.uploadedFile.findMany()
    * ```
    */
  get uploadedFile(): Prisma.UploadedFileDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.localizationKey`: Exposes CRUD operations for the **LocalizationKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalizationKeys
    * const localizationKeys = await prisma.localizationKey.findMany()
    * ```
    */
  get localizationKey(): Prisma.LocalizationKeyDelegate<ExtArgs>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **Translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.TranslationDelegate<ExtArgs>;

  /**
   * `prisma.featureFlags`: Exposes CRUD operations for the **FeatureFlags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureFlags
    * const featureFlags = await prisma.featureFlags.findMany()
    * ```
    */
  get featureFlags(): Prisma.FeatureFlagsDelegate<ExtArgs>;

  /**
   * `prisma.sdkSettings`: Exposes CRUD operations for the **SdkSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SdkSettings
    * const sdkSettings = await prisma.sdkSettings.findMany()
    * ```
    */
  get sdkSettings(): Prisma.SdkSettingsDelegate<ExtArgs>;

  /**
   * `prisma.configCategory`: Exposes CRUD operations for the **ConfigCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigCategories
    * const configCategories = await prisma.configCategory.findMany()
    * ```
    */
  get configCategory(): Prisma.ConfigCategoryDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.enforcementState`: Exposes CRUD operations for the **EnforcementState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnforcementStates
    * const enforcementStates = await prisma.enforcementState.findMany()
    * ```
    */
  get enforcementState(): Prisma.EnforcementStateDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<ExtArgs>;

  /**
   * `prisma.buildFeature`: Exposes CRUD operations for the **BuildFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildFeatures
    * const buildFeatures = await prisma.buildFeature.findMany()
    * ```
    */
  get buildFeature(): Prisma.BuildFeatureDelegate<ExtArgs>;

  /**
   * `prisma.buildMode`: Exposes CRUD operations for the **BuildMode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildModes
    * const buildModes = await prisma.buildMode.findMany()
    * ```
    */
  get buildMode(): Prisma.BuildModeDelegate<ExtArgs>;

  /**
   * `prisma.buildChangeLog`: Exposes CRUD operations for the **BuildChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildChangeLogs
    * const buildChangeLogs = await prisma.buildChangeLog.findMany()
    * ```
    */
  get buildChangeLog(): Prisma.BuildChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.mockEnvironment`: Exposes CRUD operations for the **MockEnvironment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockEnvironments
    * const mockEnvironments = await prisma.mockEnvironment.findMany()
    * ```
    */
  get mockEnvironment(): Prisma.MockEnvironmentDelegate<ExtArgs>;

  /**
   * `prisma.mockEndpoint`: Exposes CRUD operations for the **MockEndpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockEndpoints
    * const mockEndpoints = await prisma.mockEndpoint.findMany()
    * ```
    */
  get mockEndpoint(): Prisma.MockEndpointDelegate<ExtArgs>;

  /**
   * `prisma.mockResponse`: Exposes CRUD operations for the **MockResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockResponses
    * const mockResponses = await prisma.mockResponse.findMany()
    * ```
    */
  get mockResponse(): Prisma.MockResponseDelegate<ExtArgs>;

  /**
   * `prisma.mockCondition`: Exposes CRUD operations for the **MockCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockConditions
    * const mockConditions = await prisma.mockCondition.findMany()
    * ```
    */
  get mockCondition(): Prisma.MockConditionDelegate<ExtArgs>;

  /**
   * `prisma.configAlert`: Exposes CRUD operations for the **ConfigAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigAlerts
    * const configAlerts = await prisma.configAlert.findMany()
    * ```
    */
  get configAlert(): Prisma.ConfigAlertDelegate<ExtArgs>;

  /**
   * `prisma.configAlertEvent`: Exposes CRUD operations for the **ConfigAlertEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigAlertEvents
    * const configAlertEvents = await prisma.configAlertEvent.findMany()
    * ```
    */
  get configAlertEvent(): Prisma.ConfigAlertEventDelegate<ExtArgs>;

  /**
   * `prisma.configApproval`: Exposes CRUD operations for the **ConfigApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigApprovals
    * const configApprovals = await prisma.configApproval.findMany()
    * ```
    */
  get configApproval(): Prisma.ConfigApprovalDelegate<ExtArgs>;

  /**
   * `prisma.systemConfiguration`: Exposes CRUD operations for the **SystemConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigurations
    * const systemConfigurations = await prisma.systemConfiguration.findMany()
    * ```
    */
  get systemConfiguration(): Prisma.SystemConfigurationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    Device: 'Device',
    Log: 'Log',
    Crash: 'Crash',
    ApiTrace: 'ApiTrace',
    ApiConfig: 'ApiConfig',
    Session: 'Session',
    NotificationSettings: 'NotificationSettings',
    ApiAlert: 'ApiAlert',
    MonitoredError: 'MonitoredError',
    BusinessConfig: 'BusinessConfig',
    UploadedFile: 'UploadedFile',
    Language: 'Language',
    LocalizationKey: 'LocalizationKey',
    Translation: 'Translation',
    FeatureFlags: 'FeatureFlags',
    SdkSettings: 'SdkSettings',
    ConfigCategory: 'ConfigCategory',
    Plan: 'Plan',
    Subscription: 'Subscription',
    EnforcementState: 'EnforcementState',
    Invoice: 'Invoice',
    Build: 'Build',
    BuildFeature: 'BuildFeature',
    BuildMode: 'BuildMode',
    BuildChangeLog: 'BuildChangeLog',
    MockEnvironment: 'MockEnvironment',
    MockEndpoint: 'MockEndpoint',
    MockResponse: 'MockResponse',
    MockCondition: 'MockCondition',
    ConfigAlert: 'ConfigAlert',
    ConfigAlertEvent: 'ConfigAlertEvent',
    ConfigApproval: 'ConfigApproval',
    SystemConfiguration: 'SystemConfiguration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "device" | "log" | "crash" | "apiTrace" | "apiConfig" | "session" | "notificationSettings" | "apiAlert" | "monitoredError" | "businessConfig" | "uploadedFile" | "language" | "localizationKey" | "translation" | "featureFlags" | "sdkSettings" | "configCategory" | "plan" | "subscription" | "enforcementState" | "invoice" | "build" | "buildFeature" | "buildMode" | "buildChangeLog" | "mockEnvironment" | "mockEndpoint" | "mockResponse" | "mockCondition" | "configAlert" | "configAlertEvent" | "configApproval" | "systemConfiguration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Crash: {
        payload: Prisma.$CrashPayload<ExtArgs>
        fields: Prisma.CrashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          findFirst: {
            args: Prisma.CrashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          findMany: {
            args: Prisma.CrashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>[]
          }
          create: {
            args: Prisma.CrashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          createMany: {
            args: Prisma.CrashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>[]
          }
          delete: {
            args: Prisma.CrashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          update: {
            args: Prisma.CrashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          deleteMany: {
            args: Prisma.CrashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashPayload>
          }
          aggregate: {
            args: Prisma.CrashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrash>
          }
          groupBy: {
            args: Prisma.CrashGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrashGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrashCountArgs<ExtArgs>
            result: $Utils.Optional<CrashCountAggregateOutputType> | number
          }
        }
      }
      ApiTrace: {
        payload: Prisma.$ApiTracePayload<ExtArgs>
        fields: Prisma.ApiTraceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiTraceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiTraceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          findFirst: {
            args: Prisma.ApiTraceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiTraceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          findMany: {
            args: Prisma.ApiTraceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>[]
          }
          create: {
            args: Prisma.ApiTraceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          createMany: {
            args: Prisma.ApiTraceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiTraceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>[]
          }
          delete: {
            args: Prisma.ApiTraceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          update: {
            args: Prisma.ApiTraceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          deleteMany: {
            args: Prisma.ApiTraceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiTraceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiTraceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiTracePayload>
          }
          aggregate: {
            args: Prisma.ApiTraceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiTrace>
          }
          groupBy: {
            args: Prisma.ApiTraceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiTraceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiTraceCountArgs<ExtArgs>
            result: $Utils.Optional<ApiTraceCountAggregateOutputType> | number
          }
        }
      }
      ApiConfig: {
        payload: Prisma.$ApiConfigPayload<ExtArgs>
        fields: Prisma.ApiConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          findFirst: {
            args: Prisma.ApiConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          findMany: {
            args: Prisma.ApiConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>[]
          }
          create: {
            args: Prisma.ApiConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          createMany: {
            args: Prisma.ApiConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>[]
          }
          delete: {
            args: Prisma.ApiConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          update: {
            args: Prisma.ApiConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          deleteMany: {
            args: Prisma.ApiConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiConfigPayload>
          }
          aggregate: {
            args: Prisma.ApiConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiConfig>
          }
          groupBy: {
            args: Prisma.ApiConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ApiConfigCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      ApiAlert: {
        payload: Prisma.$ApiAlertPayload<ExtArgs>
        fields: Prisma.ApiAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          findFirst: {
            args: Prisma.ApiAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          findMany: {
            args: Prisma.ApiAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>[]
          }
          create: {
            args: Prisma.ApiAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          createMany: {
            args: Prisma.ApiAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>[]
          }
          delete: {
            args: Prisma.ApiAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          update: {
            args: Prisma.ApiAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          deleteMany: {
            args: Prisma.ApiAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiAlertPayload>
          }
          aggregate: {
            args: Prisma.ApiAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiAlert>
          }
          groupBy: {
            args: Prisma.ApiAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiAlertCountArgs<ExtArgs>
            result: $Utils.Optional<ApiAlertCountAggregateOutputType> | number
          }
        }
      }
      MonitoredError: {
        payload: Prisma.$MonitoredErrorPayload<ExtArgs>
        fields: Prisma.MonitoredErrorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonitoredErrorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonitoredErrorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          findFirst: {
            args: Prisma.MonitoredErrorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonitoredErrorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          findMany: {
            args: Prisma.MonitoredErrorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>[]
          }
          create: {
            args: Prisma.MonitoredErrorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          createMany: {
            args: Prisma.MonitoredErrorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonitoredErrorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>[]
          }
          delete: {
            args: Prisma.MonitoredErrorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          update: {
            args: Prisma.MonitoredErrorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          deleteMany: {
            args: Prisma.MonitoredErrorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonitoredErrorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonitoredErrorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonitoredErrorPayload>
          }
          aggregate: {
            args: Prisma.MonitoredErrorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitoredError>
          }
          groupBy: {
            args: Prisma.MonitoredErrorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonitoredErrorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonitoredErrorCountArgs<ExtArgs>
            result: $Utils.Optional<MonitoredErrorCountAggregateOutputType> | number
          }
        }
      }
      BusinessConfig: {
        payload: Prisma.$BusinessConfigPayload<ExtArgs>
        fields: Prisma.BusinessConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          findFirst: {
            args: Prisma.BusinessConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          findMany: {
            args: Prisma.BusinessConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>[]
          }
          create: {
            args: Prisma.BusinessConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          createMany: {
            args: Prisma.BusinessConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>[]
          }
          delete: {
            args: Prisma.BusinessConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          update: {
            args: Prisma.BusinessConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          deleteMany: {
            args: Prisma.BusinessConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessConfigPayload>
          }
          aggregate: {
            args: Prisma.BusinessConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessConfig>
          }
          groupBy: {
            args: Prisma.BusinessConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessConfigCountAggregateOutputType> | number
          }
        }
      }
      UploadedFile: {
        payload: Prisma.$UploadedFilePayload<ExtArgs>
        fields: Prisma.UploadedFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadedFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadedFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findFirst: {
            args: Prisma.UploadedFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadedFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          findMany: {
            args: Prisma.UploadedFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          create: {
            args: Prisma.UploadedFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          createMany: {
            args: Prisma.UploadedFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadedFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>[]
          }
          delete: {
            args: Prisma.UploadedFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          update: {
            args: Prisma.UploadedFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          deleteMany: {
            args: Prisma.UploadedFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadedFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UploadedFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadedFilePayload>
          }
          aggregate: {
            args: Prisma.UploadedFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUploadedFile>
          }
          groupBy: {
            args: Prisma.UploadedFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadedFileCountArgs<ExtArgs>
            result: $Utils.Optional<UploadedFileCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      LocalizationKey: {
        payload: Prisma.$LocalizationKeyPayload<ExtArgs>
        fields: Prisma.LocalizationKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalizationKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalizationKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          findFirst: {
            args: Prisma.LocalizationKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalizationKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          findMany: {
            args: Prisma.LocalizationKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>[]
          }
          create: {
            args: Prisma.LocalizationKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          createMany: {
            args: Prisma.LocalizationKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalizationKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>[]
          }
          delete: {
            args: Prisma.LocalizationKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          update: {
            args: Prisma.LocalizationKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          deleteMany: {
            args: Prisma.LocalizationKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalizationKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalizationKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizationKeyPayload>
          }
          aggregate: {
            args: Prisma.LocalizationKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalizationKey>
          }
          groupBy: {
            args: Prisma.LocalizationKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalizationKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalizationKeyCountArgs<ExtArgs>
            result: $Utils.Optional<LocalizationKeyCountAggregateOutputType> | number
          }
        }
      }
      Translation: {
        payload: Prisma.$TranslationPayload<ExtArgs>
        fields: Prisma.TranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findFirst: {
            args: Prisma.TranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findMany: {
            args: Prisma.TranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          create: {
            args: Prisma.TranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          createMany: {
            args: Prisma.TranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          delete: {
            args: Prisma.TranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          update: {
            args: Prisma.TranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          deleteMany: {
            args: Prisma.TranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.TranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
      FeatureFlags: {
        payload: Prisma.$FeatureFlagsPayload<ExtArgs>
        fields: Prisma.FeatureFlagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFlagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFlagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          findFirst: {
            args: Prisma.FeatureFlagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFlagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          findMany: {
            args: Prisma.FeatureFlagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>[]
          }
          create: {
            args: Prisma.FeatureFlagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          createMany: {
            args: Prisma.FeatureFlagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureFlagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>[]
          }
          delete: {
            args: Prisma.FeatureFlagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          update: {
            args: Prisma.FeatureFlagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          deleteMany: {
            args: Prisma.FeatureFlagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureFlagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeatureFlagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagsPayload>
          }
          aggregate: {
            args: Prisma.FeatureFlagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureFlags>
          }
          groupBy: {
            args: Prisma.FeatureFlagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureFlagsCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagsCountAggregateOutputType> | number
          }
        }
      }
      SdkSettings: {
        payload: Prisma.$SdkSettingsPayload<ExtArgs>
        fields: Prisma.SdkSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SdkSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SdkSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          findFirst: {
            args: Prisma.SdkSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SdkSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          findMany: {
            args: Prisma.SdkSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>[]
          }
          create: {
            args: Prisma.SdkSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          createMany: {
            args: Prisma.SdkSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SdkSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>[]
          }
          delete: {
            args: Prisma.SdkSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          update: {
            args: Prisma.SdkSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SdkSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SdkSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SdkSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SdkSettingsPayload>
          }
          aggregate: {
            args: Prisma.SdkSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSdkSettings>
          }
          groupBy: {
            args: Prisma.SdkSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SdkSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SdkSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SdkSettingsCountAggregateOutputType> | number
          }
        }
      }
      ConfigCategory: {
        payload: Prisma.$ConfigCategoryPayload<ExtArgs>
        fields: Prisma.ConfigCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          findFirst: {
            args: Prisma.ConfigCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          findMany: {
            args: Prisma.ConfigCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>[]
          }
          create: {
            args: Prisma.ConfigCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          createMany: {
            args: Prisma.ConfigCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>[]
          }
          delete: {
            args: Prisma.ConfigCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          update: {
            args: Prisma.ConfigCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ConfigCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigCategoryPayload>
          }
          aggregate: {
            args: Prisma.ConfigCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigCategory>
          }
          groupBy: {
            args: Prisma.ConfigCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCategoryCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      EnforcementState: {
        payload: Prisma.$EnforcementStatePayload<ExtArgs>
        fields: Prisma.EnforcementStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnforcementStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnforcementStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          findFirst: {
            args: Prisma.EnforcementStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnforcementStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          findMany: {
            args: Prisma.EnforcementStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>[]
          }
          create: {
            args: Prisma.EnforcementStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          createMany: {
            args: Prisma.EnforcementStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnforcementStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>[]
          }
          delete: {
            args: Prisma.EnforcementStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          update: {
            args: Prisma.EnforcementStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          deleteMany: {
            args: Prisma.EnforcementStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnforcementStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnforcementStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnforcementStatePayload>
          }
          aggregate: {
            args: Prisma.EnforcementStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnforcementState>
          }
          groupBy: {
            args: Prisma.EnforcementStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnforcementStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnforcementStateCountArgs<ExtArgs>
            result: $Utils.Optional<EnforcementStateCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Build: {
        payload: Prisma.$BuildPayload<ExtArgs>
        fields: Prisma.BuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findFirst: {
            args: Prisma.BuildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findMany: {
            args: Prisma.BuildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>[]
          }
          create: {
            args: Prisma.BuildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          createMany: {
            args: Prisma.BuildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>[]
          }
          delete: {
            args: Prisma.BuildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          update: {
            args: Prisma.BuildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          deleteMany: {
            args: Prisma.BuildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          aggregate: {
            args: Prisma.BuildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuild>
          }
          groupBy: {
            args: Prisma.BuildGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildCountArgs<ExtArgs>
            result: $Utils.Optional<BuildCountAggregateOutputType> | number
          }
        }
      }
      BuildFeature: {
        payload: Prisma.$BuildFeaturePayload<ExtArgs>
        fields: Prisma.BuildFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          findFirst: {
            args: Prisma.BuildFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          findMany: {
            args: Prisma.BuildFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>[]
          }
          create: {
            args: Prisma.BuildFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          createMany: {
            args: Prisma.BuildFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>[]
          }
          delete: {
            args: Prisma.BuildFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          update: {
            args: Prisma.BuildFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          deleteMany: {
            args: Prisma.BuildFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildFeaturePayload>
          }
          aggregate: {
            args: Prisma.BuildFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuildFeature>
          }
          groupBy: {
            args: Prisma.BuildFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<BuildFeatureCountAggregateOutputType> | number
          }
        }
      }
      BuildMode: {
        payload: Prisma.$BuildModePayload<ExtArgs>
        fields: Prisma.BuildModeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildModeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildModeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          findFirst: {
            args: Prisma.BuildModeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildModeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          findMany: {
            args: Prisma.BuildModeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>[]
          }
          create: {
            args: Prisma.BuildModeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          createMany: {
            args: Prisma.BuildModeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildModeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>[]
          }
          delete: {
            args: Prisma.BuildModeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          update: {
            args: Prisma.BuildModeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          deleteMany: {
            args: Prisma.BuildModeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildModeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildModeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildModePayload>
          }
          aggregate: {
            args: Prisma.BuildModeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuildMode>
          }
          groupBy: {
            args: Prisma.BuildModeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildModeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildModeCountArgs<ExtArgs>
            result: $Utils.Optional<BuildModeCountAggregateOutputType> | number
          }
        }
      }
      BuildChangeLog: {
        payload: Prisma.$BuildChangeLogPayload<ExtArgs>
        fields: Prisma.BuildChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          findFirst: {
            args: Prisma.BuildChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          findMany: {
            args: Prisma.BuildChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>[]
          }
          create: {
            args: Prisma.BuildChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          createMany: {
            args: Prisma.BuildChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>[]
          }
          delete: {
            args: Prisma.BuildChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          update: {
            args: Prisma.BuildChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.BuildChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildChangeLogPayload>
          }
          aggregate: {
            args: Prisma.BuildChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuildChangeLog>
          }
          groupBy: {
            args: Prisma.BuildChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<BuildChangeLogCountAggregateOutputType> | number
          }
        }
      }
      MockEnvironment: {
        payload: Prisma.$MockEnvironmentPayload<ExtArgs>
        fields: Prisma.MockEnvironmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockEnvironmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockEnvironmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          findFirst: {
            args: Prisma.MockEnvironmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockEnvironmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          findMany: {
            args: Prisma.MockEnvironmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>[]
          }
          create: {
            args: Prisma.MockEnvironmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          createMany: {
            args: Prisma.MockEnvironmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockEnvironmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>[]
          }
          delete: {
            args: Prisma.MockEnvironmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          update: {
            args: Prisma.MockEnvironmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          deleteMany: {
            args: Prisma.MockEnvironmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockEnvironmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MockEnvironmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEnvironmentPayload>
          }
          aggregate: {
            args: Prisma.MockEnvironmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockEnvironment>
          }
          groupBy: {
            args: Prisma.MockEnvironmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockEnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockEnvironmentCountArgs<ExtArgs>
            result: $Utils.Optional<MockEnvironmentCountAggregateOutputType> | number
          }
        }
      }
      MockEndpoint: {
        payload: Prisma.$MockEndpointPayload<ExtArgs>
        fields: Prisma.MockEndpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockEndpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockEndpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          findFirst: {
            args: Prisma.MockEndpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockEndpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          findMany: {
            args: Prisma.MockEndpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>[]
          }
          create: {
            args: Prisma.MockEndpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          createMany: {
            args: Prisma.MockEndpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockEndpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>[]
          }
          delete: {
            args: Prisma.MockEndpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          update: {
            args: Prisma.MockEndpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          deleteMany: {
            args: Prisma.MockEndpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockEndpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MockEndpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockEndpointPayload>
          }
          aggregate: {
            args: Prisma.MockEndpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockEndpoint>
          }
          groupBy: {
            args: Prisma.MockEndpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockEndpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockEndpointCountArgs<ExtArgs>
            result: $Utils.Optional<MockEndpointCountAggregateOutputType> | number
          }
        }
      }
      MockResponse: {
        payload: Prisma.$MockResponsePayload<ExtArgs>
        fields: Prisma.MockResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          findFirst: {
            args: Prisma.MockResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          findMany: {
            args: Prisma.MockResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>[]
          }
          create: {
            args: Prisma.MockResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          createMany: {
            args: Prisma.MockResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>[]
          }
          delete: {
            args: Prisma.MockResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          update: {
            args: Prisma.MockResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          deleteMany: {
            args: Prisma.MockResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MockResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockResponsePayload>
          }
          aggregate: {
            args: Prisma.MockResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockResponse>
          }
          groupBy: {
            args: Prisma.MockResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockResponseCountArgs<ExtArgs>
            result: $Utils.Optional<MockResponseCountAggregateOutputType> | number
          }
        }
      }
      MockCondition: {
        payload: Prisma.$MockConditionPayload<ExtArgs>
        fields: Prisma.MockConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          findFirst: {
            args: Prisma.MockConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          findMany: {
            args: Prisma.MockConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>[]
          }
          create: {
            args: Prisma.MockConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          createMany: {
            args: Prisma.MockConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>[]
          }
          delete: {
            args: Prisma.MockConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          update: {
            args: Prisma.MockConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          deleteMany: {
            args: Prisma.MockConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MockConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockConditionPayload>
          }
          aggregate: {
            args: Prisma.MockConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockCondition>
          }
          groupBy: {
            args: Prisma.MockConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockConditionCountArgs<ExtArgs>
            result: $Utils.Optional<MockConditionCountAggregateOutputType> | number
          }
        }
      }
      ConfigAlert: {
        payload: Prisma.$ConfigAlertPayload<ExtArgs>
        fields: Prisma.ConfigAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          findFirst: {
            args: Prisma.ConfigAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          findMany: {
            args: Prisma.ConfigAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>[]
          }
          create: {
            args: Prisma.ConfigAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          createMany: {
            args: Prisma.ConfigAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>[]
          }
          delete: {
            args: Prisma.ConfigAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          update: {
            args: Prisma.ConfigAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          deleteMany: {
            args: Prisma.ConfigAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertPayload>
          }
          aggregate: {
            args: Prisma.ConfigAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigAlert>
          }
          groupBy: {
            args: Prisma.ConfigAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigAlertCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigAlertCountAggregateOutputType> | number
          }
        }
      }
      ConfigAlertEvent: {
        payload: Prisma.$ConfigAlertEventPayload<ExtArgs>
        fields: Prisma.ConfigAlertEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigAlertEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigAlertEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          findFirst: {
            args: Prisma.ConfigAlertEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigAlertEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          findMany: {
            args: Prisma.ConfigAlertEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>[]
          }
          create: {
            args: Prisma.ConfigAlertEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          createMany: {
            args: Prisma.ConfigAlertEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigAlertEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>[]
          }
          delete: {
            args: Prisma.ConfigAlertEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          update: {
            args: Prisma.ConfigAlertEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          deleteMany: {
            args: Prisma.ConfigAlertEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigAlertEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigAlertEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigAlertEventPayload>
          }
          aggregate: {
            args: Prisma.ConfigAlertEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigAlertEvent>
          }
          groupBy: {
            args: Prisma.ConfigAlertEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigAlertEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigAlertEventCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigAlertEventCountAggregateOutputType> | number
          }
        }
      }
      ConfigApproval: {
        payload: Prisma.$ConfigApprovalPayload<ExtArgs>
        fields: Prisma.ConfigApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          findFirst: {
            args: Prisma.ConfigApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          findMany: {
            args: Prisma.ConfigApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>[]
          }
          create: {
            args: Prisma.ConfigApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          createMany: {
            args: Prisma.ConfigApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>[]
          }
          delete: {
            args: Prisma.ConfigApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          update: {
            args: Prisma.ConfigApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ConfigApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigApprovalPayload>
          }
          aggregate: {
            args: Prisma.ConfigApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigApproval>
          }
          groupBy: {
            args: Prisma.ConfigApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigApprovalCountAggregateOutputType> | number
          }
        }
      }
      SystemConfiguration: {
        payload: Prisma.$SystemConfigurationPayload<ExtArgs>
        fields: Prisma.SystemConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          findMany: {
            args: Prisma.SystemConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>[]
          }
          create: {
            args: Prisma.SystemConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          createMany: {
            args: Prisma.SystemConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          update: {
            args: Prisma.SystemConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigurationPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfiguration>
          }
          groupBy: {
            args: Prisma.SystemConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigurationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    devices: number
    logs: number
    crashes: number
    apiTraces: number
    apiConfigs: number
    sessions: number
    apiAlerts: number
    builds: number
    mockEnvironments: number
    businessConfigs: number
    configAlerts: number
    configApprovals: number
    languages: number
    localizationKeys: number
    configCategories: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | ProjectCountOutputTypeCountDevicesArgs
    logs?: boolean | ProjectCountOutputTypeCountLogsArgs
    crashes?: boolean | ProjectCountOutputTypeCountCrashesArgs
    apiTraces?: boolean | ProjectCountOutputTypeCountApiTracesArgs
    apiConfigs?: boolean | ProjectCountOutputTypeCountApiConfigsArgs
    sessions?: boolean | ProjectCountOutputTypeCountSessionsArgs
    apiAlerts?: boolean | ProjectCountOutputTypeCountApiAlertsArgs
    builds?: boolean | ProjectCountOutputTypeCountBuildsArgs
    mockEnvironments?: boolean | ProjectCountOutputTypeCountMockEnvironmentsArgs
    businessConfigs?: boolean | ProjectCountOutputTypeCountBusinessConfigsArgs
    configAlerts?: boolean | ProjectCountOutputTypeCountConfigAlertsArgs
    configApprovals?: boolean | ProjectCountOutputTypeCountConfigApprovalsArgs
    languages?: boolean | ProjectCountOutputTypeCountLanguagesArgs
    localizationKeys?: boolean | ProjectCountOutputTypeCountLocalizationKeysArgs
    configCategories?: boolean | ProjectCountOutputTypeCountConfigCategoriesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCrashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiTraceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiConfigWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiAlertWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBuildsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMockEnvironmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockEnvironmentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBusinessConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessConfigWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountConfigAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigAlertWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountConfigApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigApprovalWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLocalizationKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalizationKeyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountConfigCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigCategoryWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    logs: number
    crashes: number
    apiTraces: number
    sessions: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | DeviceCountOutputTypeCountLogsArgs
    crashes?: boolean | DeviceCountOutputTypeCountCrashesArgs
    apiTraces?: boolean | DeviceCountOutputTypeCountApiTracesArgs
    sessions?: boolean | DeviceCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountCrashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountApiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiTraceWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    apiTraces: number
    logs: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiTraces?: boolean | SessionCountOutputTypeCountApiTracesArgs
    logs?: boolean | SessionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountApiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiTraceWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Count Type ApiAlertCountOutputType
   */

  export type ApiAlertCountOutputType = {
    monitoredErrors: number
  }

  export type ApiAlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitoredErrors?: boolean | ApiAlertCountOutputTypeCountMonitoredErrorsArgs
  }

  // Custom InputTypes
  /**
   * ApiAlertCountOutputType without action
   */
  export type ApiAlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlertCountOutputType
     */
    select?: ApiAlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiAlertCountOutputType without action
   */
  export type ApiAlertCountOutputTypeCountMonitoredErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitoredErrorWhereInput
  }


  /**
   * Count Type BusinessConfigCountOutputType
   */

  export type BusinessConfigCountOutputType = {
    alerts: number
    approvals: number
  }

  export type BusinessConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | BusinessConfigCountOutputTypeCountAlertsArgs
    approvals?: boolean | BusinessConfigCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * BusinessConfigCountOutputType without action
   */
  export type BusinessConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfigCountOutputType
     */
    select?: BusinessConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessConfigCountOutputType without action
   */
  export type BusinessConfigCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigAlertWhereInput
  }

  /**
   * BusinessConfigCountOutputType without action
   */
  export type BusinessConfigCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigApprovalWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    translations: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | LanguageCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }


  /**
   * Count Type LocalizationKeyCountOutputType
   */

  export type LocalizationKeyCountOutputType = {
    translations: number
  }

  export type LocalizationKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | LocalizationKeyCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * LocalizationKeyCountOutputType without action
   */
  export type LocalizationKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKeyCountOutputType
     */
    select?: LocalizationKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalizationKeyCountOutputType without action
   */
  export type LocalizationKeyCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type BuildCountOutputType
   */

  export type BuildCountOutputType = {
    features: number
    changeLogs: number
  }

  export type BuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | BuildCountOutputTypeCountFeaturesArgs
    changeLogs?: boolean | BuildCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     */
    select?: BuildCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildFeatureWhereInput
  }

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildChangeLogWhereInput
  }


  /**
   * Count Type MockEnvironmentCountOutputType
   */

  export type MockEnvironmentCountOutputType = {
    endpoints: number
  }

  export type MockEnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoints?: boolean | MockEnvironmentCountOutputTypeCountEndpointsArgs
  }

  // Custom InputTypes
  /**
   * MockEnvironmentCountOutputType without action
   */
  export type MockEnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironmentCountOutputType
     */
    select?: MockEnvironmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MockEnvironmentCountOutputType without action
   */
  export type MockEnvironmentCountOutputTypeCountEndpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockEndpointWhereInput
  }


  /**
   * Count Type MockEndpointCountOutputType
   */

  export type MockEndpointCountOutputType = {
    responses: number
    conditions: number
  }

  export type MockEndpointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | MockEndpointCountOutputTypeCountResponsesArgs
    conditions?: boolean | MockEndpointCountOutputTypeCountConditionsArgs
  }

  // Custom InputTypes
  /**
   * MockEndpointCountOutputType without action
   */
  export type MockEndpointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpointCountOutputType
     */
    select?: MockEndpointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MockEndpointCountOutputType without action
   */
  export type MockEndpointCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockResponseWhereInput
  }

  /**
   * MockEndpointCountOutputType without action
   */
  export type MockEndpointCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockConditionWhereInput
  }


  /**
   * Count Type MockResponseCountOutputType
   */

  export type MockResponseCountOutputType = {
    conditions: number
  }

  export type MockResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditions?: boolean | MockResponseCountOutputTypeCountConditionsArgs
  }

  // Custom InputTypes
  /**
   * MockResponseCountOutputType without action
   */
  export type MockResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponseCountOutputType
     */
    select?: MockResponseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MockResponseCountOutputType without action
   */
  export type MockResponseCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockConditionWhereInput
  }


  /**
   * Count Type ConfigAlertCountOutputType
   */

  export type ConfigAlertCountOutputType = {
    events: number
  }

  export type ConfigAlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | ConfigAlertCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ConfigAlertCountOutputType without action
   */
  export type ConfigAlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertCountOutputType
     */
    select?: ConfigAlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConfigAlertCountOutputType without action
   */
  export type ConfigAlertCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigAlertEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    isAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    isAdmin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isAdmin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    isAdmin: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      isAdmin: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    apiKey: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    apiKey: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    devices?: boolean | Project$devicesArgs<ExtArgs>
    logs?: boolean | Project$logsArgs<ExtArgs>
    crashes?: boolean | Project$crashesArgs<ExtArgs>
    apiTraces?: boolean | Project$apiTracesArgs<ExtArgs>
    apiConfigs?: boolean | Project$apiConfigsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    notificationSettings?: boolean | Project$notificationSettingsArgs<ExtArgs>
    apiAlerts?: boolean | Project$apiAlertsArgs<ExtArgs>
    builds?: boolean | Project$buildsArgs<ExtArgs>
    buildMode?: boolean | Project$buildModeArgs<ExtArgs>
    mockEnvironments?: boolean | Project$mockEnvironmentsArgs<ExtArgs>
    businessConfigs?: boolean | Project$businessConfigsArgs<ExtArgs>
    configAlerts?: boolean | Project$configAlertsArgs<ExtArgs>
    configApprovals?: boolean | Project$configApprovalsArgs<ExtArgs>
    languages?: boolean | Project$languagesArgs<ExtArgs>
    localizationKeys?: boolean | Project$localizationKeysArgs<ExtArgs>
    featureFlags?: boolean | Project$featureFlagsArgs<ExtArgs>
    sdkSettings?: boolean | Project$sdkSettingsArgs<ExtArgs>
    configCategories?: boolean | Project$configCategoriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    apiKey?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    devices?: boolean | Project$devicesArgs<ExtArgs>
    logs?: boolean | Project$logsArgs<ExtArgs>
    crashes?: boolean | Project$crashesArgs<ExtArgs>
    apiTraces?: boolean | Project$apiTracesArgs<ExtArgs>
    apiConfigs?: boolean | Project$apiConfigsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    notificationSettings?: boolean | Project$notificationSettingsArgs<ExtArgs>
    apiAlerts?: boolean | Project$apiAlertsArgs<ExtArgs>
    builds?: boolean | Project$buildsArgs<ExtArgs>
    buildMode?: boolean | Project$buildModeArgs<ExtArgs>
    mockEnvironments?: boolean | Project$mockEnvironmentsArgs<ExtArgs>
    businessConfigs?: boolean | Project$businessConfigsArgs<ExtArgs>
    configAlerts?: boolean | Project$configAlertsArgs<ExtArgs>
    configApprovals?: boolean | Project$configApprovalsArgs<ExtArgs>
    languages?: boolean | Project$languagesArgs<ExtArgs>
    localizationKeys?: boolean | Project$localizationKeysArgs<ExtArgs>
    featureFlags?: boolean | Project$featureFlagsArgs<ExtArgs>
    sdkSettings?: boolean | Project$sdkSettingsArgs<ExtArgs>
    configCategories?: boolean | Project$configCategoriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      devices: Prisma.$DevicePayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      crashes: Prisma.$CrashPayload<ExtArgs>[]
      apiTraces: Prisma.$ApiTracePayload<ExtArgs>[]
      apiConfigs: Prisma.$ApiConfigPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      notificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs> | null
      apiAlerts: Prisma.$ApiAlertPayload<ExtArgs>[]
      builds: Prisma.$BuildPayload<ExtArgs>[]
      buildMode: Prisma.$BuildModePayload<ExtArgs> | null
      mockEnvironments: Prisma.$MockEnvironmentPayload<ExtArgs>[]
      businessConfigs: Prisma.$BusinessConfigPayload<ExtArgs>[]
      configAlerts: Prisma.$ConfigAlertPayload<ExtArgs>[]
      configApprovals: Prisma.$ConfigApprovalPayload<ExtArgs>[]
      languages: Prisma.$LanguagePayload<ExtArgs>[]
      localizationKeys: Prisma.$LocalizationKeyPayload<ExtArgs>[]
      featureFlags: Prisma.$FeatureFlagsPayload<ExtArgs> | null
      sdkSettings: Prisma.$SdkSettingsPayload<ExtArgs> | null
      configCategories: Prisma.$ConfigCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      apiKey: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    devices<T extends Project$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Project$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Project$logsArgs<ExtArgs> = {}>(args?: Subset<T, Project$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    crashes<T extends Project$crashesArgs<ExtArgs> = {}>(args?: Subset<T, Project$crashesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findMany"> | Null>
    apiTraces<T extends Project$apiTracesArgs<ExtArgs> = {}>(args?: Subset<T, Project$apiTracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findMany"> | Null>
    apiConfigs<T extends Project$apiConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Project$apiConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Project$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    notificationSettings<T extends Project$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Project$notificationSettingsArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    apiAlerts<T extends Project$apiAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Project$apiAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findMany"> | Null>
    builds<T extends Project$buildsArgs<ExtArgs> = {}>(args?: Subset<T, Project$buildsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findMany"> | Null>
    buildMode<T extends Project$buildModeArgs<ExtArgs> = {}>(args?: Subset<T, Project$buildModeArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mockEnvironments<T extends Project$mockEnvironmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$mockEnvironmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findMany"> | Null>
    businessConfigs<T extends Project$businessConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Project$businessConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findMany"> | Null>
    configAlerts<T extends Project$configAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Project$configAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findMany"> | Null>
    configApprovals<T extends Project$configApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, Project$configApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    languages<T extends Project$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany"> | Null>
    localizationKeys<T extends Project$localizationKeysArgs<ExtArgs> = {}>(args?: Subset<T, Project$localizationKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findMany"> | Null>
    featureFlags<T extends Project$featureFlagsArgs<ExtArgs> = {}>(args?: Subset<T, Project$featureFlagsArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sdkSettings<T extends Project$sdkSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sdkSettingsArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    configCategories<T extends Project$configCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$configCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly apiKey: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.devices
   */
  export type Project$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Project.logs
   */
  export type Project$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Project.crashes
   */
  export type Project$crashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    where?: CrashWhereInput
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    cursor?: CrashWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashScalarFieldEnum | CrashScalarFieldEnum[]
  }

  /**
   * Project.apiTraces
   */
  export type Project$apiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    where?: ApiTraceWhereInput
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    cursor?: ApiTraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * Project.apiConfigs
   */
  export type Project$apiConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    where?: ApiConfigWhereInput
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    cursor?: ApiConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * Project.sessions
   */
  export type Project$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Project.notificationSettings
   */
  export type Project$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
  }

  /**
   * Project.apiAlerts
   */
  export type Project$apiAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    where?: ApiAlertWhereInput
    orderBy?: ApiAlertOrderByWithRelationInput | ApiAlertOrderByWithRelationInput[]
    cursor?: ApiAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiAlertScalarFieldEnum | ApiAlertScalarFieldEnum[]
  }

  /**
   * Project.builds
   */
  export type Project$buildsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }

  /**
   * Project.buildMode
   */
  export type Project$buildModeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    where?: BuildModeWhereInput
  }

  /**
   * Project.mockEnvironments
   */
  export type Project$mockEnvironmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    where?: MockEnvironmentWhereInput
    orderBy?: MockEnvironmentOrderByWithRelationInput | MockEnvironmentOrderByWithRelationInput[]
    cursor?: MockEnvironmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockEnvironmentScalarFieldEnum | MockEnvironmentScalarFieldEnum[]
  }

  /**
   * Project.businessConfigs
   */
  export type Project$businessConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    where?: BusinessConfigWhereInput
    orderBy?: BusinessConfigOrderByWithRelationInput | BusinessConfigOrderByWithRelationInput[]
    cursor?: BusinessConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessConfigScalarFieldEnum | BusinessConfigScalarFieldEnum[]
  }

  /**
   * Project.configAlerts
   */
  export type Project$configAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    where?: ConfigAlertWhereInput
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    cursor?: ConfigAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigAlertScalarFieldEnum | ConfigAlertScalarFieldEnum[]
  }

  /**
   * Project.configApprovals
   */
  export type Project$configApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    where?: ConfigApprovalWhereInput
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    cursor?: ConfigApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigApprovalScalarFieldEnum | ConfigApprovalScalarFieldEnum[]
  }

  /**
   * Project.languages
   */
  export type Project$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    cursor?: LanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Project.localizationKeys
   */
  export type Project$localizationKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    where?: LocalizationKeyWhereInput
    orderBy?: LocalizationKeyOrderByWithRelationInput | LocalizationKeyOrderByWithRelationInput[]
    cursor?: LocalizationKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalizationKeyScalarFieldEnum | LocalizationKeyScalarFieldEnum[]
  }

  /**
   * Project.featureFlags
   */
  export type Project$featureFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    where?: FeatureFlagsWhereInput
  }

  /**
   * Project.sdkSettings
   */
  export type Project$sdkSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    where?: SdkSettingsWhereInput
  }

  /**
   * Project.configCategories
   */
  export type Project$configCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    where?: ConfigCategoryWhereInput
    orderBy?: ConfigCategoryOrderByWithRelationInput | ConfigCategoryOrderByWithRelationInput[]
    cursor?: ConfigCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigCategoryScalarFieldEnum | ConfigCategoryScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    platform: string | null
    osVersion: string | null
    appVersion: string | null
    model: string | null
    manufacturer: string | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deviceCode: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    debugModeEnabled: boolean | null
    debugModeEnabledAt: Date | null
    debugModeExpiresAt: Date | null
    debugModeEnabledBy: string | null
    status: string | null
    deletedAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    platform: string | null
    osVersion: string | null
    appVersion: string | null
    model: string | null
    manufacturer: string | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deviceCode: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    debugModeEnabled: boolean | null
    debugModeEnabledAt: Date | null
    debugModeExpiresAt: Date | null
    debugModeEnabledBy: string | null
    status: string | null
    deletedAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    projectId: number
    deviceId: number
    platform: number
    osVersion: number
    appVersion: number
    model: number
    manufacturer: number
    metadata: number
    lastSeenAt: number
    createdAt: number
    updatedAt: number
    deviceCode: number
    userId: number
    userEmail: number
    userName: number
    debugModeEnabled: number
    debugModeEnabledAt: number
    debugModeExpiresAt: number
    debugModeEnabledBy: number
    status: number
    deletedAt: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    platform?: true
    osVersion?: true
    appVersion?: true
    model?: true
    manufacturer?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    deviceCode?: true
    userId?: true
    userEmail?: true
    userName?: true
    debugModeEnabled?: true
    debugModeEnabledAt?: true
    debugModeExpiresAt?: true
    debugModeEnabledBy?: true
    status?: true
    deletedAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    platform?: true
    osVersion?: true
    appVersion?: true
    model?: true
    manufacturer?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    deviceCode?: true
    userId?: true
    userEmail?: true
    userName?: true
    debugModeEnabled?: true
    debugModeEnabledAt?: true
    debugModeExpiresAt?: true
    debugModeEnabledBy?: true
    status?: true
    deletedAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    platform?: true
    osVersion?: true
    appVersion?: true
    model?: true
    manufacturer?: true
    metadata?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    deviceCode?: true
    userId?: true
    userEmail?: true
    userName?: true
    debugModeEnabled?: true
    debugModeEnabledAt?: true
    debugModeExpiresAt?: true
    debugModeEnabledBy?: true
    status?: true
    deletedAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    projectId: string | null
    deviceId: string
    platform: string
    osVersion: string | null
    appVersion: string | null
    model: string | null
    manufacturer: string | null
    metadata: JsonValue | null
    lastSeenAt: Date
    createdAt: Date
    updatedAt: Date
    deviceCode: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    debugModeEnabled: boolean
    debugModeEnabledAt: Date | null
    debugModeExpiresAt: Date | null
    debugModeEnabledBy: string | null
    status: string
    deletedAt: Date | null
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    platform?: boolean
    osVersion?: boolean
    appVersion?: boolean
    model?: boolean
    manufacturer?: boolean
    metadata?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceCode?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    debugModeEnabled?: boolean
    debugModeEnabledAt?: boolean
    debugModeExpiresAt?: boolean
    debugModeEnabledBy?: boolean
    status?: boolean
    deletedAt?: boolean
    project?: boolean | Device$projectArgs<ExtArgs>
    logs?: boolean | Device$logsArgs<ExtArgs>
    crashes?: boolean | Device$crashesArgs<ExtArgs>
    apiTraces?: boolean | Device$apiTracesArgs<ExtArgs>
    sessions?: boolean | Device$sessionsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    platform?: boolean
    osVersion?: boolean
    appVersion?: boolean
    model?: boolean
    manufacturer?: boolean
    metadata?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceCode?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    debugModeEnabled?: boolean
    debugModeEnabledAt?: boolean
    debugModeExpiresAt?: boolean
    debugModeEnabledBy?: boolean
    status?: boolean
    deletedAt?: boolean
    project?: boolean | Device$projectArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    platform?: boolean
    osVersion?: boolean
    appVersion?: boolean
    model?: boolean
    manufacturer?: boolean
    metadata?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceCode?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    debugModeEnabled?: boolean
    debugModeEnabledAt?: boolean
    debugModeExpiresAt?: boolean
    debugModeEnabledBy?: boolean
    status?: boolean
    deletedAt?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Device$projectArgs<ExtArgs>
    logs?: boolean | Device$logsArgs<ExtArgs>
    crashes?: boolean | Device$crashesArgs<ExtArgs>
    apiTraces?: boolean | Device$apiTracesArgs<ExtArgs>
    sessions?: boolean | Device$sessionsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Device$projectArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      logs: Prisma.$LogPayload<ExtArgs>[]
      crashes: Prisma.$CrashPayload<ExtArgs>[]
      apiTraces: Prisma.$ApiTracePayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
      deviceId: string
      platform: string
      osVersion: string | null
      appVersion: string | null
      model: string | null
      manufacturer: string | null
      metadata: Prisma.JsonValue | null
      lastSeenAt: Date
      createdAt: Date
      updatedAt: Date
      deviceCode: string | null
      userId: string | null
      userEmail: string | null
      userName: string | null
      debugModeEnabled: boolean
      debugModeEnabledAt: Date | null
      debugModeExpiresAt: Date | null
      debugModeEnabledBy: string | null
      status: string
      deletedAt: Date | null
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Device$projectArgs<ExtArgs> = {}>(args?: Subset<T, Device$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Device$logsArgs<ExtArgs> = {}>(args?: Subset<T, Device$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    crashes<T extends Device$crashesArgs<ExtArgs> = {}>(args?: Subset<T, Device$crashesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findMany"> | Null>
    apiTraces<T extends Device$apiTracesArgs<ExtArgs> = {}>(args?: Subset<T, Device$apiTracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Device$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Device$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly projectId: FieldRef<"Device", 'String'>
    readonly deviceId: FieldRef<"Device", 'String'>
    readonly platform: FieldRef<"Device", 'String'>
    readonly osVersion: FieldRef<"Device", 'String'>
    readonly appVersion: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly manufacturer: FieldRef<"Device", 'String'>
    readonly metadata: FieldRef<"Device", 'Json'>
    readonly lastSeenAt: FieldRef<"Device", 'DateTime'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly updatedAt: FieldRef<"Device", 'DateTime'>
    readonly deviceCode: FieldRef<"Device", 'String'>
    readonly userId: FieldRef<"Device", 'String'>
    readonly userEmail: FieldRef<"Device", 'String'>
    readonly userName: FieldRef<"Device", 'String'>
    readonly debugModeEnabled: FieldRef<"Device", 'Boolean'>
    readonly debugModeEnabledAt: FieldRef<"Device", 'DateTime'>
    readonly debugModeExpiresAt: FieldRef<"Device", 'DateTime'>
    readonly debugModeEnabledBy: FieldRef<"Device", 'String'>
    readonly status: FieldRef<"Device", 'String'>
    readonly deletedAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }

  /**
   * Device.project
   */
  export type Device$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Device.logs
   */
  export type Device$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Device.crashes
   */
  export type Device$crashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    where?: CrashWhereInput
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    cursor?: CrashWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashScalarFieldEnum | CrashScalarFieldEnum[]
  }

  /**
   * Device.apiTraces
   */
  export type Device$apiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    where?: ApiTraceWhereInput
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    cursor?: ApiTraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * Device.sessions
   */
  export type Device$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    lineNumber: number | null
  }

  export type LogSumAggregateOutputType = {
    lineNumber: number | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionId: string | null
    level: string | null
    message: string | null
    tag: string | null
    fileName: string | null
    lineNumber: number | null
    functionName: string | null
    className: string | null
    screenName: string | null
    threadName: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionId: string | null
    level: string | null
    message: string | null
    tag: string | null
    fileName: string | null
    lineNumber: number | null
    functionName: string | null
    className: string | null
    screenName: string | null
    threadName: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    projectId: number
    deviceId: number
    sessionId: number
    level: number
    message: number
    tag: number
    data: number
    fileName: number
    lineNumber: number
    functionName: number
    className: number
    screenName: number
    threadName: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    lineNumber?: true
  }

  export type LogSumAggregateInputType = {
    lineNumber?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    level?: true
    message?: true
    tag?: true
    fileName?: true
    lineNumber?: true
    functionName?: true
    className?: true
    screenName?: true
    threadName?: true
    timestamp?: true
    createdAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    level?: true
    message?: true
    tag?: true
    fileName?: true
    lineNumber?: true
    functionName?: true
    className?: true
    screenName?: true
    threadName?: true
    timestamp?: true
    createdAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    level?: true
    message?: true
    tag?: true
    data?: true
    fileName?: true
    lineNumber?: true
    functionName?: true
    className?: true
    screenName?: true
    threadName?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    projectId: string
    deviceId: string | null
    sessionId: string | null
    level: string
    message: string
    tag: string | null
    data: JsonValue | null
    fileName: string | null
    lineNumber: number | null
    functionName: string | null
    className: string | null
    screenName: string | null
    threadName: string | null
    timestamp: Date
    createdAt: Date
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    level?: boolean
    message?: boolean
    tag?: boolean
    data?: boolean
    fileName?: boolean
    lineNumber?: boolean
    functionName?: boolean
    className?: boolean
    screenName?: boolean
    threadName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Log$deviceArgs<ExtArgs>
    session?: boolean | Log$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    level?: boolean
    message?: boolean
    tag?: boolean
    data?: boolean
    fileName?: boolean
    lineNumber?: boolean
    functionName?: boolean
    className?: boolean
    screenName?: boolean
    threadName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Log$deviceArgs<ExtArgs>
    session?: boolean | Log$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    level?: boolean
    message?: boolean
    tag?: boolean
    data?: boolean
    fileName?: boolean
    lineNumber?: boolean
    functionName?: boolean
    className?: boolean
    screenName?: boolean
    threadName?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Log$deviceArgs<ExtArgs>
    session?: boolean | Log$sessionArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Log$deviceArgs<ExtArgs>
    session?: boolean | Log$sessionArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
      session: Prisma.$SessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      deviceId: string | null
      sessionId: string | null
      level: string
      message: string
      tag: string | null
      data: Prisma.JsonValue | null
      fileName: string | null
      lineNumber: number | null
      functionName: string | null
      className: string | null
      screenName: string | null
      threadName: string | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends Log$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Log$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends Log$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Log$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly projectId: FieldRef<"Log", 'String'>
    readonly deviceId: FieldRef<"Log", 'String'>
    readonly sessionId: FieldRef<"Log", 'String'>
    readonly level: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly tag: FieldRef<"Log", 'String'>
    readonly data: FieldRef<"Log", 'Json'>
    readonly fileName: FieldRef<"Log", 'String'>
    readonly lineNumber: FieldRef<"Log", 'Int'>
    readonly functionName: FieldRef<"Log", 'String'>
    readonly className: FieldRef<"Log", 'String'>
    readonly screenName: FieldRef<"Log", 'String'>
    readonly threadName: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }

  /**
   * Log.device
   */
  export type Log$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Log.session
   */
  export type Log$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Crash
   */

  export type AggregateCrash = {
    _count: CrashCountAggregateOutputType | null
    _min: CrashMinAggregateOutputType | null
    _max: CrashMaxAggregateOutputType | null
  }

  export type CrashMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    message: string | null
    stackTrace: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type CrashMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    message: string | null
    stackTrace: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type CrashCountAggregateOutputType = {
    id: number
    projectId: number
    deviceId: number
    message: number
    stackTrace: number
    metadata: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type CrashMinAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    message?: true
    stackTrace?: true
    timestamp?: true
    createdAt?: true
  }

  export type CrashMaxAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    message?: true
    stackTrace?: true
    timestamp?: true
    createdAt?: true
  }

  export type CrashCountAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    message?: true
    stackTrace?: true
    metadata?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type CrashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crash to aggregate.
     */
    where?: CrashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crashes to fetch.
     */
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crashes
    **/
    _count?: true | CrashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrashMaxAggregateInputType
  }

  export type GetCrashAggregateType<T extends CrashAggregateArgs> = {
        [P in keyof T & keyof AggregateCrash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrash[P]>
      : GetScalarType<T[P], AggregateCrash[P]>
  }




  export type CrashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashWhereInput
    orderBy?: CrashOrderByWithAggregationInput | CrashOrderByWithAggregationInput[]
    by: CrashScalarFieldEnum[] | CrashScalarFieldEnum
    having?: CrashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrashCountAggregateInputType | true
    _min?: CrashMinAggregateInputType
    _max?: CrashMaxAggregateInputType
  }

  export type CrashGroupByOutputType = {
    id: string
    projectId: string
    deviceId: string | null
    message: string
    stackTrace: string | null
    metadata: JsonValue | null
    timestamp: Date
    createdAt: Date
    _count: CrashCountAggregateOutputType | null
    _min: CrashMinAggregateOutputType | null
    _max: CrashMaxAggregateOutputType | null
  }

  type GetCrashGroupByPayload<T extends CrashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrashGroupByOutputType[P]>
            : GetScalarType<T[P], CrashGroupByOutputType[P]>
        }
      >
    >


  export type CrashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    message?: boolean
    stackTrace?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Crash$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["crash"]>

  export type CrashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    message?: boolean
    stackTrace?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Crash$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["crash"]>

  export type CrashSelectScalar = {
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    message?: boolean
    stackTrace?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type CrashInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Crash$deviceArgs<ExtArgs>
  }
  export type CrashIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Crash$deviceArgs<ExtArgs>
  }

  export type $CrashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crash"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      deviceId: string | null
      message: string
      stackTrace: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["crash"]>
    composites: {}
  }

  type CrashGetPayload<S extends boolean | null | undefined | CrashDefaultArgs> = $Result.GetResult<Prisma.$CrashPayload, S>

  type CrashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrashFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrashCountAggregateInputType | true
    }

  export interface CrashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crash'], meta: { name: 'Crash' } }
    /**
     * Find zero or one Crash that matches the filter.
     * @param {CrashFindUniqueArgs} args - Arguments to find a Crash
     * @example
     * // Get one Crash
     * const crash = await prisma.crash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrashFindUniqueArgs>(args: SelectSubset<T, CrashFindUniqueArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Crash that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrashFindUniqueOrThrowArgs} args - Arguments to find a Crash
     * @example
     * // Get one Crash
     * const crash = await prisma.crash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrashFindUniqueOrThrowArgs>(args: SelectSubset<T, CrashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Crash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashFindFirstArgs} args - Arguments to find a Crash
     * @example
     * // Get one Crash
     * const crash = await prisma.crash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrashFindFirstArgs>(args?: SelectSubset<T, CrashFindFirstArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Crash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashFindFirstOrThrowArgs} args - Arguments to find a Crash
     * @example
     * // Get one Crash
     * const crash = await prisma.crash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrashFindFirstOrThrowArgs>(args?: SelectSubset<T, CrashFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Crashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crashes
     * const crashes = await prisma.crash.findMany()
     * 
     * // Get first 10 Crashes
     * const crashes = await prisma.crash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crashWithIdOnly = await prisma.crash.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrashFindManyArgs>(args?: SelectSubset<T, CrashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Crash.
     * @param {CrashCreateArgs} args - Arguments to create a Crash.
     * @example
     * // Create one Crash
     * const Crash = await prisma.crash.create({
     *   data: {
     *     // ... data to create a Crash
     *   }
     * })
     * 
     */
    create<T extends CrashCreateArgs>(args: SelectSubset<T, CrashCreateArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Crashes.
     * @param {CrashCreateManyArgs} args - Arguments to create many Crashes.
     * @example
     * // Create many Crashes
     * const crash = await prisma.crash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrashCreateManyArgs>(args?: SelectSubset<T, CrashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crashes and returns the data saved in the database.
     * @param {CrashCreateManyAndReturnArgs} args - Arguments to create many Crashes.
     * @example
     * // Create many Crashes
     * const crash = await prisma.crash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crashes and only return the `id`
     * const crashWithIdOnly = await prisma.crash.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrashCreateManyAndReturnArgs>(args?: SelectSubset<T, CrashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Crash.
     * @param {CrashDeleteArgs} args - Arguments to delete one Crash.
     * @example
     * // Delete one Crash
     * const Crash = await prisma.crash.delete({
     *   where: {
     *     // ... filter to delete one Crash
     *   }
     * })
     * 
     */
    delete<T extends CrashDeleteArgs>(args: SelectSubset<T, CrashDeleteArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Crash.
     * @param {CrashUpdateArgs} args - Arguments to update one Crash.
     * @example
     * // Update one Crash
     * const crash = await prisma.crash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrashUpdateArgs>(args: SelectSubset<T, CrashUpdateArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Crashes.
     * @param {CrashDeleteManyArgs} args - Arguments to filter Crashes to delete.
     * @example
     * // Delete a few Crashes
     * const { count } = await prisma.crash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrashDeleteManyArgs>(args?: SelectSubset<T, CrashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crashes
     * const crash = await prisma.crash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrashUpdateManyArgs>(args: SelectSubset<T, CrashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crash.
     * @param {CrashUpsertArgs} args - Arguments to update or create a Crash.
     * @example
     * // Update or create a Crash
     * const crash = await prisma.crash.upsert({
     *   create: {
     *     // ... data to create a Crash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crash we want to update
     *   }
     * })
     */
    upsert<T extends CrashUpsertArgs>(args: SelectSubset<T, CrashUpsertArgs<ExtArgs>>): Prisma__CrashClient<$Result.GetResult<Prisma.$CrashPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Crashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashCountArgs} args - Arguments to filter Crashes to count.
     * @example
     * // Count the number of Crashes
     * const count = await prisma.crash.count({
     *   where: {
     *     // ... the filter for the Crashes we want to count
     *   }
     * })
    **/
    count<T extends CrashCountArgs>(
      args?: Subset<T, CrashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrashAggregateArgs>(args: Subset<T, CrashAggregateArgs>): Prisma.PrismaPromise<GetCrashAggregateType<T>>

    /**
     * Group by Crash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrashGroupByArgs['orderBy'] }
        : { orderBy?: CrashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crash model
   */
  readonly fields: CrashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends Crash$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Crash$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crash model
   */ 
  interface CrashFieldRefs {
    readonly id: FieldRef<"Crash", 'String'>
    readonly projectId: FieldRef<"Crash", 'String'>
    readonly deviceId: FieldRef<"Crash", 'String'>
    readonly message: FieldRef<"Crash", 'String'>
    readonly stackTrace: FieldRef<"Crash", 'String'>
    readonly metadata: FieldRef<"Crash", 'Json'>
    readonly timestamp: FieldRef<"Crash", 'DateTime'>
    readonly createdAt: FieldRef<"Crash", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Crash findUnique
   */
  export type CrashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter, which Crash to fetch.
     */
    where: CrashWhereUniqueInput
  }

  /**
   * Crash findUniqueOrThrow
   */
  export type CrashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter, which Crash to fetch.
     */
    where: CrashWhereUniqueInput
  }

  /**
   * Crash findFirst
   */
  export type CrashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter, which Crash to fetch.
     */
    where?: CrashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crashes to fetch.
     */
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crashes.
     */
    cursor?: CrashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crashes.
     */
    distinct?: CrashScalarFieldEnum | CrashScalarFieldEnum[]
  }

  /**
   * Crash findFirstOrThrow
   */
  export type CrashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter, which Crash to fetch.
     */
    where?: CrashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crashes to fetch.
     */
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crashes.
     */
    cursor?: CrashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crashes.
     */
    distinct?: CrashScalarFieldEnum | CrashScalarFieldEnum[]
  }

  /**
   * Crash findMany
   */
  export type CrashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter, which Crashes to fetch.
     */
    where?: CrashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crashes to fetch.
     */
    orderBy?: CrashOrderByWithRelationInput | CrashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crashes.
     */
    cursor?: CrashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crashes.
     */
    skip?: number
    distinct?: CrashScalarFieldEnum | CrashScalarFieldEnum[]
  }

  /**
   * Crash create
   */
  export type CrashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * The data needed to create a Crash.
     */
    data: XOR<CrashCreateInput, CrashUncheckedCreateInput>
  }

  /**
   * Crash createMany
   */
  export type CrashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crashes.
     */
    data: CrashCreateManyInput | CrashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crash createManyAndReturn
   */
  export type CrashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Crashes.
     */
    data: CrashCreateManyInput | CrashCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Crash update
   */
  export type CrashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * The data needed to update a Crash.
     */
    data: XOR<CrashUpdateInput, CrashUncheckedUpdateInput>
    /**
     * Choose, which Crash to update.
     */
    where: CrashWhereUniqueInput
  }

  /**
   * Crash updateMany
   */
  export type CrashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crashes.
     */
    data: XOR<CrashUpdateManyMutationInput, CrashUncheckedUpdateManyInput>
    /**
     * Filter which Crashes to update
     */
    where?: CrashWhereInput
  }

  /**
   * Crash upsert
   */
  export type CrashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * The filter to search for the Crash to update in case it exists.
     */
    where: CrashWhereUniqueInput
    /**
     * In case the Crash found by the `where` argument doesn't exist, create a new Crash with this data.
     */
    create: XOR<CrashCreateInput, CrashUncheckedCreateInput>
    /**
     * In case the Crash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrashUpdateInput, CrashUncheckedUpdateInput>
  }

  /**
   * Crash delete
   */
  export type CrashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
    /**
     * Filter which Crash to delete.
     */
    where: CrashWhereUniqueInput
  }

  /**
   * Crash deleteMany
   */
  export type CrashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crashes to delete
     */
    where?: CrashWhereInput
  }

  /**
   * Crash.device
   */
  export type Crash$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Crash without action
   */
  export type CrashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crash
     */
    select?: CrashSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashInclude<ExtArgs> | null
  }


  /**
   * Model ApiTrace
   */

  export type AggregateApiTrace = {
    _count: ApiTraceCountAggregateOutputType | null
    _avg: ApiTraceAvgAggregateOutputType | null
    _sum: ApiTraceSumAggregateOutputType | null
    _min: ApiTraceMinAggregateOutputType | null
    _max: ApiTraceMaxAggregateOutputType | null
  }

  export type ApiTraceAvgAggregateOutputType = {
    statusCode: number | null
    duration: number | null
    cost: number | null
  }

  export type ApiTraceSumAggregateOutputType = {
    statusCode: number | null
    duration: number | null
    cost: number | null
  }

  export type ApiTraceMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionId: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    requestBody: string | null
    responseBody: string | null
    duration: number | null
    error: string | null
    screenName: string | null
    networkType: string | null
    country: string | null
    carrier: string | null
    ipAddress: string | null
    userAgent: string | null
    cost: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ApiTraceMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionId: string | null
    url: string | null
    method: string | null
    statusCode: number | null
    requestBody: string | null
    responseBody: string | null
    duration: number | null
    error: string | null
    screenName: string | null
    networkType: string | null
    country: string | null
    carrier: string | null
    ipAddress: string | null
    userAgent: string | null
    cost: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ApiTraceCountAggregateOutputType = {
    id: number
    projectId: number
    deviceId: number
    sessionId: number
    url: number
    method: number
    statusCode: number
    requestHeaders: number
    requestBody: number
    responseHeaders: number
    responseBody: number
    duration: number
    error: number
    screenName: number
    networkType: number
    country: number
    carrier: number
    ipAddress: number
    userAgent: number
    cost: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type ApiTraceAvgAggregateInputType = {
    statusCode?: true
    duration?: true
    cost?: true
  }

  export type ApiTraceSumAggregateInputType = {
    statusCode?: true
    duration?: true
    cost?: true
  }

  export type ApiTraceMinAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    url?: true
    method?: true
    statusCode?: true
    requestBody?: true
    responseBody?: true
    duration?: true
    error?: true
    screenName?: true
    networkType?: true
    country?: true
    carrier?: true
    ipAddress?: true
    userAgent?: true
    cost?: true
    timestamp?: true
    createdAt?: true
  }

  export type ApiTraceMaxAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    url?: true
    method?: true
    statusCode?: true
    requestBody?: true
    responseBody?: true
    duration?: true
    error?: true
    screenName?: true
    networkType?: true
    country?: true
    carrier?: true
    ipAddress?: true
    userAgent?: true
    cost?: true
    timestamp?: true
    createdAt?: true
  }

  export type ApiTraceCountAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionId?: true
    url?: true
    method?: true
    statusCode?: true
    requestHeaders?: true
    requestBody?: true
    responseHeaders?: true
    responseBody?: true
    duration?: true
    error?: true
    screenName?: true
    networkType?: true
    country?: true
    carrier?: true
    ipAddress?: true
    userAgent?: true
    cost?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type ApiTraceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiTrace to aggregate.
     */
    where?: ApiTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTraces to fetch.
     */
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiTraces
    **/
    _count?: true | ApiTraceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiTraceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiTraceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiTraceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiTraceMaxAggregateInputType
  }

  export type GetApiTraceAggregateType<T extends ApiTraceAggregateArgs> = {
        [P in keyof T & keyof AggregateApiTrace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiTrace[P]>
      : GetScalarType<T[P], AggregateApiTrace[P]>
  }




  export type ApiTraceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiTraceWhereInput
    orderBy?: ApiTraceOrderByWithAggregationInput | ApiTraceOrderByWithAggregationInput[]
    by: ApiTraceScalarFieldEnum[] | ApiTraceScalarFieldEnum
    having?: ApiTraceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiTraceCountAggregateInputType | true
    _avg?: ApiTraceAvgAggregateInputType
    _sum?: ApiTraceSumAggregateInputType
    _min?: ApiTraceMinAggregateInputType
    _max?: ApiTraceMaxAggregateInputType
  }

  export type ApiTraceGroupByOutputType = {
    id: string
    projectId: string
    deviceId: string | null
    sessionId: string | null
    url: string
    method: string
    statusCode: number | null
    requestHeaders: JsonValue | null
    requestBody: string | null
    responseHeaders: JsonValue | null
    responseBody: string | null
    duration: number | null
    error: string | null
    screenName: string | null
    networkType: string | null
    country: string | null
    carrier: string | null
    ipAddress: string | null
    userAgent: string | null
    cost: number | null
    timestamp: Date
    createdAt: Date
    _count: ApiTraceCountAggregateOutputType | null
    _avg: ApiTraceAvgAggregateOutputType | null
    _sum: ApiTraceSumAggregateOutputType | null
    _min: ApiTraceMinAggregateOutputType | null
    _max: ApiTraceMaxAggregateOutputType | null
  }

  type GetApiTraceGroupByPayload<T extends ApiTraceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiTraceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiTraceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiTraceGroupByOutputType[P]>
            : GetScalarType<T[P], ApiTraceGroupByOutputType[P]>
        }
      >
    >


  export type ApiTraceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    requestHeaders?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    duration?: boolean
    error?: boolean
    screenName?: boolean
    networkType?: boolean
    country?: boolean
    carrier?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    cost?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | ApiTrace$deviceArgs<ExtArgs>
    session?: boolean | ApiTrace$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["apiTrace"]>

  export type ApiTraceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    requestHeaders?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    duration?: boolean
    error?: boolean
    screenName?: boolean
    networkType?: boolean
    country?: boolean
    carrier?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    cost?: boolean
    timestamp?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | ApiTrace$deviceArgs<ExtArgs>
    session?: boolean | ApiTrace$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["apiTrace"]>

  export type ApiTraceSelectScalar = {
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionId?: boolean
    url?: boolean
    method?: boolean
    statusCode?: boolean
    requestHeaders?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    duration?: boolean
    error?: boolean
    screenName?: boolean
    networkType?: boolean
    country?: boolean
    carrier?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    cost?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type ApiTraceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | ApiTrace$deviceArgs<ExtArgs>
    session?: boolean | ApiTrace$sessionArgs<ExtArgs>
  }
  export type ApiTraceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | ApiTrace$deviceArgs<ExtArgs>
    session?: boolean | ApiTrace$sessionArgs<ExtArgs>
  }

  export type $ApiTracePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiTrace"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
      session: Prisma.$SessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      deviceId: string | null
      sessionId: string | null
      url: string
      method: string
      statusCode: number | null
      requestHeaders: Prisma.JsonValue | null
      requestBody: string | null
      responseHeaders: Prisma.JsonValue | null
      responseBody: string | null
      duration: number | null
      error: string | null
      screenName: string | null
      networkType: string | null
      country: string | null
      carrier: string | null
      ipAddress: string | null
      userAgent: string | null
      cost: number | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["apiTrace"]>
    composites: {}
  }

  type ApiTraceGetPayload<S extends boolean | null | undefined | ApiTraceDefaultArgs> = $Result.GetResult<Prisma.$ApiTracePayload, S>

  type ApiTraceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiTraceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiTraceCountAggregateInputType | true
    }

  export interface ApiTraceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiTrace'], meta: { name: 'ApiTrace' } }
    /**
     * Find zero or one ApiTrace that matches the filter.
     * @param {ApiTraceFindUniqueArgs} args - Arguments to find a ApiTrace
     * @example
     * // Get one ApiTrace
     * const apiTrace = await prisma.apiTrace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiTraceFindUniqueArgs>(args: SelectSubset<T, ApiTraceFindUniqueArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiTrace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiTraceFindUniqueOrThrowArgs} args - Arguments to find a ApiTrace
     * @example
     * // Get one ApiTrace
     * const apiTrace = await prisma.apiTrace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiTraceFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiTraceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiTrace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceFindFirstArgs} args - Arguments to find a ApiTrace
     * @example
     * // Get one ApiTrace
     * const apiTrace = await prisma.apiTrace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiTraceFindFirstArgs>(args?: SelectSubset<T, ApiTraceFindFirstArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiTrace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceFindFirstOrThrowArgs} args - Arguments to find a ApiTrace
     * @example
     * // Get one ApiTrace
     * const apiTrace = await prisma.apiTrace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiTraceFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiTraceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiTraces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiTraces
     * const apiTraces = await prisma.apiTrace.findMany()
     * 
     * // Get first 10 ApiTraces
     * const apiTraces = await prisma.apiTrace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiTraceWithIdOnly = await prisma.apiTrace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiTraceFindManyArgs>(args?: SelectSubset<T, ApiTraceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiTrace.
     * @param {ApiTraceCreateArgs} args - Arguments to create a ApiTrace.
     * @example
     * // Create one ApiTrace
     * const ApiTrace = await prisma.apiTrace.create({
     *   data: {
     *     // ... data to create a ApiTrace
     *   }
     * })
     * 
     */
    create<T extends ApiTraceCreateArgs>(args: SelectSubset<T, ApiTraceCreateArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiTraces.
     * @param {ApiTraceCreateManyArgs} args - Arguments to create many ApiTraces.
     * @example
     * // Create many ApiTraces
     * const apiTrace = await prisma.apiTrace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiTraceCreateManyArgs>(args?: SelectSubset<T, ApiTraceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiTraces and returns the data saved in the database.
     * @param {ApiTraceCreateManyAndReturnArgs} args - Arguments to create many ApiTraces.
     * @example
     * // Create many ApiTraces
     * const apiTrace = await prisma.apiTrace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiTraces and only return the `id`
     * const apiTraceWithIdOnly = await prisma.apiTrace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiTraceCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiTraceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiTrace.
     * @param {ApiTraceDeleteArgs} args - Arguments to delete one ApiTrace.
     * @example
     * // Delete one ApiTrace
     * const ApiTrace = await prisma.apiTrace.delete({
     *   where: {
     *     // ... filter to delete one ApiTrace
     *   }
     * })
     * 
     */
    delete<T extends ApiTraceDeleteArgs>(args: SelectSubset<T, ApiTraceDeleteArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiTrace.
     * @param {ApiTraceUpdateArgs} args - Arguments to update one ApiTrace.
     * @example
     * // Update one ApiTrace
     * const apiTrace = await prisma.apiTrace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiTraceUpdateArgs>(args: SelectSubset<T, ApiTraceUpdateArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiTraces.
     * @param {ApiTraceDeleteManyArgs} args - Arguments to filter ApiTraces to delete.
     * @example
     * // Delete a few ApiTraces
     * const { count } = await prisma.apiTrace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiTraceDeleteManyArgs>(args?: SelectSubset<T, ApiTraceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiTraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiTraces
     * const apiTrace = await prisma.apiTrace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiTraceUpdateManyArgs>(args: SelectSubset<T, ApiTraceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiTrace.
     * @param {ApiTraceUpsertArgs} args - Arguments to update or create a ApiTrace.
     * @example
     * // Update or create a ApiTrace
     * const apiTrace = await prisma.apiTrace.upsert({
     *   create: {
     *     // ... data to create a ApiTrace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiTrace we want to update
     *   }
     * })
     */
    upsert<T extends ApiTraceUpsertArgs>(args: SelectSubset<T, ApiTraceUpsertArgs<ExtArgs>>): Prisma__ApiTraceClient<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiTraces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceCountArgs} args - Arguments to filter ApiTraces to count.
     * @example
     * // Count the number of ApiTraces
     * const count = await prisma.apiTrace.count({
     *   where: {
     *     // ... the filter for the ApiTraces we want to count
     *   }
     * })
    **/
    count<T extends ApiTraceCountArgs>(
      args?: Subset<T, ApiTraceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiTraceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiTrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiTraceAggregateArgs>(args: Subset<T, ApiTraceAggregateArgs>): Prisma.PrismaPromise<GetApiTraceAggregateType<T>>

    /**
     * Group by ApiTrace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiTraceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiTraceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiTraceGroupByArgs['orderBy'] }
        : { orderBy?: ApiTraceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiTraceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiTraceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiTrace model
   */
  readonly fields: ApiTraceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiTrace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiTraceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends ApiTrace$deviceArgs<ExtArgs> = {}>(args?: Subset<T, ApiTrace$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends ApiTrace$sessionArgs<ExtArgs> = {}>(args?: Subset<T, ApiTrace$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiTrace model
   */ 
  interface ApiTraceFieldRefs {
    readonly id: FieldRef<"ApiTrace", 'String'>
    readonly projectId: FieldRef<"ApiTrace", 'String'>
    readonly deviceId: FieldRef<"ApiTrace", 'String'>
    readonly sessionId: FieldRef<"ApiTrace", 'String'>
    readonly url: FieldRef<"ApiTrace", 'String'>
    readonly method: FieldRef<"ApiTrace", 'String'>
    readonly statusCode: FieldRef<"ApiTrace", 'Int'>
    readonly requestHeaders: FieldRef<"ApiTrace", 'Json'>
    readonly requestBody: FieldRef<"ApiTrace", 'String'>
    readonly responseHeaders: FieldRef<"ApiTrace", 'Json'>
    readonly responseBody: FieldRef<"ApiTrace", 'String'>
    readonly duration: FieldRef<"ApiTrace", 'Int'>
    readonly error: FieldRef<"ApiTrace", 'String'>
    readonly screenName: FieldRef<"ApiTrace", 'String'>
    readonly networkType: FieldRef<"ApiTrace", 'String'>
    readonly country: FieldRef<"ApiTrace", 'String'>
    readonly carrier: FieldRef<"ApiTrace", 'String'>
    readonly ipAddress: FieldRef<"ApiTrace", 'String'>
    readonly userAgent: FieldRef<"ApiTrace", 'String'>
    readonly cost: FieldRef<"ApiTrace", 'Float'>
    readonly timestamp: FieldRef<"ApiTrace", 'DateTime'>
    readonly createdAt: FieldRef<"ApiTrace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiTrace findUnique
   */
  export type ApiTraceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter, which ApiTrace to fetch.
     */
    where: ApiTraceWhereUniqueInput
  }

  /**
   * ApiTrace findUniqueOrThrow
   */
  export type ApiTraceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter, which ApiTrace to fetch.
     */
    where: ApiTraceWhereUniqueInput
  }

  /**
   * ApiTrace findFirst
   */
  export type ApiTraceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter, which ApiTrace to fetch.
     */
    where?: ApiTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTraces to fetch.
     */
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiTraces.
     */
    cursor?: ApiTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiTraces.
     */
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * ApiTrace findFirstOrThrow
   */
  export type ApiTraceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter, which ApiTrace to fetch.
     */
    where?: ApiTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTraces to fetch.
     */
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiTraces.
     */
    cursor?: ApiTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTraces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiTraces.
     */
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * ApiTrace findMany
   */
  export type ApiTraceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter, which ApiTraces to fetch.
     */
    where?: ApiTraceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiTraces to fetch.
     */
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiTraces.
     */
    cursor?: ApiTraceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiTraces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiTraces.
     */
    skip?: number
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * ApiTrace create
   */
  export type ApiTraceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiTrace.
     */
    data: XOR<ApiTraceCreateInput, ApiTraceUncheckedCreateInput>
  }

  /**
   * ApiTrace createMany
   */
  export type ApiTraceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiTraces.
     */
    data: ApiTraceCreateManyInput | ApiTraceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiTrace createManyAndReturn
   */
  export type ApiTraceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiTraces.
     */
    data: ApiTraceCreateManyInput | ApiTraceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiTrace update
   */
  export type ApiTraceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiTrace.
     */
    data: XOR<ApiTraceUpdateInput, ApiTraceUncheckedUpdateInput>
    /**
     * Choose, which ApiTrace to update.
     */
    where: ApiTraceWhereUniqueInput
  }

  /**
   * ApiTrace updateMany
   */
  export type ApiTraceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiTraces.
     */
    data: XOR<ApiTraceUpdateManyMutationInput, ApiTraceUncheckedUpdateManyInput>
    /**
     * Filter which ApiTraces to update
     */
    where?: ApiTraceWhereInput
  }

  /**
   * ApiTrace upsert
   */
  export type ApiTraceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiTrace to update in case it exists.
     */
    where: ApiTraceWhereUniqueInput
    /**
     * In case the ApiTrace found by the `where` argument doesn't exist, create a new ApiTrace with this data.
     */
    create: XOR<ApiTraceCreateInput, ApiTraceUncheckedCreateInput>
    /**
     * In case the ApiTrace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiTraceUpdateInput, ApiTraceUncheckedUpdateInput>
  }

  /**
   * ApiTrace delete
   */
  export type ApiTraceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    /**
     * Filter which ApiTrace to delete.
     */
    where: ApiTraceWhereUniqueInput
  }

  /**
   * ApiTrace deleteMany
   */
  export type ApiTraceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiTraces to delete
     */
    where?: ApiTraceWhereInput
  }

  /**
   * ApiTrace.device
   */
  export type ApiTrace$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * ApiTrace.session
   */
  export type ApiTrace$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * ApiTrace without action
   */
  export type ApiTraceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
  }


  /**
   * Model ApiConfig
   */

  export type AggregateApiConfig = {
    _count: ApiConfigCountAggregateOutputType | null
    _avg: ApiConfigAvgAggregateOutputType | null
    _sum: ApiConfigSumAggregateOutputType | null
    _min: ApiConfigMinAggregateOutputType | null
    _max: ApiConfigMaxAggregateOutputType | null
  }

  export type ApiConfigAvgAggregateOutputType = {
    costPerRequest: number | null
  }

  export type ApiConfigSumAggregateOutputType = {
    costPerRequest: number | null
  }

  export type ApiConfigMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    endpoint: string | null
    method: string | null
    name: string | null
    description: string | null
    costPerRequest: number | null
    isEnabled: boolean | null
    enableLogs: boolean | null
    captureRequestBody: boolean | null
    captureResponseBody: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiConfigMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    endpoint: string | null
    method: string | null
    name: string | null
    description: string | null
    costPerRequest: number | null
    isEnabled: boolean | null
    enableLogs: boolean | null
    captureRequestBody: boolean | null
    captureResponseBody: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiConfigCountAggregateOutputType = {
    id: number
    projectId: number
    endpoint: number
    method: number
    name: number
    description: number
    costPerRequest: number
    isEnabled: number
    enableLogs: number
    captureRequestBody: number
    captureResponseBody: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiConfigAvgAggregateInputType = {
    costPerRequest?: true
  }

  export type ApiConfigSumAggregateInputType = {
    costPerRequest?: true
  }

  export type ApiConfigMinAggregateInputType = {
    id?: true
    projectId?: true
    endpoint?: true
    method?: true
    name?: true
    description?: true
    costPerRequest?: true
    isEnabled?: true
    enableLogs?: true
    captureRequestBody?: true
    captureResponseBody?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiConfigMaxAggregateInputType = {
    id?: true
    projectId?: true
    endpoint?: true
    method?: true
    name?: true
    description?: true
    costPerRequest?: true
    isEnabled?: true
    enableLogs?: true
    captureRequestBody?: true
    captureResponseBody?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiConfigCountAggregateInputType = {
    id?: true
    projectId?: true
    endpoint?: true
    method?: true
    name?: true
    description?: true
    costPerRequest?: true
    isEnabled?: true
    enableLogs?: true
    captureRequestBody?: true
    captureResponseBody?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiConfig to aggregate.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiConfigs
    **/
    _count?: true | ApiConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiConfigMaxAggregateInputType
  }

  export type GetApiConfigAggregateType<T extends ApiConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateApiConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiConfig[P]>
      : GetScalarType<T[P], AggregateApiConfig[P]>
  }




  export type ApiConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiConfigWhereInput
    orderBy?: ApiConfigOrderByWithAggregationInput | ApiConfigOrderByWithAggregationInput[]
    by: ApiConfigScalarFieldEnum[] | ApiConfigScalarFieldEnum
    having?: ApiConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiConfigCountAggregateInputType | true
    _avg?: ApiConfigAvgAggregateInputType
    _sum?: ApiConfigSumAggregateInputType
    _min?: ApiConfigMinAggregateInputType
    _max?: ApiConfigMaxAggregateInputType
  }

  export type ApiConfigGroupByOutputType = {
    id: string
    projectId: string
    endpoint: string
    method: string | null
    name: string | null
    description: string | null
    costPerRequest: number
    isEnabled: boolean
    enableLogs: boolean
    captureRequestBody: boolean
    captureResponseBody: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ApiConfigCountAggregateOutputType | null
    _avg: ApiConfigAvgAggregateOutputType | null
    _sum: ApiConfigSumAggregateOutputType | null
    _min: ApiConfigMinAggregateOutputType | null
    _max: ApiConfigMaxAggregateOutputType | null
  }

  type GetApiConfigGroupByPayload<T extends ApiConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ApiConfigGroupByOutputType[P]>
        }
      >
    >


  export type ApiConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    endpoint?: boolean
    method?: boolean
    name?: boolean
    description?: boolean
    costPerRequest?: boolean
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiConfig"]>

  export type ApiConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    endpoint?: boolean
    method?: boolean
    name?: boolean
    description?: boolean
    costPerRequest?: boolean
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiConfig"]>

  export type ApiConfigSelectScalar = {
    id?: boolean
    projectId?: boolean
    endpoint?: boolean
    method?: boolean
    name?: boolean
    description?: boolean
    costPerRequest?: boolean
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ApiConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiConfig"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      endpoint: string
      method: string | null
      name: string | null
      description: string | null
      costPerRequest: number
      isEnabled: boolean
      enableLogs: boolean
      captureRequestBody: boolean
      captureResponseBody: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiConfig"]>
    composites: {}
  }

  type ApiConfigGetPayload<S extends boolean | null | undefined | ApiConfigDefaultArgs> = $Result.GetResult<Prisma.$ApiConfigPayload, S>

  type ApiConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiConfigCountAggregateInputType | true
    }

  export interface ApiConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiConfig'], meta: { name: 'ApiConfig' } }
    /**
     * Find zero or one ApiConfig that matches the filter.
     * @param {ApiConfigFindUniqueArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiConfigFindUniqueArgs>(args: SelectSubset<T, ApiConfigFindUniqueArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiConfigFindUniqueOrThrowArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindFirstArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiConfigFindFirstArgs>(args?: SelectSubset<T, ApiConfigFindFirstArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindFirstOrThrowArgs} args - Arguments to find a ApiConfig
     * @example
     * // Get one ApiConfig
     * const apiConfig = await prisma.apiConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiConfigs
     * const apiConfigs = await prisma.apiConfig.findMany()
     * 
     * // Get first 10 ApiConfigs
     * const apiConfigs = await prisma.apiConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiConfigWithIdOnly = await prisma.apiConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiConfigFindManyArgs>(args?: SelectSubset<T, ApiConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiConfig.
     * @param {ApiConfigCreateArgs} args - Arguments to create a ApiConfig.
     * @example
     * // Create one ApiConfig
     * const ApiConfig = await prisma.apiConfig.create({
     *   data: {
     *     // ... data to create a ApiConfig
     *   }
     * })
     * 
     */
    create<T extends ApiConfigCreateArgs>(args: SelectSubset<T, ApiConfigCreateArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiConfigs.
     * @param {ApiConfigCreateManyArgs} args - Arguments to create many ApiConfigs.
     * @example
     * // Create many ApiConfigs
     * const apiConfig = await prisma.apiConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiConfigCreateManyArgs>(args?: SelectSubset<T, ApiConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiConfigs and returns the data saved in the database.
     * @param {ApiConfigCreateManyAndReturnArgs} args - Arguments to create many ApiConfigs.
     * @example
     * // Create many ApiConfigs
     * const apiConfig = await prisma.apiConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiConfigs and only return the `id`
     * const apiConfigWithIdOnly = await prisma.apiConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiConfig.
     * @param {ApiConfigDeleteArgs} args - Arguments to delete one ApiConfig.
     * @example
     * // Delete one ApiConfig
     * const ApiConfig = await prisma.apiConfig.delete({
     *   where: {
     *     // ... filter to delete one ApiConfig
     *   }
     * })
     * 
     */
    delete<T extends ApiConfigDeleteArgs>(args: SelectSubset<T, ApiConfigDeleteArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiConfig.
     * @param {ApiConfigUpdateArgs} args - Arguments to update one ApiConfig.
     * @example
     * // Update one ApiConfig
     * const apiConfig = await prisma.apiConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiConfigUpdateArgs>(args: SelectSubset<T, ApiConfigUpdateArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiConfigs.
     * @param {ApiConfigDeleteManyArgs} args - Arguments to filter ApiConfigs to delete.
     * @example
     * // Delete a few ApiConfigs
     * const { count } = await prisma.apiConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiConfigDeleteManyArgs>(args?: SelectSubset<T, ApiConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiConfigs
     * const apiConfig = await prisma.apiConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiConfigUpdateManyArgs>(args: SelectSubset<T, ApiConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiConfig.
     * @param {ApiConfigUpsertArgs} args - Arguments to update or create a ApiConfig.
     * @example
     * // Update or create a ApiConfig
     * const apiConfig = await prisma.apiConfig.upsert({
     *   create: {
     *     // ... data to create a ApiConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiConfig we want to update
     *   }
     * })
     */
    upsert<T extends ApiConfigUpsertArgs>(args: SelectSubset<T, ApiConfigUpsertArgs<ExtArgs>>): Prisma__ApiConfigClient<$Result.GetResult<Prisma.$ApiConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigCountArgs} args - Arguments to filter ApiConfigs to count.
     * @example
     * // Count the number of ApiConfigs
     * const count = await prisma.apiConfig.count({
     *   where: {
     *     // ... the filter for the ApiConfigs we want to count
     *   }
     * })
    **/
    count<T extends ApiConfigCountArgs>(
      args?: Subset<T, ApiConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiConfigAggregateArgs>(args: Subset<T, ApiConfigAggregateArgs>): Prisma.PrismaPromise<GetApiConfigAggregateType<T>>

    /**
     * Group by ApiConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiConfigGroupByArgs['orderBy'] }
        : { orderBy?: ApiConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiConfig model
   */
  readonly fields: ApiConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiConfig model
   */ 
  interface ApiConfigFieldRefs {
    readonly id: FieldRef<"ApiConfig", 'String'>
    readonly projectId: FieldRef<"ApiConfig", 'String'>
    readonly endpoint: FieldRef<"ApiConfig", 'String'>
    readonly method: FieldRef<"ApiConfig", 'String'>
    readonly name: FieldRef<"ApiConfig", 'String'>
    readonly description: FieldRef<"ApiConfig", 'String'>
    readonly costPerRequest: FieldRef<"ApiConfig", 'Float'>
    readonly isEnabled: FieldRef<"ApiConfig", 'Boolean'>
    readonly enableLogs: FieldRef<"ApiConfig", 'Boolean'>
    readonly captureRequestBody: FieldRef<"ApiConfig", 'Boolean'>
    readonly captureResponseBody: FieldRef<"ApiConfig", 'Boolean'>
    readonly metadata: FieldRef<"ApiConfig", 'Json'>
    readonly createdAt: FieldRef<"ApiConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiConfig findUnique
   */
  export type ApiConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig findUniqueOrThrow
   */
  export type ApiConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig findFirst
   */
  export type ApiConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiConfigs.
     */
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig findFirstOrThrow
   */
  export type ApiConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfig to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiConfigs.
     */
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig findMany
   */
  export type ApiConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter, which ApiConfigs to fetch.
     */
    where?: ApiConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiConfigs to fetch.
     */
    orderBy?: ApiConfigOrderByWithRelationInput | ApiConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiConfigs.
     */
    cursor?: ApiConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiConfigs.
     */
    skip?: number
    distinct?: ApiConfigScalarFieldEnum | ApiConfigScalarFieldEnum[]
  }

  /**
   * ApiConfig create
   */
  export type ApiConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiConfig.
     */
    data: XOR<ApiConfigCreateInput, ApiConfigUncheckedCreateInput>
  }

  /**
   * ApiConfig createMany
   */
  export type ApiConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiConfigs.
     */
    data: ApiConfigCreateManyInput | ApiConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiConfig createManyAndReturn
   */
  export type ApiConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiConfigs.
     */
    data: ApiConfigCreateManyInput | ApiConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiConfig update
   */
  export type ApiConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiConfig.
     */
    data: XOR<ApiConfigUpdateInput, ApiConfigUncheckedUpdateInput>
    /**
     * Choose, which ApiConfig to update.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig updateMany
   */
  export type ApiConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiConfigs.
     */
    data: XOR<ApiConfigUpdateManyMutationInput, ApiConfigUncheckedUpdateManyInput>
    /**
     * Filter which ApiConfigs to update
     */
    where?: ApiConfigWhereInput
  }

  /**
   * ApiConfig upsert
   */
  export type ApiConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiConfig to update in case it exists.
     */
    where: ApiConfigWhereUniqueInput
    /**
     * In case the ApiConfig found by the `where` argument doesn't exist, create a new ApiConfig with this data.
     */
    create: XOR<ApiConfigCreateInput, ApiConfigUncheckedCreateInput>
    /**
     * In case the ApiConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiConfigUpdateInput, ApiConfigUncheckedUpdateInput>
  }

  /**
   * ApiConfig delete
   */
  export type ApiConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
    /**
     * Filter which ApiConfig to delete.
     */
    where: ApiConfigWhereUniqueInput
  }

  /**
   * ApiConfig deleteMany
   */
  export type ApiConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiConfigs to delete
     */
    where?: ApiConfigWhereInput
  }

  /**
   * ApiConfig without action
   */
  export type ApiConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiConfig
     */
    select?: ApiConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiConfigInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    duration: number | null
    screenCount: number | null
    eventCount: number | null
    errorCount: number | null
  }

  export type SessionSumAggregateOutputType = {
    duration: number | null
    screenCount: number | null
    eventCount: number | null
    errorCount: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionToken: string | null
    startedAt: Date | null
    endedAt: Date | null
    isActive: boolean | null
    appVersion: string | null
    osVersion: string | null
    locale: string | null
    timezone: string | null
    networkType: string | null
    entryScreen: string | null
    exitScreen: string | null
    duration: number | null
    screenCount: number | null
    eventCount: number | null
    errorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    deviceId: string | null
    sessionToken: string | null
    startedAt: Date | null
    endedAt: Date | null
    isActive: boolean | null
    appVersion: string | null
    osVersion: string | null
    locale: string | null
    timezone: string | null
    networkType: string | null
    entryScreen: string | null
    exitScreen: string | null
    duration: number | null
    screenCount: number | null
    eventCount: number | null
    errorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    projectId: number
    deviceId: number
    sessionToken: number
    startedAt: number
    endedAt: number
    isActive: number
    appVersion: number
    osVersion: number
    locale: number
    timezone: number
    networkType: number
    screenFlow: number
    entryScreen: number
    exitScreen: number
    duration: number
    screenCount: number
    eventCount: number
    errorCount: number
    metadata: number
    userProperties: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    duration?: true
    screenCount?: true
    eventCount?: true
    errorCount?: true
  }

  export type SessionSumAggregateInputType = {
    duration?: true
    screenCount?: true
    eventCount?: true
    errorCount?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionToken?: true
    startedAt?: true
    endedAt?: true
    isActive?: true
    appVersion?: true
    osVersion?: true
    locale?: true
    timezone?: true
    networkType?: true
    entryScreen?: true
    exitScreen?: true
    duration?: true
    screenCount?: true
    eventCount?: true
    errorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionToken?: true
    startedAt?: true
    endedAt?: true
    isActive?: true
    appVersion?: true
    osVersion?: true
    locale?: true
    timezone?: true
    networkType?: true
    entryScreen?: true
    exitScreen?: true
    duration?: true
    screenCount?: true
    eventCount?: true
    errorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    projectId?: true
    deviceId?: true
    sessionToken?: true
    startedAt?: true
    endedAt?: true
    isActive?: true
    appVersion?: true
    osVersion?: true
    locale?: true
    timezone?: true
    networkType?: true
    screenFlow?: true
    entryScreen?: true
    exitScreen?: true
    duration?: true
    screenCount?: true
    eventCount?: true
    errorCount?: true
    metadata?: true
    userProperties?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    projectId: string
    deviceId: string | null
    sessionToken: string
    startedAt: Date
    endedAt: Date | null
    isActive: boolean
    appVersion: string | null
    osVersion: string | null
    locale: string | null
    timezone: string | null
    networkType: string | null
    screenFlow: string[]
    entryScreen: string | null
    exitScreen: string | null
    duration: number | null
    screenCount: number
    eventCount: number
    errorCount: number
    metadata: JsonValue | null
    userProperties: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isActive?: boolean
    appVersion?: boolean
    osVersion?: boolean
    locale?: boolean
    timezone?: boolean
    networkType?: boolean
    screenFlow?: boolean
    entryScreen?: boolean
    exitScreen?: boolean
    duration?: boolean
    screenCount?: boolean
    eventCount?: boolean
    errorCount?: boolean
    metadata?: boolean
    userProperties?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Session$deviceArgs<ExtArgs>
    apiTraces?: boolean | Session$apiTracesArgs<ExtArgs>
    logs?: boolean | Session$logsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isActive?: boolean
    appVersion?: boolean
    osVersion?: boolean
    locale?: boolean
    timezone?: boolean
    networkType?: boolean
    screenFlow?: boolean
    entryScreen?: boolean
    exitScreen?: boolean
    duration?: boolean
    screenCount?: boolean
    eventCount?: boolean
    errorCount?: boolean
    metadata?: boolean
    userProperties?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Session$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    projectId?: boolean
    deviceId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isActive?: boolean
    appVersion?: boolean
    osVersion?: boolean
    locale?: boolean
    timezone?: boolean
    networkType?: boolean
    screenFlow?: boolean
    entryScreen?: boolean
    exitScreen?: boolean
    duration?: boolean
    screenCount?: boolean
    eventCount?: boolean
    errorCount?: boolean
    metadata?: boolean
    userProperties?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Session$deviceArgs<ExtArgs>
    apiTraces?: boolean | Session$apiTracesArgs<ExtArgs>
    logs?: boolean | Session$logsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    device?: boolean | Session$deviceArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
      apiTraces: Prisma.$ApiTracePayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      deviceId: string | null
      sessionToken: string
      startedAt: Date
      endedAt: Date | null
      isActive: boolean
      appVersion: string | null
      osVersion: string | null
      locale: string | null
      timezone: string | null
      networkType: string | null
      screenFlow: string[]
      entryScreen: string | null
      exitScreen: string | null
      duration: number | null
      screenCount: number
      eventCount: number
      errorCount: number
      metadata: Prisma.JsonValue | null
      userProperties: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends Session$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Session$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    apiTraces<T extends Session$apiTracesArgs<ExtArgs> = {}>(args?: Subset<T, Session$apiTracesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiTracePayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Session$logsArgs<ExtArgs> = {}>(args?: Subset<T, Session$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly projectId: FieldRef<"Session", 'String'>
    readonly deviceId: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly startedAt: FieldRef<"Session", 'DateTime'>
    readonly endedAt: FieldRef<"Session", 'DateTime'>
    readonly isActive: FieldRef<"Session", 'Boolean'>
    readonly appVersion: FieldRef<"Session", 'String'>
    readonly osVersion: FieldRef<"Session", 'String'>
    readonly locale: FieldRef<"Session", 'String'>
    readonly timezone: FieldRef<"Session", 'String'>
    readonly networkType: FieldRef<"Session", 'String'>
    readonly screenFlow: FieldRef<"Session", 'String[]'>
    readonly entryScreen: FieldRef<"Session", 'String'>
    readonly exitScreen: FieldRef<"Session", 'String'>
    readonly duration: FieldRef<"Session", 'Int'>
    readonly screenCount: FieldRef<"Session", 'Int'>
    readonly eventCount: FieldRef<"Session", 'Int'>
    readonly errorCount: FieldRef<"Session", 'Int'>
    readonly metadata: FieldRef<"Session", 'Json'>
    readonly userProperties: FieldRef<"Session", 'Json'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.device
   */
  export type Session$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Session.apiTraces
   */
  export type Session$apiTracesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiTrace
     */
    select?: ApiTraceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiTraceInclude<ExtArgs> | null
    where?: ApiTraceWhereInput
    orderBy?: ApiTraceOrderByWithRelationInput | ApiTraceOrderByWithRelationInput[]
    cursor?: ApiTraceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiTraceScalarFieldEnum | ApiTraceScalarFieldEnum[]
  }

  /**
   * Session.logs
   */
  export type Session$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    pushToken: string | null
    smsEnabled: boolean | null
    webhookEnabled: boolean | null
    webhookUrl: string | null
    webhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    pushToken: string | null
    smsEnabled: boolean | null
    webhookEnabled: boolean | null
    webhookUrl: string | null
    webhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    projectId: number
    emailEnabled: number
    emailAddresses: number
    pushEnabled: number
    pushToken: number
    smsEnabled: number
    smsNumbers: number
    webhookEnabled: number
    webhookUrl: number
    webhookSecret: number
    webhookHeaders: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    projectId?: true
    emailEnabled?: true
    pushEnabled?: true
    pushToken?: true
    smsEnabled?: true
    webhookEnabled?: true
    webhookUrl?: true
    webhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    projectId?: true
    emailEnabled?: true
    pushEnabled?: true
    pushToken?: true
    smsEnabled?: true
    webhookEnabled?: true
    webhookUrl?: true
    webhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    projectId?: true
    emailEnabled?: true
    emailAddresses?: true
    pushEnabled?: true
    pushToken?: true
    smsEnabled?: true
    smsNumbers?: true
    webhookEnabled?: true
    webhookUrl?: true
    webhookSecret?: true
    webhookHeaders?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    projectId: string
    emailEnabled: boolean
    emailAddresses: string[]
    pushEnabled: boolean
    pushToken: string | null
    smsEnabled: boolean
    smsNumbers: string[]
    webhookEnabled: boolean
    webhookUrl: string | null
    webhookSecret: string | null
    webhookHeaders: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    emailEnabled?: boolean
    emailAddresses?: boolean
    pushEnabled?: boolean
    pushToken?: boolean
    smsEnabled?: boolean
    smsNumbers?: boolean
    webhookEnabled?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    webhookHeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    emailEnabled?: boolean
    emailAddresses?: boolean
    pushEnabled?: boolean
    pushToken?: boolean
    smsEnabled?: boolean
    smsNumbers?: boolean
    webhookEnabled?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    webhookHeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    projectId?: boolean
    emailEnabled?: boolean
    emailAddresses?: boolean
    pushEnabled?: boolean
    pushToken?: boolean
    smsEnabled?: boolean
    smsNumbers?: boolean
    webhookEnabled?: boolean
    webhookUrl?: boolean
    webhookSecret?: boolean
    webhookHeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      emailEnabled: boolean
      emailAddresses: string[]
      pushEnabled: boolean
      pushToken: string | null
      smsEnabled: boolean
      smsNumbers: string[]
      webhookEnabled: boolean
      webhookUrl: string | null
      webhookSecret: string | null
      webhookHeaders: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly projectId: FieldRef<"NotificationSettings", 'String'>
    readonly emailEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly emailAddresses: FieldRef<"NotificationSettings", 'String[]'>
    readonly pushEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly pushToken: FieldRef<"NotificationSettings", 'String'>
    readonly smsEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly smsNumbers: FieldRef<"NotificationSettings", 'String[]'>
    readonly webhookEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly webhookUrl: FieldRef<"NotificationSettings", 'String'>
    readonly webhookSecret: FieldRef<"NotificationSettings", 'String'>
    readonly webhookHeaders: FieldRef<"NotificationSettings", 'Json'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ApiAlert
   */

  export type AggregateApiAlert = {
    _count: ApiAlertCountAggregateOutputType | null
    _avg: ApiAlertAvgAggregateOutputType | null
    _sum: ApiAlertSumAggregateOutputType | null
    _min: ApiAlertMinAggregateOutputType | null
    _max: ApiAlertMaxAggregateOutputType | null
  }

  export type ApiAlertAvgAggregateOutputType = {
    standardErrorCodes: number | null
    customStatusCodes: number | null
    cooldownMinutes: number | null
  }

  export type ApiAlertSumAggregateOutputType = {
    standardErrorCodes: number[]
    customStatusCodes: number[]
    cooldownMinutes: number | null
  }

  export type ApiAlertMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    endpoint: string | null
    method: string | null
    isEnabled: boolean | null
    monitorStandardErrors: boolean | null
    bodyErrorField: string | null
    headerErrorField: string | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifySms: boolean | null
    notifyWebhook: boolean | null
    cooldownMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiAlertMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    endpoint: string | null
    method: string | null
    isEnabled: boolean | null
    monitorStandardErrors: boolean | null
    bodyErrorField: string | null
    headerErrorField: string | null
    notifyEmail: boolean | null
    notifyPush: boolean | null
    notifySms: boolean | null
    notifyWebhook: boolean | null
    cooldownMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiAlertCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    endpoint: number
    method: number
    isEnabled: number
    monitorStandardErrors: number
    standardErrorCodes: number
    customStatusCodes: number
    bodyErrorField: number
    bodyErrorValues: number
    headerErrorField: number
    headerErrorValues: number
    notifyEmail: number
    notifyPush: number
    notifySms: number
    notifyWebhook: number
    cooldownMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiAlertAvgAggregateInputType = {
    standardErrorCodes?: true
    customStatusCodes?: true
    cooldownMinutes?: true
  }

  export type ApiAlertSumAggregateInputType = {
    standardErrorCodes?: true
    customStatusCodes?: true
    cooldownMinutes?: true
  }

  export type ApiAlertMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    endpoint?: true
    method?: true
    isEnabled?: true
    monitorStandardErrors?: true
    bodyErrorField?: true
    headerErrorField?: true
    notifyEmail?: true
    notifyPush?: true
    notifySms?: true
    notifyWebhook?: true
    cooldownMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiAlertMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    endpoint?: true
    method?: true
    isEnabled?: true
    monitorStandardErrors?: true
    bodyErrorField?: true
    headerErrorField?: true
    notifyEmail?: true
    notifyPush?: true
    notifySms?: true
    notifyWebhook?: true
    cooldownMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiAlertCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    endpoint?: true
    method?: true
    isEnabled?: true
    monitorStandardErrors?: true
    standardErrorCodes?: true
    customStatusCodes?: true
    bodyErrorField?: true
    bodyErrorValues?: true
    headerErrorField?: true
    headerErrorValues?: true
    notifyEmail?: true
    notifyPush?: true
    notifySms?: true
    notifyWebhook?: true
    cooldownMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiAlert to aggregate.
     */
    where?: ApiAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiAlerts to fetch.
     */
    orderBy?: ApiAlertOrderByWithRelationInput | ApiAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiAlerts
    **/
    _count?: true | ApiAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiAlertMaxAggregateInputType
  }

  export type GetApiAlertAggregateType<T extends ApiAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateApiAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiAlert[P]>
      : GetScalarType<T[P], AggregateApiAlert[P]>
  }




  export type ApiAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiAlertWhereInput
    orderBy?: ApiAlertOrderByWithAggregationInput | ApiAlertOrderByWithAggregationInput[]
    by: ApiAlertScalarFieldEnum[] | ApiAlertScalarFieldEnum
    having?: ApiAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiAlertCountAggregateInputType | true
    _avg?: ApiAlertAvgAggregateInputType
    _sum?: ApiAlertSumAggregateInputType
    _min?: ApiAlertMinAggregateInputType
    _max?: ApiAlertMaxAggregateInputType
  }

  export type ApiAlertGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    endpoint: string | null
    method: string | null
    isEnabled: boolean
    monitorStandardErrors: boolean
    standardErrorCodes: number[]
    customStatusCodes: number[]
    bodyErrorField: string | null
    bodyErrorValues: string[]
    headerErrorField: string | null
    headerErrorValues: string[]
    notifyEmail: boolean
    notifyPush: boolean
    notifySms: boolean
    notifyWebhook: boolean
    cooldownMinutes: number
    createdAt: Date
    updatedAt: Date
    _count: ApiAlertCountAggregateOutputType | null
    _avg: ApiAlertAvgAggregateOutputType | null
    _sum: ApiAlertSumAggregateOutputType | null
    _min: ApiAlertMinAggregateOutputType | null
    _max: ApiAlertMaxAggregateOutputType | null
  }

  type GetApiAlertGroupByPayload<T extends ApiAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiAlertGroupByOutputType[P]>
            : GetScalarType<T[P], ApiAlertGroupByOutputType[P]>
        }
      >
    >


  export type ApiAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    endpoint?: boolean
    method?: boolean
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: boolean
    customStatusCodes?: boolean
    bodyErrorField?: boolean
    bodyErrorValues?: boolean
    headerErrorField?: boolean
    headerErrorValues?: boolean
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    monitoredErrors?: boolean | ApiAlert$monitoredErrorsArgs<ExtArgs>
    _count?: boolean | ApiAlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiAlert"]>

  export type ApiAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    endpoint?: boolean
    method?: boolean
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: boolean
    customStatusCodes?: boolean
    bodyErrorField?: boolean
    bodyErrorValues?: boolean
    headerErrorField?: boolean
    headerErrorValues?: boolean
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiAlert"]>

  export type ApiAlertSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    endpoint?: boolean
    method?: boolean
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: boolean
    customStatusCodes?: boolean
    bodyErrorField?: boolean
    bodyErrorValues?: boolean
    headerErrorField?: boolean
    headerErrorValues?: boolean
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    monitoredErrors?: boolean | ApiAlert$monitoredErrorsArgs<ExtArgs>
    _count?: boolean | ApiAlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiAlert"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      monitoredErrors: Prisma.$MonitoredErrorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      endpoint: string | null
      method: string | null
      isEnabled: boolean
      monitorStandardErrors: boolean
      standardErrorCodes: number[]
      customStatusCodes: number[]
      bodyErrorField: string | null
      bodyErrorValues: string[]
      headerErrorField: string | null
      headerErrorValues: string[]
      notifyEmail: boolean
      notifyPush: boolean
      notifySms: boolean
      notifyWebhook: boolean
      cooldownMinutes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiAlert"]>
    composites: {}
  }

  type ApiAlertGetPayload<S extends boolean | null | undefined | ApiAlertDefaultArgs> = $Result.GetResult<Prisma.$ApiAlertPayload, S>

  type ApiAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiAlertCountAggregateInputType | true
    }

  export interface ApiAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiAlert'], meta: { name: 'ApiAlert' } }
    /**
     * Find zero or one ApiAlert that matches the filter.
     * @param {ApiAlertFindUniqueArgs} args - Arguments to find a ApiAlert
     * @example
     * // Get one ApiAlert
     * const apiAlert = await prisma.apiAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiAlertFindUniqueArgs>(args: SelectSubset<T, ApiAlertFindUniqueArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiAlertFindUniqueOrThrowArgs} args - Arguments to find a ApiAlert
     * @example
     * // Get one ApiAlert
     * const apiAlert = await prisma.apiAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertFindFirstArgs} args - Arguments to find a ApiAlert
     * @example
     * // Get one ApiAlert
     * const apiAlert = await prisma.apiAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiAlertFindFirstArgs>(args?: SelectSubset<T, ApiAlertFindFirstArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertFindFirstOrThrowArgs} args - Arguments to find a ApiAlert
     * @example
     * // Get one ApiAlert
     * const apiAlert = await prisma.apiAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiAlerts
     * const apiAlerts = await prisma.apiAlert.findMany()
     * 
     * // Get first 10 ApiAlerts
     * const apiAlerts = await prisma.apiAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiAlertWithIdOnly = await prisma.apiAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiAlertFindManyArgs>(args?: SelectSubset<T, ApiAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiAlert.
     * @param {ApiAlertCreateArgs} args - Arguments to create a ApiAlert.
     * @example
     * // Create one ApiAlert
     * const ApiAlert = await prisma.apiAlert.create({
     *   data: {
     *     // ... data to create a ApiAlert
     *   }
     * })
     * 
     */
    create<T extends ApiAlertCreateArgs>(args: SelectSubset<T, ApiAlertCreateArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiAlerts.
     * @param {ApiAlertCreateManyArgs} args - Arguments to create many ApiAlerts.
     * @example
     * // Create many ApiAlerts
     * const apiAlert = await prisma.apiAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiAlertCreateManyArgs>(args?: SelectSubset<T, ApiAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiAlerts and returns the data saved in the database.
     * @param {ApiAlertCreateManyAndReturnArgs} args - Arguments to create many ApiAlerts.
     * @example
     * // Create many ApiAlerts
     * const apiAlert = await prisma.apiAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiAlerts and only return the `id`
     * const apiAlertWithIdOnly = await prisma.apiAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiAlert.
     * @param {ApiAlertDeleteArgs} args - Arguments to delete one ApiAlert.
     * @example
     * // Delete one ApiAlert
     * const ApiAlert = await prisma.apiAlert.delete({
     *   where: {
     *     // ... filter to delete one ApiAlert
     *   }
     * })
     * 
     */
    delete<T extends ApiAlertDeleteArgs>(args: SelectSubset<T, ApiAlertDeleteArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiAlert.
     * @param {ApiAlertUpdateArgs} args - Arguments to update one ApiAlert.
     * @example
     * // Update one ApiAlert
     * const apiAlert = await prisma.apiAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiAlertUpdateArgs>(args: SelectSubset<T, ApiAlertUpdateArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiAlerts.
     * @param {ApiAlertDeleteManyArgs} args - Arguments to filter ApiAlerts to delete.
     * @example
     * // Delete a few ApiAlerts
     * const { count } = await prisma.apiAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiAlertDeleteManyArgs>(args?: SelectSubset<T, ApiAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiAlerts
     * const apiAlert = await prisma.apiAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiAlertUpdateManyArgs>(args: SelectSubset<T, ApiAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiAlert.
     * @param {ApiAlertUpsertArgs} args - Arguments to update or create a ApiAlert.
     * @example
     * // Update or create a ApiAlert
     * const apiAlert = await prisma.apiAlert.upsert({
     *   create: {
     *     // ... data to create a ApiAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiAlert we want to update
     *   }
     * })
     */
    upsert<T extends ApiAlertUpsertArgs>(args: SelectSubset<T, ApiAlertUpsertArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertCountArgs} args - Arguments to filter ApiAlerts to count.
     * @example
     * // Count the number of ApiAlerts
     * const count = await prisma.apiAlert.count({
     *   where: {
     *     // ... the filter for the ApiAlerts we want to count
     *   }
     * })
    **/
    count<T extends ApiAlertCountArgs>(
      args?: Subset<T, ApiAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiAlertAggregateArgs>(args: Subset<T, ApiAlertAggregateArgs>): Prisma.PrismaPromise<GetApiAlertAggregateType<T>>

    /**
     * Group by ApiAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiAlertGroupByArgs['orderBy'] }
        : { orderBy?: ApiAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiAlert model
   */
  readonly fields: ApiAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    monitoredErrors<T extends ApiAlert$monitoredErrorsArgs<ExtArgs> = {}>(args?: Subset<T, ApiAlert$monitoredErrorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiAlert model
   */ 
  interface ApiAlertFieldRefs {
    readonly id: FieldRef<"ApiAlert", 'String'>
    readonly projectId: FieldRef<"ApiAlert", 'String'>
    readonly title: FieldRef<"ApiAlert", 'String'>
    readonly description: FieldRef<"ApiAlert", 'String'>
    readonly endpoint: FieldRef<"ApiAlert", 'String'>
    readonly method: FieldRef<"ApiAlert", 'String'>
    readonly isEnabled: FieldRef<"ApiAlert", 'Boolean'>
    readonly monitorStandardErrors: FieldRef<"ApiAlert", 'Boolean'>
    readonly standardErrorCodes: FieldRef<"ApiAlert", 'Int[]'>
    readonly customStatusCodes: FieldRef<"ApiAlert", 'Int[]'>
    readonly bodyErrorField: FieldRef<"ApiAlert", 'String'>
    readonly bodyErrorValues: FieldRef<"ApiAlert", 'String[]'>
    readonly headerErrorField: FieldRef<"ApiAlert", 'String'>
    readonly headerErrorValues: FieldRef<"ApiAlert", 'String[]'>
    readonly notifyEmail: FieldRef<"ApiAlert", 'Boolean'>
    readonly notifyPush: FieldRef<"ApiAlert", 'Boolean'>
    readonly notifySms: FieldRef<"ApiAlert", 'Boolean'>
    readonly notifyWebhook: FieldRef<"ApiAlert", 'Boolean'>
    readonly cooldownMinutes: FieldRef<"ApiAlert", 'Int'>
    readonly createdAt: FieldRef<"ApiAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiAlert findUnique
   */
  export type ApiAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter, which ApiAlert to fetch.
     */
    where: ApiAlertWhereUniqueInput
  }

  /**
   * ApiAlert findUniqueOrThrow
   */
  export type ApiAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter, which ApiAlert to fetch.
     */
    where: ApiAlertWhereUniqueInput
  }

  /**
   * ApiAlert findFirst
   */
  export type ApiAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter, which ApiAlert to fetch.
     */
    where?: ApiAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiAlerts to fetch.
     */
    orderBy?: ApiAlertOrderByWithRelationInput | ApiAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiAlerts.
     */
    cursor?: ApiAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiAlerts.
     */
    distinct?: ApiAlertScalarFieldEnum | ApiAlertScalarFieldEnum[]
  }

  /**
   * ApiAlert findFirstOrThrow
   */
  export type ApiAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter, which ApiAlert to fetch.
     */
    where?: ApiAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiAlerts to fetch.
     */
    orderBy?: ApiAlertOrderByWithRelationInput | ApiAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiAlerts.
     */
    cursor?: ApiAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiAlerts.
     */
    distinct?: ApiAlertScalarFieldEnum | ApiAlertScalarFieldEnum[]
  }

  /**
   * ApiAlert findMany
   */
  export type ApiAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter, which ApiAlerts to fetch.
     */
    where?: ApiAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiAlerts to fetch.
     */
    orderBy?: ApiAlertOrderByWithRelationInput | ApiAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiAlerts.
     */
    cursor?: ApiAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiAlerts.
     */
    skip?: number
    distinct?: ApiAlertScalarFieldEnum | ApiAlertScalarFieldEnum[]
  }

  /**
   * ApiAlert create
   */
  export type ApiAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiAlert.
     */
    data: XOR<ApiAlertCreateInput, ApiAlertUncheckedCreateInput>
  }

  /**
   * ApiAlert createMany
   */
  export type ApiAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiAlerts.
     */
    data: ApiAlertCreateManyInput | ApiAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiAlert createManyAndReturn
   */
  export type ApiAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiAlerts.
     */
    data: ApiAlertCreateManyInput | ApiAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiAlert update
   */
  export type ApiAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiAlert.
     */
    data: XOR<ApiAlertUpdateInput, ApiAlertUncheckedUpdateInput>
    /**
     * Choose, which ApiAlert to update.
     */
    where: ApiAlertWhereUniqueInput
  }

  /**
   * ApiAlert updateMany
   */
  export type ApiAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiAlerts.
     */
    data: XOR<ApiAlertUpdateManyMutationInput, ApiAlertUncheckedUpdateManyInput>
    /**
     * Filter which ApiAlerts to update
     */
    where?: ApiAlertWhereInput
  }

  /**
   * ApiAlert upsert
   */
  export type ApiAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiAlert to update in case it exists.
     */
    where: ApiAlertWhereUniqueInput
    /**
     * In case the ApiAlert found by the `where` argument doesn't exist, create a new ApiAlert with this data.
     */
    create: XOR<ApiAlertCreateInput, ApiAlertUncheckedCreateInput>
    /**
     * In case the ApiAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiAlertUpdateInput, ApiAlertUncheckedUpdateInput>
  }

  /**
   * ApiAlert delete
   */
  export type ApiAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
    /**
     * Filter which ApiAlert to delete.
     */
    where: ApiAlertWhereUniqueInput
  }

  /**
   * ApiAlert deleteMany
   */
  export type ApiAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiAlerts to delete
     */
    where?: ApiAlertWhereInput
  }

  /**
   * ApiAlert.monitoredErrors
   */
  export type ApiAlert$monitoredErrorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    where?: MonitoredErrorWhereInput
    orderBy?: MonitoredErrorOrderByWithRelationInput | MonitoredErrorOrderByWithRelationInput[]
    cursor?: MonitoredErrorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonitoredErrorScalarFieldEnum | MonitoredErrorScalarFieldEnum[]
  }

  /**
   * ApiAlert without action
   */
  export type ApiAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiAlert
     */
    select?: ApiAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiAlertInclude<ExtArgs> | null
  }


  /**
   * Model MonitoredError
   */

  export type AggregateMonitoredError = {
    _count: MonitoredErrorCountAggregateOutputType | null
    _avg: MonitoredErrorAvgAggregateOutputType | null
    _sum: MonitoredErrorSumAggregateOutputType | null
    _min: MonitoredErrorMinAggregateOutputType | null
    _max: MonitoredErrorMaxAggregateOutputType | null
  }

  export type MonitoredErrorAvgAggregateOutputType = {
    statusCode: number | null
    occurrenceCount: number | null
    notificationCount: number | null
  }

  export type MonitoredErrorSumAggregateOutputType = {
    statusCode: number | null
    occurrenceCount: number | null
    notificationCount: number | null
  }

  export type MonitoredErrorMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    projectId: string | null
    errorType: string | null
    errorCode: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    requestBody: string | null
    responseBody: string | null
    firstOccurrence: Date | null
    lastOccurrence: Date | null
    occurrenceCount: number | null
    lastTraceId: string | null
    lastNotifiedAt: Date | null
    notificationCount: number | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitoredErrorMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    projectId: string | null
    errorType: string | null
    errorCode: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    requestBody: string | null
    responseBody: string | null
    firstOccurrence: Date | null
    lastOccurrence: Date | null
    occurrenceCount: number | null
    lastTraceId: string | null
    lastNotifiedAt: Date | null
    notificationCount: number | null
    isResolved: boolean | null
    resolvedAt: Date | null
    resolvedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonitoredErrorCountAggregateOutputType = {
    id: number
    alertId: number
    projectId: number
    errorType: number
    errorCode: number
    endpoint: number
    method: number
    statusCode: number
    requestBody: number
    responseBody: number
    firstOccurrence: number
    lastOccurrence: number
    occurrenceCount: number
    affectedDevices: number
    affectedSessions: number
    lastTraceId: number
    lastNotifiedAt: number
    notificationCount: number
    isResolved: number
    resolvedAt: number
    resolvedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonitoredErrorAvgAggregateInputType = {
    statusCode?: true
    occurrenceCount?: true
    notificationCount?: true
  }

  export type MonitoredErrorSumAggregateInputType = {
    statusCode?: true
    occurrenceCount?: true
    notificationCount?: true
  }

  export type MonitoredErrorMinAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    errorType?: true
    errorCode?: true
    endpoint?: true
    method?: true
    statusCode?: true
    requestBody?: true
    responseBody?: true
    firstOccurrence?: true
    lastOccurrence?: true
    occurrenceCount?: true
    lastTraceId?: true
    lastNotifiedAt?: true
    notificationCount?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitoredErrorMaxAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    errorType?: true
    errorCode?: true
    endpoint?: true
    method?: true
    statusCode?: true
    requestBody?: true
    responseBody?: true
    firstOccurrence?: true
    lastOccurrence?: true
    occurrenceCount?: true
    lastTraceId?: true
    lastNotifiedAt?: true
    notificationCount?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonitoredErrorCountAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    errorType?: true
    errorCode?: true
    endpoint?: true
    method?: true
    statusCode?: true
    requestBody?: true
    responseBody?: true
    firstOccurrence?: true
    lastOccurrence?: true
    occurrenceCount?: true
    affectedDevices?: true
    affectedSessions?: true
    lastTraceId?: true
    lastNotifiedAt?: true
    notificationCount?: true
    isResolved?: true
    resolvedAt?: true
    resolvedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonitoredErrorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoredError to aggregate.
     */
    where?: MonitoredErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredErrors to fetch.
     */
    orderBy?: MonitoredErrorOrderByWithRelationInput | MonitoredErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonitoredErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonitoredErrors
    **/
    _count?: true | MonitoredErrorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonitoredErrorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonitoredErrorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonitoredErrorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonitoredErrorMaxAggregateInputType
  }

  export type GetMonitoredErrorAggregateType<T extends MonitoredErrorAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitoredError]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitoredError[P]>
      : GetScalarType<T[P], AggregateMonitoredError[P]>
  }




  export type MonitoredErrorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonitoredErrorWhereInput
    orderBy?: MonitoredErrorOrderByWithAggregationInput | MonitoredErrorOrderByWithAggregationInput[]
    by: MonitoredErrorScalarFieldEnum[] | MonitoredErrorScalarFieldEnum
    having?: MonitoredErrorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonitoredErrorCountAggregateInputType | true
    _avg?: MonitoredErrorAvgAggregateInputType
    _sum?: MonitoredErrorSumAggregateInputType
    _min?: MonitoredErrorMinAggregateInputType
    _max?: MonitoredErrorMaxAggregateInputType
  }

  export type MonitoredErrorGroupByOutputType = {
    id: string
    alertId: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode: number | null
    requestBody: string | null
    responseBody: string | null
    firstOccurrence: Date
    lastOccurrence: Date
    occurrenceCount: number
    affectedDevices: string[]
    affectedSessions: string[]
    lastTraceId: string | null
    lastNotifiedAt: Date | null
    notificationCount: number
    isResolved: boolean
    resolvedAt: Date | null
    resolvedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: MonitoredErrorCountAggregateOutputType | null
    _avg: MonitoredErrorAvgAggregateOutputType | null
    _sum: MonitoredErrorSumAggregateOutputType | null
    _min: MonitoredErrorMinAggregateOutputType | null
    _max: MonitoredErrorMaxAggregateOutputType | null
  }

  type GetMonitoredErrorGroupByPayload<T extends MonitoredErrorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonitoredErrorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonitoredErrorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonitoredErrorGroupByOutputType[P]>
            : GetScalarType<T[P], MonitoredErrorGroupByOutputType[P]>
        }
      >
    >


  export type MonitoredErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    errorType?: boolean
    errorCode?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    requestBody?: boolean
    responseBody?: boolean
    firstOccurrence?: boolean
    lastOccurrence?: boolean
    occurrenceCount?: boolean
    affectedDevices?: boolean
    affectedSessions?: boolean
    lastTraceId?: boolean
    lastNotifiedAt?: boolean
    notificationCount?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | ApiAlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitoredError"]>

  export type MonitoredErrorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    errorType?: boolean
    errorCode?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    requestBody?: boolean
    responseBody?: boolean
    firstOccurrence?: boolean
    lastOccurrence?: boolean
    occurrenceCount?: boolean
    affectedDevices?: boolean
    affectedSessions?: boolean
    lastTraceId?: boolean
    lastNotifiedAt?: boolean
    notificationCount?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alert?: boolean | ApiAlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitoredError"]>

  export type MonitoredErrorSelectScalar = {
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    errorType?: boolean
    errorCode?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    requestBody?: boolean
    responseBody?: boolean
    firstOccurrence?: boolean
    lastOccurrence?: boolean
    occurrenceCount?: boolean
    affectedDevices?: boolean
    affectedSessions?: boolean
    lastTraceId?: boolean
    lastNotifiedAt?: boolean
    notificationCount?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonitoredErrorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | ApiAlertDefaultArgs<ExtArgs>
  }
  export type MonitoredErrorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | ApiAlertDefaultArgs<ExtArgs>
  }

  export type $MonitoredErrorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonitoredError"
    objects: {
      alert: Prisma.$ApiAlertPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string
      projectId: string
      errorType: string
      errorCode: string
      endpoint: string
      method: string
      statusCode: number | null
      requestBody: string | null
      responseBody: string | null
      firstOccurrence: Date
      lastOccurrence: Date
      occurrenceCount: number
      affectedDevices: string[]
      affectedSessions: string[]
      lastTraceId: string | null
      lastNotifiedAt: Date | null
      notificationCount: number
      isResolved: boolean
      resolvedAt: Date | null
      resolvedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monitoredError"]>
    composites: {}
  }

  type MonitoredErrorGetPayload<S extends boolean | null | undefined | MonitoredErrorDefaultArgs> = $Result.GetResult<Prisma.$MonitoredErrorPayload, S>

  type MonitoredErrorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonitoredErrorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonitoredErrorCountAggregateInputType | true
    }

  export interface MonitoredErrorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonitoredError'], meta: { name: 'MonitoredError' } }
    /**
     * Find zero or one MonitoredError that matches the filter.
     * @param {MonitoredErrorFindUniqueArgs} args - Arguments to find a MonitoredError
     * @example
     * // Get one MonitoredError
     * const monitoredError = await prisma.monitoredError.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonitoredErrorFindUniqueArgs>(args: SelectSubset<T, MonitoredErrorFindUniqueArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonitoredError that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonitoredErrorFindUniqueOrThrowArgs} args - Arguments to find a MonitoredError
     * @example
     * // Get one MonitoredError
     * const monitoredError = await prisma.monitoredError.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonitoredErrorFindUniqueOrThrowArgs>(args: SelectSubset<T, MonitoredErrorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonitoredError that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorFindFirstArgs} args - Arguments to find a MonitoredError
     * @example
     * // Get one MonitoredError
     * const monitoredError = await prisma.monitoredError.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonitoredErrorFindFirstArgs>(args?: SelectSubset<T, MonitoredErrorFindFirstArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonitoredError that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorFindFirstOrThrowArgs} args - Arguments to find a MonitoredError
     * @example
     * // Get one MonitoredError
     * const monitoredError = await prisma.monitoredError.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonitoredErrorFindFirstOrThrowArgs>(args?: SelectSubset<T, MonitoredErrorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonitoredErrors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonitoredErrors
     * const monitoredErrors = await prisma.monitoredError.findMany()
     * 
     * // Get first 10 MonitoredErrors
     * const monitoredErrors = await prisma.monitoredError.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitoredErrorWithIdOnly = await prisma.monitoredError.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonitoredErrorFindManyArgs>(args?: SelectSubset<T, MonitoredErrorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonitoredError.
     * @param {MonitoredErrorCreateArgs} args - Arguments to create a MonitoredError.
     * @example
     * // Create one MonitoredError
     * const MonitoredError = await prisma.monitoredError.create({
     *   data: {
     *     // ... data to create a MonitoredError
     *   }
     * })
     * 
     */
    create<T extends MonitoredErrorCreateArgs>(args: SelectSubset<T, MonitoredErrorCreateArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonitoredErrors.
     * @param {MonitoredErrorCreateManyArgs} args - Arguments to create many MonitoredErrors.
     * @example
     * // Create many MonitoredErrors
     * const monitoredError = await prisma.monitoredError.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonitoredErrorCreateManyArgs>(args?: SelectSubset<T, MonitoredErrorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonitoredErrors and returns the data saved in the database.
     * @param {MonitoredErrorCreateManyAndReturnArgs} args - Arguments to create many MonitoredErrors.
     * @example
     * // Create many MonitoredErrors
     * const monitoredError = await prisma.monitoredError.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonitoredErrors and only return the `id`
     * const monitoredErrorWithIdOnly = await prisma.monitoredError.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonitoredErrorCreateManyAndReturnArgs>(args?: SelectSubset<T, MonitoredErrorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonitoredError.
     * @param {MonitoredErrorDeleteArgs} args - Arguments to delete one MonitoredError.
     * @example
     * // Delete one MonitoredError
     * const MonitoredError = await prisma.monitoredError.delete({
     *   where: {
     *     // ... filter to delete one MonitoredError
     *   }
     * })
     * 
     */
    delete<T extends MonitoredErrorDeleteArgs>(args: SelectSubset<T, MonitoredErrorDeleteArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonitoredError.
     * @param {MonitoredErrorUpdateArgs} args - Arguments to update one MonitoredError.
     * @example
     * // Update one MonitoredError
     * const monitoredError = await prisma.monitoredError.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonitoredErrorUpdateArgs>(args: SelectSubset<T, MonitoredErrorUpdateArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonitoredErrors.
     * @param {MonitoredErrorDeleteManyArgs} args - Arguments to filter MonitoredErrors to delete.
     * @example
     * // Delete a few MonitoredErrors
     * const { count } = await prisma.monitoredError.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonitoredErrorDeleteManyArgs>(args?: SelectSubset<T, MonitoredErrorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonitoredErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonitoredErrors
     * const monitoredError = await prisma.monitoredError.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonitoredErrorUpdateManyArgs>(args: SelectSubset<T, MonitoredErrorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonitoredError.
     * @param {MonitoredErrorUpsertArgs} args - Arguments to update or create a MonitoredError.
     * @example
     * // Update or create a MonitoredError
     * const monitoredError = await prisma.monitoredError.upsert({
     *   create: {
     *     // ... data to create a MonitoredError
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonitoredError we want to update
     *   }
     * })
     */
    upsert<T extends MonitoredErrorUpsertArgs>(args: SelectSubset<T, MonitoredErrorUpsertArgs<ExtArgs>>): Prisma__MonitoredErrorClient<$Result.GetResult<Prisma.$MonitoredErrorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonitoredErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorCountArgs} args - Arguments to filter MonitoredErrors to count.
     * @example
     * // Count the number of MonitoredErrors
     * const count = await prisma.monitoredError.count({
     *   where: {
     *     // ... the filter for the MonitoredErrors we want to count
     *   }
     * })
    **/
    count<T extends MonitoredErrorCountArgs>(
      args?: Subset<T, MonitoredErrorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonitoredErrorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonitoredError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonitoredErrorAggregateArgs>(args: Subset<T, MonitoredErrorAggregateArgs>): Prisma.PrismaPromise<GetMonitoredErrorAggregateType<T>>

    /**
     * Group by MonitoredError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonitoredErrorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonitoredErrorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonitoredErrorGroupByArgs['orderBy'] }
        : { orderBy?: MonitoredErrorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonitoredErrorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitoredErrorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonitoredError model
   */
  readonly fields: MonitoredErrorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonitoredError.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonitoredErrorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends ApiAlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiAlertDefaultArgs<ExtArgs>>): Prisma__ApiAlertClient<$Result.GetResult<Prisma.$ApiAlertPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonitoredError model
   */ 
  interface MonitoredErrorFieldRefs {
    readonly id: FieldRef<"MonitoredError", 'String'>
    readonly alertId: FieldRef<"MonitoredError", 'String'>
    readonly projectId: FieldRef<"MonitoredError", 'String'>
    readonly errorType: FieldRef<"MonitoredError", 'String'>
    readonly errorCode: FieldRef<"MonitoredError", 'String'>
    readonly endpoint: FieldRef<"MonitoredError", 'String'>
    readonly method: FieldRef<"MonitoredError", 'String'>
    readonly statusCode: FieldRef<"MonitoredError", 'Int'>
    readonly requestBody: FieldRef<"MonitoredError", 'String'>
    readonly responseBody: FieldRef<"MonitoredError", 'String'>
    readonly firstOccurrence: FieldRef<"MonitoredError", 'DateTime'>
    readonly lastOccurrence: FieldRef<"MonitoredError", 'DateTime'>
    readonly occurrenceCount: FieldRef<"MonitoredError", 'Int'>
    readonly affectedDevices: FieldRef<"MonitoredError", 'String[]'>
    readonly affectedSessions: FieldRef<"MonitoredError", 'String[]'>
    readonly lastTraceId: FieldRef<"MonitoredError", 'String'>
    readonly lastNotifiedAt: FieldRef<"MonitoredError", 'DateTime'>
    readonly notificationCount: FieldRef<"MonitoredError", 'Int'>
    readonly isResolved: FieldRef<"MonitoredError", 'Boolean'>
    readonly resolvedAt: FieldRef<"MonitoredError", 'DateTime'>
    readonly resolvedBy: FieldRef<"MonitoredError", 'String'>
    readonly notes: FieldRef<"MonitoredError", 'String'>
    readonly createdAt: FieldRef<"MonitoredError", 'DateTime'>
    readonly updatedAt: FieldRef<"MonitoredError", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonitoredError findUnique
   */
  export type MonitoredErrorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredError to fetch.
     */
    where: MonitoredErrorWhereUniqueInput
  }

  /**
   * MonitoredError findUniqueOrThrow
   */
  export type MonitoredErrorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredError to fetch.
     */
    where: MonitoredErrorWhereUniqueInput
  }

  /**
   * MonitoredError findFirst
   */
  export type MonitoredErrorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredError to fetch.
     */
    where?: MonitoredErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredErrors to fetch.
     */
    orderBy?: MonitoredErrorOrderByWithRelationInput | MonitoredErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoredErrors.
     */
    cursor?: MonitoredErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoredErrors.
     */
    distinct?: MonitoredErrorScalarFieldEnum | MonitoredErrorScalarFieldEnum[]
  }

  /**
   * MonitoredError findFirstOrThrow
   */
  export type MonitoredErrorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredError to fetch.
     */
    where?: MonitoredErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredErrors to fetch.
     */
    orderBy?: MonitoredErrorOrderByWithRelationInput | MonitoredErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonitoredErrors.
     */
    cursor?: MonitoredErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonitoredErrors.
     */
    distinct?: MonitoredErrorScalarFieldEnum | MonitoredErrorScalarFieldEnum[]
  }

  /**
   * MonitoredError findMany
   */
  export type MonitoredErrorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter, which MonitoredErrors to fetch.
     */
    where?: MonitoredErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonitoredErrors to fetch.
     */
    orderBy?: MonitoredErrorOrderByWithRelationInput | MonitoredErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonitoredErrors.
     */
    cursor?: MonitoredErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonitoredErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonitoredErrors.
     */
    skip?: number
    distinct?: MonitoredErrorScalarFieldEnum | MonitoredErrorScalarFieldEnum[]
  }

  /**
   * MonitoredError create
   */
  export type MonitoredErrorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * The data needed to create a MonitoredError.
     */
    data: XOR<MonitoredErrorCreateInput, MonitoredErrorUncheckedCreateInput>
  }

  /**
   * MonitoredError createMany
   */
  export type MonitoredErrorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonitoredErrors.
     */
    data: MonitoredErrorCreateManyInput | MonitoredErrorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonitoredError createManyAndReturn
   */
  export type MonitoredErrorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonitoredErrors.
     */
    data: MonitoredErrorCreateManyInput | MonitoredErrorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonitoredError update
   */
  export type MonitoredErrorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * The data needed to update a MonitoredError.
     */
    data: XOR<MonitoredErrorUpdateInput, MonitoredErrorUncheckedUpdateInput>
    /**
     * Choose, which MonitoredError to update.
     */
    where: MonitoredErrorWhereUniqueInput
  }

  /**
   * MonitoredError updateMany
   */
  export type MonitoredErrorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonitoredErrors.
     */
    data: XOR<MonitoredErrorUpdateManyMutationInput, MonitoredErrorUncheckedUpdateManyInput>
    /**
     * Filter which MonitoredErrors to update
     */
    where?: MonitoredErrorWhereInput
  }

  /**
   * MonitoredError upsert
   */
  export type MonitoredErrorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * The filter to search for the MonitoredError to update in case it exists.
     */
    where: MonitoredErrorWhereUniqueInput
    /**
     * In case the MonitoredError found by the `where` argument doesn't exist, create a new MonitoredError with this data.
     */
    create: XOR<MonitoredErrorCreateInput, MonitoredErrorUncheckedCreateInput>
    /**
     * In case the MonitoredError was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonitoredErrorUpdateInput, MonitoredErrorUncheckedUpdateInput>
  }

  /**
   * MonitoredError delete
   */
  export type MonitoredErrorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
    /**
     * Filter which MonitoredError to delete.
     */
    where: MonitoredErrorWhereUniqueInput
  }

  /**
   * MonitoredError deleteMany
   */
  export type MonitoredErrorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonitoredErrors to delete
     */
    where?: MonitoredErrorWhereInput
  }

  /**
   * MonitoredError without action
   */
  export type MonitoredErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonitoredError
     */
    select?: MonitoredErrorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonitoredErrorInclude<ExtArgs> | null
  }


  /**
   * Model BusinessConfig
   */

  export type AggregateBusinessConfig = {
    _count: BusinessConfigCountAggregateOutputType | null
    _avg: BusinessConfigAvgAggregateOutputType | null
    _sum: BusinessConfigSumAggregateOutputType | null
    _min: BusinessConfigMinAggregateOutputType | null
    _max: BusinessConfigMaxAggregateOutputType | null
  }

  export type BusinessConfigAvgAggregateOutputType = {
    integerValue: number | null
    decimalValue: number | null
    version: number | null
  }

  export type BusinessConfigSumAggregateOutputType = {
    integerValue: number | null
    decimalValue: number | null
    version: number | null
  }

  export type BusinessConfigMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    key: string | null
    label: string | null
    description: string | null
    valueType: string | null
    stringValue: string | null
    integerValue: number | null
    booleanValue: boolean | null
    decimalValue: number | null
    imageUrl: string | null
    category: string | null
    isEnabled: boolean | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessConfigMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    key: string | null
    label: string | null
    description: string | null
    valueType: string | null
    stringValue: string | null
    integerValue: number | null
    booleanValue: boolean | null
    decimalValue: number | null
    imageUrl: string | null
    category: string | null
    isEnabled: boolean | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessConfigCountAggregateOutputType = {
    id: number
    projectId: number
    key: number
    label: number
    description: number
    valueType: number
    stringValue: number
    integerValue: number
    booleanValue: number
    decimalValue: number
    jsonValue: number
    imageUrl: number
    category: number
    isEnabled: number
    version: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessConfigAvgAggregateInputType = {
    integerValue?: true
    decimalValue?: true
    version?: true
  }

  export type BusinessConfigSumAggregateInputType = {
    integerValue?: true
    decimalValue?: true
    version?: true
  }

  export type BusinessConfigMinAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    label?: true
    description?: true
    valueType?: true
    stringValue?: true
    integerValue?: true
    booleanValue?: true
    decimalValue?: true
    imageUrl?: true
    category?: true
    isEnabled?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessConfigMaxAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    label?: true
    description?: true
    valueType?: true
    stringValue?: true
    integerValue?: true
    booleanValue?: true
    decimalValue?: true
    imageUrl?: true
    category?: true
    isEnabled?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessConfigCountAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    label?: true
    description?: true
    valueType?: true
    stringValue?: true
    integerValue?: true
    booleanValue?: true
    decimalValue?: true
    jsonValue?: true
    imageUrl?: true
    category?: true
    isEnabled?: true
    version?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessConfig to aggregate.
     */
    where?: BusinessConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessConfigs to fetch.
     */
    orderBy?: BusinessConfigOrderByWithRelationInput | BusinessConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessConfigs
    **/
    _count?: true | BusinessConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessConfigMaxAggregateInputType
  }

  export type GetBusinessConfigAggregateType<T extends BusinessConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessConfig[P]>
      : GetScalarType<T[P], AggregateBusinessConfig[P]>
  }




  export type BusinessConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessConfigWhereInput
    orderBy?: BusinessConfigOrderByWithAggregationInput | BusinessConfigOrderByWithAggregationInput[]
    by: BusinessConfigScalarFieldEnum[] | BusinessConfigScalarFieldEnum
    having?: BusinessConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessConfigCountAggregateInputType | true
    _avg?: BusinessConfigAvgAggregateInputType
    _sum?: BusinessConfigSumAggregateInputType
    _min?: BusinessConfigMinAggregateInputType
    _max?: BusinessConfigMaxAggregateInputType
  }

  export type BusinessConfigGroupByOutputType = {
    id: string
    projectId: string
    key: string
    label: string | null
    description: string | null
    valueType: string
    stringValue: string | null
    integerValue: number | null
    booleanValue: boolean | null
    decimalValue: number | null
    jsonValue: JsonValue | null
    imageUrl: string | null
    category: string | null
    isEnabled: boolean
    version: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessConfigCountAggregateOutputType | null
    _avg: BusinessConfigAvgAggregateOutputType | null
    _sum: BusinessConfigSumAggregateOutputType | null
    _min: BusinessConfigMinAggregateOutputType | null
    _max: BusinessConfigMaxAggregateOutputType | null
  }

  type GetBusinessConfigGroupByPayload<T extends BusinessConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessConfigGroupByOutputType[P]>
        }
      >
    >


  export type BusinessConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    key?: boolean
    label?: boolean
    description?: boolean
    valueType?: boolean
    stringValue?: boolean
    integerValue?: boolean
    booleanValue?: boolean
    decimalValue?: boolean
    jsonValue?: boolean
    imageUrl?: boolean
    category?: boolean
    isEnabled?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    alerts?: boolean | BusinessConfig$alertsArgs<ExtArgs>
    approvals?: boolean | BusinessConfig$approvalsArgs<ExtArgs>
    _count?: boolean | BusinessConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessConfig"]>

  export type BusinessConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    key?: boolean
    label?: boolean
    description?: boolean
    valueType?: boolean
    stringValue?: boolean
    integerValue?: boolean
    booleanValue?: boolean
    decimalValue?: boolean
    jsonValue?: boolean
    imageUrl?: boolean
    category?: boolean
    isEnabled?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessConfig"]>

  export type BusinessConfigSelectScalar = {
    id?: boolean
    projectId?: boolean
    key?: boolean
    label?: boolean
    description?: boolean
    valueType?: boolean
    stringValue?: boolean
    integerValue?: boolean
    booleanValue?: boolean
    decimalValue?: boolean
    jsonValue?: boolean
    imageUrl?: boolean
    category?: boolean
    isEnabled?: boolean
    version?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    alerts?: boolean | BusinessConfig$alertsArgs<ExtArgs>
    approvals?: boolean | BusinessConfig$approvalsArgs<ExtArgs>
    _count?: boolean | BusinessConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BusinessConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessConfig"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      alerts: Prisma.$ConfigAlertPayload<ExtArgs>[]
      approvals: Prisma.$ConfigApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      key: string
      label: string | null
      description: string | null
      valueType: string
      stringValue: string | null
      integerValue: number | null
      booleanValue: boolean | null
      decimalValue: number | null
      jsonValue: Prisma.JsonValue | null
      imageUrl: string | null
      category: string | null
      isEnabled: boolean
      version: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessConfig"]>
    composites: {}
  }

  type BusinessConfigGetPayload<S extends boolean | null | undefined | BusinessConfigDefaultArgs> = $Result.GetResult<Prisma.$BusinessConfigPayload, S>

  type BusinessConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessConfigCountAggregateInputType | true
    }

  export interface BusinessConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessConfig'], meta: { name: 'BusinessConfig' } }
    /**
     * Find zero or one BusinessConfig that matches the filter.
     * @param {BusinessConfigFindUniqueArgs} args - Arguments to find a BusinessConfig
     * @example
     * // Get one BusinessConfig
     * const businessConfig = await prisma.businessConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessConfigFindUniqueArgs>(args: SelectSubset<T, BusinessConfigFindUniqueArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessConfigFindUniqueOrThrowArgs} args - Arguments to find a BusinessConfig
     * @example
     * // Get one BusinessConfig
     * const businessConfig = await prisma.businessConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigFindFirstArgs} args - Arguments to find a BusinessConfig
     * @example
     * // Get one BusinessConfig
     * const businessConfig = await prisma.businessConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessConfigFindFirstArgs>(args?: SelectSubset<T, BusinessConfigFindFirstArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigFindFirstOrThrowArgs} args - Arguments to find a BusinessConfig
     * @example
     * // Get one BusinessConfig
     * const businessConfig = await prisma.businessConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessConfigs
     * const businessConfigs = await prisma.businessConfig.findMany()
     * 
     * // Get first 10 BusinessConfigs
     * const businessConfigs = await prisma.businessConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessConfigWithIdOnly = await prisma.businessConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessConfigFindManyArgs>(args?: SelectSubset<T, BusinessConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessConfig.
     * @param {BusinessConfigCreateArgs} args - Arguments to create a BusinessConfig.
     * @example
     * // Create one BusinessConfig
     * const BusinessConfig = await prisma.businessConfig.create({
     *   data: {
     *     // ... data to create a BusinessConfig
     *   }
     * })
     * 
     */
    create<T extends BusinessConfigCreateArgs>(args: SelectSubset<T, BusinessConfigCreateArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessConfigs.
     * @param {BusinessConfigCreateManyArgs} args - Arguments to create many BusinessConfigs.
     * @example
     * // Create many BusinessConfigs
     * const businessConfig = await prisma.businessConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessConfigCreateManyArgs>(args?: SelectSubset<T, BusinessConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessConfigs and returns the data saved in the database.
     * @param {BusinessConfigCreateManyAndReturnArgs} args - Arguments to create many BusinessConfigs.
     * @example
     * // Create many BusinessConfigs
     * const businessConfig = await prisma.businessConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessConfigs and only return the `id`
     * const businessConfigWithIdOnly = await prisma.businessConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessConfig.
     * @param {BusinessConfigDeleteArgs} args - Arguments to delete one BusinessConfig.
     * @example
     * // Delete one BusinessConfig
     * const BusinessConfig = await prisma.businessConfig.delete({
     *   where: {
     *     // ... filter to delete one BusinessConfig
     *   }
     * })
     * 
     */
    delete<T extends BusinessConfigDeleteArgs>(args: SelectSubset<T, BusinessConfigDeleteArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessConfig.
     * @param {BusinessConfigUpdateArgs} args - Arguments to update one BusinessConfig.
     * @example
     * // Update one BusinessConfig
     * const businessConfig = await prisma.businessConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessConfigUpdateArgs>(args: SelectSubset<T, BusinessConfigUpdateArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessConfigs.
     * @param {BusinessConfigDeleteManyArgs} args - Arguments to filter BusinessConfigs to delete.
     * @example
     * // Delete a few BusinessConfigs
     * const { count } = await prisma.businessConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessConfigDeleteManyArgs>(args?: SelectSubset<T, BusinessConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessConfigs
     * const businessConfig = await prisma.businessConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessConfigUpdateManyArgs>(args: SelectSubset<T, BusinessConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessConfig.
     * @param {BusinessConfigUpsertArgs} args - Arguments to update or create a BusinessConfig.
     * @example
     * // Update or create a BusinessConfig
     * const businessConfig = await prisma.businessConfig.upsert({
     *   create: {
     *     // ... data to create a BusinessConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessConfig we want to update
     *   }
     * })
     */
    upsert<T extends BusinessConfigUpsertArgs>(args: SelectSubset<T, BusinessConfigUpsertArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigCountArgs} args - Arguments to filter BusinessConfigs to count.
     * @example
     * // Count the number of BusinessConfigs
     * const count = await prisma.businessConfig.count({
     *   where: {
     *     // ... the filter for the BusinessConfigs we want to count
     *   }
     * })
    **/
    count<T extends BusinessConfigCountArgs>(
      args?: Subset<T, BusinessConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessConfigAggregateArgs>(args: Subset<T, BusinessConfigAggregateArgs>): Prisma.PrismaPromise<GetBusinessConfigAggregateType<T>>

    /**
     * Group by BusinessConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessConfigGroupByArgs['orderBy'] }
        : { orderBy?: BusinessConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessConfig model
   */
  readonly fields: BusinessConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alerts<T extends BusinessConfig$alertsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessConfig$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends BusinessConfig$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessConfig$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessConfig model
   */ 
  interface BusinessConfigFieldRefs {
    readonly id: FieldRef<"BusinessConfig", 'String'>
    readonly projectId: FieldRef<"BusinessConfig", 'String'>
    readonly key: FieldRef<"BusinessConfig", 'String'>
    readonly label: FieldRef<"BusinessConfig", 'String'>
    readonly description: FieldRef<"BusinessConfig", 'String'>
    readonly valueType: FieldRef<"BusinessConfig", 'String'>
    readonly stringValue: FieldRef<"BusinessConfig", 'String'>
    readonly integerValue: FieldRef<"BusinessConfig", 'Int'>
    readonly booleanValue: FieldRef<"BusinessConfig", 'Boolean'>
    readonly decimalValue: FieldRef<"BusinessConfig", 'Float'>
    readonly jsonValue: FieldRef<"BusinessConfig", 'Json'>
    readonly imageUrl: FieldRef<"BusinessConfig", 'String'>
    readonly category: FieldRef<"BusinessConfig", 'String'>
    readonly isEnabled: FieldRef<"BusinessConfig", 'Boolean'>
    readonly version: FieldRef<"BusinessConfig", 'Int'>
    readonly metadata: FieldRef<"BusinessConfig", 'Json'>
    readonly createdAt: FieldRef<"BusinessConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessConfig findUnique
   */
  export type BusinessConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter, which BusinessConfig to fetch.
     */
    where: BusinessConfigWhereUniqueInput
  }

  /**
   * BusinessConfig findUniqueOrThrow
   */
  export type BusinessConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter, which BusinessConfig to fetch.
     */
    where: BusinessConfigWhereUniqueInput
  }

  /**
   * BusinessConfig findFirst
   */
  export type BusinessConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter, which BusinessConfig to fetch.
     */
    where?: BusinessConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessConfigs to fetch.
     */
    orderBy?: BusinessConfigOrderByWithRelationInput | BusinessConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessConfigs.
     */
    cursor?: BusinessConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessConfigs.
     */
    distinct?: BusinessConfigScalarFieldEnum | BusinessConfigScalarFieldEnum[]
  }

  /**
   * BusinessConfig findFirstOrThrow
   */
  export type BusinessConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter, which BusinessConfig to fetch.
     */
    where?: BusinessConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessConfigs to fetch.
     */
    orderBy?: BusinessConfigOrderByWithRelationInput | BusinessConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessConfigs.
     */
    cursor?: BusinessConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessConfigs.
     */
    distinct?: BusinessConfigScalarFieldEnum | BusinessConfigScalarFieldEnum[]
  }

  /**
   * BusinessConfig findMany
   */
  export type BusinessConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter, which BusinessConfigs to fetch.
     */
    where?: BusinessConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessConfigs to fetch.
     */
    orderBy?: BusinessConfigOrderByWithRelationInput | BusinessConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessConfigs.
     */
    cursor?: BusinessConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessConfigs.
     */
    skip?: number
    distinct?: BusinessConfigScalarFieldEnum | BusinessConfigScalarFieldEnum[]
  }

  /**
   * BusinessConfig create
   */
  export type BusinessConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessConfig.
     */
    data: XOR<BusinessConfigCreateInput, BusinessConfigUncheckedCreateInput>
  }

  /**
   * BusinessConfig createMany
   */
  export type BusinessConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessConfigs.
     */
    data: BusinessConfigCreateManyInput | BusinessConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessConfig createManyAndReturn
   */
  export type BusinessConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessConfigs.
     */
    data: BusinessConfigCreateManyInput | BusinessConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessConfig update
   */
  export type BusinessConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessConfig.
     */
    data: XOR<BusinessConfigUpdateInput, BusinessConfigUncheckedUpdateInput>
    /**
     * Choose, which BusinessConfig to update.
     */
    where: BusinessConfigWhereUniqueInput
  }

  /**
   * BusinessConfig updateMany
   */
  export type BusinessConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessConfigs.
     */
    data: XOR<BusinessConfigUpdateManyMutationInput, BusinessConfigUncheckedUpdateManyInput>
    /**
     * Filter which BusinessConfigs to update
     */
    where?: BusinessConfigWhereInput
  }

  /**
   * BusinessConfig upsert
   */
  export type BusinessConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessConfig to update in case it exists.
     */
    where: BusinessConfigWhereUniqueInput
    /**
     * In case the BusinessConfig found by the `where` argument doesn't exist, create a new BusinessConfig with this data.
     */
    create: XOR<BusinessConfigCreateInput, BusinessConfigUncheckedCreateInput>
    /**
     * In case the BusinessConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessConfigUpdateInput, BusinessConfigUncheckedUpdateInput>
  }

  /**
   * BusinessConfig delete
   */
  export type BusinessConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    /**
     * Filter which BusinessConfig to delete.
     */
    where: BusinessConfigWhereUniqueInput
  }

  /**
   * BusinessConfig deleteMany
   */
  export type BusinessConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessConfigs to delete
     */
    where?: BusinessConfigWhereInput
  }

  /**
   * BusinessConfig.alerts
   */
  export type BusinessConfig$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    where?: ConfigAlertWhereInput
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    cursor?: ConfigAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigAlertScalarFieldEnum | ConfigAlertScalarFieldEnum[]
  }

  /**
   * BusinessConfig.approvals
   */
  export type BusinessConfig$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    where?: ConfigApprovalWhereInput
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    cursor?: ConfigApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigApprovalScalarFieldEnum | ConfigApprovalScalarFieldEnum[]
  }

  /**
   * BusinessConfig without action
   */
  export type BusinessConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
  }


  /**
   * Model UploadedFile
   */

  export type AggregateUploadedFile = {
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  export type UploadedFileAvgAggregateOutputType = {
    size: number | null
  }

  export type UploadedFileSumAggregateOutputType = {
    size: number | null
  }

  export type UploadedFileMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    filename: string | null
    storedName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type UploadedFileMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    filename: string | null
    storedName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedBy: string | null
    createdAt: Date | null
  }

  export type UploadedFileCountAggregateOutputType = {
    id: number
    projectId: number
    filename: number
    storedName: number
    mimeType: number
    size: number
    url: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type UploadedFileAvgAggregateInputType = {
    size?: true
  }

  export type UploadedFileSumAggregateInputType = {
    size?: true
  }

  export type UploadedFileMinAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    storedName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type UploadedFileMaxAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    storedName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type UploadedFileCountAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    storedName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type UploadedFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFile to aggregate.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadedFiles
    **/
    _count?: true | UploadedFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadedFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadedFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadedFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadedFileMaxAggregateInputType
  }

  export type GetUploadedFileAggregateType<T extends UploadedFileAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadedFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadedFile[P]>
      : GetScalarType<T[P], AggregateUploadedFile[P]>
  }




  export type UploadedFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadedFileWhereInput
    orderBy?: UploadedFileOrderByWithAggregationInput | UploadedFileOrderByWithAggregationInput[]
    by: UploadedFileScalarFieldEnum[] | UploadedFileScalarFieldEnum
    having?: UploadedFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadedFileCountAggregateInputType | true
    _avg?: UploadedFileAvgAggregateInputType
    _sum?: UploadedFileSumAggregateInputType
    _min?: UploadedFileMinAggregateInputType
    _max?: UploadedFileMaxAggregateInputType
  }

  export type UploadedFileGroupByOutputType = {
    id: string
    projectId: string
    filename: string
    storedName: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string | null
    createdAt: Date
    _count: UploadedFileCountAggregateOutputType | null
    _avg: UploadedFileAvgAggregateOutputType | null
    _sum: UploadedFileSumAggregateOutputType | null
    _min: UploadedFileMinAggregateOutputType | null
    _max: UploadedFileMaxAggregateOutputType | null
  }

  type GetUploadedFileGroupByPayload<T extends UploadedFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadedFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadedFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
            : GetScalarType<T[P], UploadedFileGroupByOutputType[P]>
        }
      >
    >


  export type UploadedFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    filename?: boolean
    storedName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    filename?: boolean
    storedName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["uploadedFile"]>

  export type UploadedFileSelectScalar = {
    id?: boolean
    projectId?: boolean
    filename?: boolean
    storedName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }


  export type $UploadedFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UploadedFile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      filename: string
      storedName: string
      mimeType: string
      size: number
      url: string
      uploadedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["uploadedFile"]>
    composites: {}
  }

  type UploadedFileGetPayload<S extends boolean | null | undefined | UploadedFileDefaultArgs> = $Result.GetResult<Prisma.$UploadedFilePayload, S>

  type UploadedFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UploadedFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UploadedFileCountAggregateInputType | true
    }

  export interface UploadedFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadedFile'], meta: { name: 'UploadedFile' } }
    /**
     * Find zero or one UploadedFile that matches the filter.
     * @param {UploadedFileFindUniqueArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadedFileFindUniqueArgs>(args: SelectSubset<T, UploadedFileFindUniqueArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UploadedFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UploadedFileFindUniqueOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadedFileFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadedFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UploadedFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadedFileFindFirstArgs>(args?: SelectSubset<T, UploadedFileFindFirstArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UploadedFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindFirstOrThrowArgs} args - Arguments to find a UploadedFile
     * @example
     * // Get one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadedFileFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadedFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UploadedFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany()
     * 
     * // Get first 10 UploadedFiles
     * const uploadedFiles = await prisma.uploadedFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadedFileFindManyArgs>(args?: SelectSubset<T, UploadedFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UploadedFile.
     * @param {UploadedFileCreateArgs} args - Arguments to create a UploadedFile.
     * @example
     * // Create one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.create({
     *   data: {
     *     // ... data to create a UploadedFile
     *   }
     * })
     * 
     */
    create<T extends UploadedFileCreateArgs>(args: SelectSubset<T, UploadedFileCreateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UploadedFiles.
     * @param {UploadedFileCreateManyArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadedFileCreateManyArgs>(args?: SelectSubset<T, UploadedFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UploadedFiles and returns the data saved in the database.
     * @param {UploadedFileCreateManyAndReturnArgs} args - Arguments to create many UploadedFiles.
     * @example
     * // Create many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UploadedFiles and only return the `id`
     * const uploadedFileWithIdOnly = await prisma.uploadedFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadedFileCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadedFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UploadedFile.
     * @param {UploadedFileDeleteArgs} args - Arguments to delete one UploadedFile.
     * @example
     * // Delete one UploadedFile
     * const UploadedFile = await prisma.uploadedFile.delete({
     *   where: {
     *     // ... filter to delete one UploadedFile
     *   }
     * })
     * 
     */
    delete<T extends UploadedFileDeleteArgs>(args: SelectSubset<T, UploadedFileDeleteArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UploadedFile.
     * @param {UploadedFileUpdateArgs} args - Arguments to update one UploadedFile.
     * @example
     * // Update one UploadedFile
     * const uploadedFile = await prisma.uploadedFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadedFileUpdateArgs>(args: SelectSubset<T, UploadedFileUpdateArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UploadedFiles.
     * @param {UploadedFileDeleteManyArgs} args - Arguments to filter UploadedFiles to delete.
     * @example
     * // Delete a few UploadedFiles
     * const { count } = await prisma.uploadedFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadedFileDeleteManyArgs>(args?: SelectSubset<T, UploadedFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadedFiles
     * const uploadedFile = await prisma.uploadedFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadedFileUpdateManyArgs>(args: SelectSubset<T, UploadedFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UploadedFile.
     * @param {UploadedFileUpsertArgs} args - Arguments to update or create a UploadedFile.
     * @example
     * // Update or create a UploadedFile
     * const uploadedFile = await prisma.uploadedFile.upsert({
     *   create: {
     *     // ... data to create a UploadedFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadedFile we want to update
     *   }
     * })
     */
    upsert<T extends UploadedFileUpsertArgs>(args: SelectSubset<T, UploadedFileUpsertArgs<ExtArgs>>): Prisma__UploadedFileClient<$Result.GetResult<Prisma.$UploadedFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UploadedFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileCountArgs} args - Arguments to filter UploadedFiles to count.
     * @example
     * // Count the number of UploadedFiles
     * const count = await prisma.uploadedFile.count({
     *   where: {
     *     // ... the filter for the UploadedFiles we want to count
     *   }
     * })
    **/
    count<T extends UploadedFileCountArgs>(
      args?: Subset<T, UploadedFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadedFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadedFileAggregateArgs>(args: Subset<T, UploadedFileAggregateArgs>): Prisma.PrismaPromise<GetUploadedFileAggregateType<T>>

    /**
     * Group by UploadedFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadedFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadedFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadedFileGroupByArgs['orderBy'] }
        : { orderBy?: UploadedFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadedFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadedFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UploadedFile model
   */
  readonly fields: UploadedFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadedFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadedFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UploadedFile model
   */ 
  interface UploadedFileFieldRefs {
    readonly id: FieldRef<"UploadedFile", 'String'>
    readonly projectId: FieldRef<"UploadedFile", 'String'>
    readonly filename: FieldRef<"UploadedFile", 'String'>
    readonly storedName: FieldRef<"UploadedFile", 'String'>
    readonly mimeType: FieldRef<"UploadedFile", 'String'>
    readonly size: FieldRef<"UploadedFile", 'Int'>
    readonly url: FieldRef<"UploadedFile", 'String'>
    readonly uploadedBy: FieldRef<"UploadedFile", 'String'>
    readonly createdAt: FieldRef<"UploadedFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UploadedFile findUnique
   */
  export type UploadedFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findUniqueOrThrow
   */
  export type UploadedFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile findFirst
   */
  export type UploadedFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findFirstOrThrow
   */
  export type UploadedFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter, which UploadedFile to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadedFiles.
     */
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile findMany
   */
  export type UploadedFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter, which UploadedFiles to fetch.
     */
    where?: UploadedFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadedFiles to fetch.
     */
    orderBy?: UploadedFileOrderByWithRelationInput | UploadedFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadedFiles.
     */
    cursor?: UploadedFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadedFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadedFiles.
     */
    skip?: number
    distinct?: UploadedFileScalarFieldEnum | UploadedFileScalarFieldEnum[]
  }

  /**
   * UploadedFile create
   */
  export type UploadedFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * The data needed to create a UploadedFile.
     */
    data: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
  }

  /**
   * UploadedFile createMany
   */
  export type UploadedFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UploadedFile createManyAndReturn
   */
  export type UploadedFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UploadedFiles.
     */
    data: UploadedFileCreateManyInput | UploadedFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UploadedFile update
   */
  export type UploadedFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * The data needed to update a UploadedFile.
     */
    data: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
    /**
     * Choose, which UploadedFile to update.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile updateMany
   */
  export type UploadedFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadedFiles.
     */
    data: XOR<UploadedFileUpdateManyMutationInput, UploadedFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadedFiles to update
     */
    where?: UploadedFileWhereInput
  }

  /**
   * UploadedFile upsert
   */
  export type UploadedFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * The filter to search for the UploadedFile to update in case it exists.
     */
    where: UploadedFileWhereUniqueInput
    /**
     * In case the UploadedFile found by the `where` argument doesn't exist, create a new UploadedFile with this data.
     */
    create: XOR<UploadedFileCreateInput, UploadedFileUncheckedCreateInput>
    /**
     * In case the UploadedFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadedFileUpdateInput, UploadedFileUncheckedUpdateInput>
  }

  /**
   * UploadedFile delete
   */
  export type UploadedFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
    /**
     * Filter which UploadedFile to delete.
     */
    where: UploadedFileWhereUniqueInput
  }

  /**
   * UploadedFile deleteMany
   */
  export type UploadedFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadedFiles to delete
     */
    where?: UploadedFileWhereInput
  }

  /**
   * UploadedFile without action
   */
  export type UploadedFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadedFile
     */
    select?: UploadedFileSelect<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    isDefault: boolean | null
    isEnabled: boolean | null
    isRTL: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    isDefault: boolean | null
    isEnabled: boolean | null
    isRTL: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    projectId: number
    code: number
    name: number
    nativeName: number
    isDefault: number
    isEnabled: number
    isRTL: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    projectId?: true
    code?: true
    name?: true
    nativeName?: true
    isDefault?: true
    isEnabled?: true
    isRTL?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    projectId?: true
    code?: true
    name?: true
    nativeName?: true
    isDefault?: true
    isEnabled?: true
    isRTL?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    projectId?: true
    code?: true
    name?: true
    nativeName?: true
    isDefault?: true
    isEnabled?: true
    isRTL?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    projectId: string
    code: string
    name: string
    nativeName: string | null
    isDefault: boolean
    isEnabled: boolean
    isRTL: boolean
    createdAt: Date
    updatedAt: Date
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    projectId?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      translations: Prisma.$TranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      code: string
      name: string
      nativeName: string | null
      isDefault: boolean
      isEnabled: boolean
      isRTL: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translations<T extends Language$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Language$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly projectId: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly nativeName: FieldRef<"Language", 'String'>
    readonly isDefault: FieldRef<"Language", 'Boolean'>
    readonly isEnabled: FieldRef<"Language", 'Boolean'>
    readonly isRTL: FieldRef<"Language", 'Boolean'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language.translations
   */
  export type Language$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model LocalizationKey
   */

  export type AggregateLocalizationKey = {
    _count: LocalizationKeyCountAggregateOutputType | null
    _avg: LocalizationKeyAvgAggregateOutputType | null
    _sum: LocalizationKeySumAggregateOutputType | null
    _min: LocalizationKeyMinAggregateOutputType | null
    _max: LocalizationKeyMaxAggregateOutputType | null
  }

  export type LocalizationKeyAvgAggregateOutputType = {
    maxLength: number | null
  }

  export type LocalizationKeySumAggregateOutputType = {
    maxLength: number | null
  }

  export type LocalizationKeyMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    key: string | null
    description: string | null
    category: string | null
    platform: string | null
    maxLength: number | null
    screenshot: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalizationKeyMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    key: string | null
    description: string | null
    category: string | null
    platform: string | null
    maxLength: number | null
    screenshot: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalizationKeyCountAggregateOutputType = {
    id: number
    projectId: number
    key: number
    description: number
    category: number
    platform: number
    maxLength: number
    screenshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalizationKeyAvgAggregateInputType = {
    maxLength?: true
  }

  export type LocalizationKeySumAggregateInputType = {
    maxLength?: true
  }

  export type LocalizationKeyMinAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    description?: true
    category?: true
    platform?: true
    maxLength?: true
    screenshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalizationKeyMaxAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    description?: true
    category?: true
    platform?: true
    maxLength?: true
    screenshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalizationKeyCountAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    description?: true
    category?: true
    platform?: true
    maxLength?: true
    screenshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalizationKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalizationKey to aggregate.
     */
    where?: LocalizationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizationKeys to fetch.
     */
    orderBy?: LocalizationKeyOrderByWithRelationInput | LocalizationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalizationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalizationKeys
    **/
    _count?: true | LocalizationKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalizationKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalizationKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalizationKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalizationKeyMaxAggregateInputType
  }

  export type GetLocalizationKeyAggregateType<T extends LocalizationKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalizationKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalizationKey[P]>
      : GetScalarType<T[P], AggregateLocalizationKey[P]>
  }




  export type LocalizationKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalizationKeyWhereInput
    orderBy?: LocalizationKeyOrderByWithAggregationInput | LocalizationKeyOrderByWithAggregationInput[]
    by: LocalizationKeyScalarFieldEnum[] | LocalizationKeyScalarFieldEnum
    having?: LocalizationKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalizationKeyCountAggregateInputType | true
    _avg?: LocalizationKeyAvgAggregateInputType
    _sum?: LocalizationKeySumAggregateInputType
    _min?: LocalizationKeyMinAggregateInputType
    _max?: LocalizationKeyMaxAggregateInputType
  }

  export type LocalizationKeyGroupByOutputType = {
    id: string
    projectId: string
    key: string
    description: string | null
    category: string | null
    platform: string | null
    maxLength: number | null
    screenshot: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocalizationKeyCountAggregateOutputType | null
    _avg: LocalizationKeyAvgAggregateOutputType | null
    _sum: LocalizationKeySumAggregateOutputType | null
    _min: LocalizationKeyMinAggregateOutputType | null
    _max: LocalizationKeyMaxAggregateOutputType | null
  }

  type GetLocalizationKeyGroupByPayload<T extends LocalizationKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalizationKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalizationKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalizationKeyGroupByOutputType[P]>
            : GetScalarType<T[P], LocalizationKeyGroupByOutputType[P]>
        }
      >
    >


  export type LocalizationKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    key?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    maxLength?: boolean
    screenshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    translations?: boolean | LocalizationKey$translationsArgs<ExtArgs>
    _count?: boolean | LocalizationKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localizationKey"]>

  export type LocalizationKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    key?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    maxLength?: boolean
    screenshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localizationKey"]>

  export type LocalizationKeySelectScalar = {
    id?: boolean
    projectId?: boolean
    key?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    maxLength?: boolean
    screenshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocalizationKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    translations?: boolean | LocalizationKey$translationsArgs<ExtArgs>
    _count?: boolean | LocalizationKeyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalizationKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LocalizationKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalizationKey"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      translations: Prisma.$TranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      key: string
      description: string | null
      category: string | null
      platform: string | null
      maxLength: number | null
      screenshot: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["localizationKey"]>
    composites: {}
  }

  type LocalizationKeyGetPayload<S extends boolean | null | undefined | LocalizationKeyDefaultArgs> = $Result.GetResult<Prisma.$LocalizationKeyPayload, S>

  type LocalizationKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalizationKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalizationKeyCountAggregateInputType | true
    }

  export interface LocalizationKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalizationKey'], meta: { name: 'LocalizationKey' } }
    /**
     * Find zero or one LocalizationKey that matches the filter.
     * @param {LocalizationKeyFindUniqueArgs} args - Arguments to find a LocalizationKey
     * @example
     * // Get one LocalizationKey
     * const localizationKey = await prisma.localizationKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalizationKeyFindUniqueArgs>(args: SelectSubset<T, LocalizationKeyFindUniqueArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalizationKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalizationKeyFindUniqueOrThrowArgs} args - Arguments to find a LocalizationKey
     * @example
     * // Get one LocalizationKey
     * const localizationKey = await prisma.localizationKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalizationKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalizationKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalizationKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyFindFirstArgs} args - Arguments to find a LocalizationKey
     * @example
     * // Get one LocalizationKey
     * const localizationKey = await prisma.localizationKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalizationKeyFindFirstArgs>(args?: SelectSubset<T, LocalizationKeyFindFirstArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalizationKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyFindFirstOrThrowArgs} args - Arguments to find a LocalizationKey
     * @example
     * // Get one LocalizationKey
     * const localizationKey = await prisma.localizationKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalizationKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalizationKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalizationKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalizationKeys
     * const localizationKeys = await prisma.localizationKey.findMany()
     * 
     * // Get first 10 LocalizationKeys
     * const localizationKeys = await prisma.localizationKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localizationKeyWithIdOnly = await prisma.localizationKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalizationKeyFindManyArgs>(args?: SelectSubset<T, LocalizationKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalizationKey.
     * @param {LocalizationKeyCreateArgs} args - Arguments to create a LocalizationKey.
     * @example
     * // Create one LocalizationKey
     * const LocalizationKey = await prisma.localizationKey.create({
     *   data: {
     *     // ... data to create a LocalizationKey
     *   }
     * })
     * 
     */
    create<T extends LocalizationKeyCreateArgs>(args: SelectSubset<T, LocalizationKeyCreateArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalizationKeys.
     * @param {LocalizationKeyCreateManyArgs} args - Arguments to create many LocalizationKeys.
     * @example
     * // Create many LocalizationKeys
     * const localizationKey = await prisma.localizationKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalizationKeyCreateManyArgs>(args?: SelectSubset<T, LocalizationKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalizationKeys and returns the data saved in the database.
     * @param {LocalizationKeyCreateManyAndReturnArgs} args - Arguments to create many LocalizationKeys.
     * @example
     * // Create many LocalizationKeys
     * const localizationKey = await prisma.localizationKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalizationKeys and only return the `id`
     * const localizationKeyWithIdOnly = await prisma.localizationKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalizationKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalizationKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalizationKey.
     * @param {LocalizationKeyDeleteArgs} args - Arguments to delete one LocalizationKey.
     * @example
     * // Delete one LocalizationKey
     * const LocalizationKey = await prisma.localizationKey.delete({
     *   where: {
     *     // ... filter to delete one LocalizationKey
     *   }
     * })
     * 
     */
    delete<T extends LocalizationKeyDeleteArgs>(args: SelectSubset<T, LocalizationKeyDeleteArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalizationKey.
     * @param {LocalizationKeyUpdateArgs} args - Arguments to update one LocalizationKey.
     * @example
     * // Update one LocalizationKey
     * const localizationKey = await prisma.localizationKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalizationKeyUpdateArgs>(args: SelectSubset<T, LocalizationKeyUpdateArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalizationKeys.
     * @param {LocalizationKeyDeleteManyArgs} args - Arguments to filter LocalizationKeys to delete.
     * @example
     * // Delete a few LocalizationKeys
     * const { count } = await prisma.localizationKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalizationKeyDeleteManyArgs>(args?: SelectSubset<T, LocalizationKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalizationKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalizationKeys
     * const localizationKey = await prisma.localizationKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalizationKeyUpdateManyArgs>(args: SelectSubset<T, LocalizationKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalizationKey.
     * @param {LocalizationKeyUpsertArgs} args - Arguments to update or create a LocalizationKey.
     * @example
     * // Update or create a LocalizationKey
     * const localizationKey = await prisma.localizationKey.upsert({
     *   create: {
     *     // ... data to create a LocalizationKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalizationKey we want to update
     *   }
     * })
     */
    upsert<T extends LocalizationKeyUpsertArgs>(args: SelectSubset<T, LocalizationKeyUpsertArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalizationKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyCountArgs} args - Arguments to filter LocalizationKeys to count.
     * @example
     * // Count the number of LocalizationKeys
     * const count = await prisma.localizationKey.count({
     *   where: {
     *     // ... the filter for the LocalizationKeys we want to count
     *   }
     * })
    **/
    count<T extends LocalizationKeyCountArgs>(
      args?: Subset<T, LocalizationKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalizationKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalizationKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalizationKeyAggregateArgs>(args: Subset<T, LocalizationKeyAggregateArgs>): Prisma.PrismaPromise<GetLocalizationKeyAggregateType<T>>

    /**
     * Group by LocalizationKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizationKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalizationKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalizationKeyGroupByArgs['orderBy'] }
        : { orderBy?: LocalizationKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalizationKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalizationKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalizationKey model
   */
  readonly fields: LocalizationKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalizationKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalizationKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translations<T extends LocalizationKey$translationsArgs<ExtArgs> = {}>(args?: Subset<T, LocalizationKey$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalizationKey model
   */ 
  interface LocalizationKeyFieldRefs {
    readonly id: FieldRef<"LocalizationKey", 'String'>
    readonly projectId: FieldRef<"LocalizationKey", 'String'>
    readonly key: FieldRef<"LocalizationKey", 'String'>
    readonly description: FieldRef<"LocalizationKey", 'String'>
    readonly category: FieldRef<"LocalizationKey", 'String'>
    readonly platform: FieldRef<"LocalizationKey", 'String'>
    readonly maxLength: FieldRef<"LocalizationKey", 'Int'>
    readonly screenshot: FieldRef<"LocalizationKey", 'String'>
    readonly createdAt: FieldRef<"LocalizationKey", 'DateTime'>
    readonly updatedAt: FieldRef<"LocalizationKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalizationKey findUnique
   */
  export type LocalizationKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter, which LocalizationKey to fetch.
     */
    where: LocalizationKeyWhereUniqueInput
  }

  /**
   * LocalizationKey findUniqueOrThrow
   */
  export type LocalizationKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter, which LocalizationKey to fetch.
     */
    where: LocalizationKeyWhereUniqueInput
  }

  /**
   * LocalizationKey findFirst
   */
  export type LocalizationKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter, which LocalizationKey to fetch.
     */
    where?: LocalizationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizationKeys to fetch.
     */
    orderBy?: LocalizationKeyOrderByWithRelationInput | LocalizationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalizationKeys.
     */
    cursor?: LocalizationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalizationKeys.
     */
    distinct?: LocalizationKeyScalarFieldEnum | LocalizationKeyScalarFieldEnum[]
  }

  /**
   * LocalizationKey findFirstOrThrow
   */
  export type LocalizationKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter, which LocalizationKey to fetch.
     */
    where?: LocalizationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizationKeys to fetch.
     */
    orderBy?: LocalizationKeyOrderByWithRelationInput | LocalizationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalizationKeys.
     */
    cursor?: LocalizationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizationKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalizationKeys.
     */
    distinct?: LocalizationKeyScalarFieldEnum | LocalizationKeyScalarFieldEnum[]
  }

  /**
   * LocalizationKey findMany
   */
  export type LocalizationKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter, which LocalizationKeys to fetch.
     */
    where?: LocalizationKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizationKeys to fetch.
     */
    orderBy?: LocalizationKeyOrderByWithRelationInput | LocalizationKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalizationKeys.
     */
    cursor?: LocalizationKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizationKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizationKeys.
     */
    skip?: number
    distinct?: LocalizationKeyScalarFieldEnum | LocalizationKeyScalarFieldEnum[]
  }

  /**
   * LocalizationKey create
   */
  export type LocalizationKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalizationKey.
     */
    data: XOR<LocalizationKeyCreateInput, LocalizationKeyUncheckedCreateInput>
  }

  /**
   * LocalizationKey createMany
   */
  export type LocalizationKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalizationKeys.
     */
    data: LocalizationKeyCreateManyInput | LocalizationKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocalizationKey createManyAndReturn
   */
  export type LocalizationKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalizationKeys.
     */
    data: LocalizationKeyCreateManyInput | LocalizationKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocalizationKey update
   */
  export type LocalizationKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalizationKey.
     */
    data: XOR<LocalizationKeyUpdateInput, LocalizationKeyUncheckedUpdateInput>
    /**
     * Choose, which LocalizationKey to update.
     */
    where: LocalizationKeyWhereUniqueInput
  }

  /**
   * LocalizationKey updateMany
   */
  export type LocalizationKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalizationKeys.
     */
    data: XOR<LocalizationKeyUpdateManyMutationInput, LocalizationKeyUncheckedUpdateManyInput>
    /**
     * Filter which LocalizationKeys to update
     */
    where?: LocalizationKeyWhereInput
  }

  /**
   * LocalizationKey upsert
   */
  export type LocalizationKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalizationKey to update in case it exists.
     */
    where: LocalizationKeyWhereUniqueInput
    /**
     * In case the LocalizationKey found by the `where` argument doesn't exist, create a new LocalizationKey with this data.
     */
    create: XOR<LocalizationKeyCreateInput, LocalizationKeyUncheckedCreateInput>
    /**
     * In case the LocalizationKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalizationKeyUpdateInput, LocalizationKeyUncheckedUpdateInput>
  }

  /**
   * LocalizationKey delete
   */
  export type LocalizationKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
    /**
     * Filter which LocalizationKey to delete.
     */
    where: LocalizationKeyWhereUniqueInput
  }

  /**
   * LocalizationKey deleteMany
   */
  export type LocalizationKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalizationKeys to delete
     */
    where?: LocalizationKeyWhereInput
  }

  /**
   * LocalizationKey.translations
   */
  export type LocalizationKey$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * LocalizationKey without action
   */
  export type LocalizationKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizationKey
     */
    select?: LocalizationKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalizationKeyInclude<ExtArgs> | null
  }


  /**
   * Model Translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    keyId: string | null
    languageId: string | null
    value: string | null
    isReviewed: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    keyId: string | null
    languageId: string | null
    value: string | null
    isReviewed: boolean | null
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationCountAggregateOutputType = {
    id: number
    projectId: number
    keyId: number
    languageId: number
    value: number
    isReviewed: number
    reviewedBy: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TranslationMinAggregateInputType = {
    id?: true
    projectId?: true
    keyId?: true
    languageId?: true
    value?: true
    isReviewed?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationMaxAggregateInputType = {
    id?: true
    projectId?: true
    keyId?: true
    languageId?: true
    value?: true
    isReviewed?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationCountAggregateInputType = {
    id?: true
    projectId?: true
    keyId?: true
    languageId?: true
    value?: true
    isReviewed?: true
    reviewedBy?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translation to aggregate.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithAggregationInput | TranslationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: TranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    id: string
    projectId: string
    keyId: string
    languageId: string
    value: string
    isReviewed: boolean
    reviewedBy: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type TranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    keyId?: boolean
    languageId?: boolean
    value?: boolean
    isReviewed?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean | LocalizationKeyDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    keyId?: boolean
    languageId?: boolean
    value?: boolean
    isReviewed?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean | LocalizationKeyDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectScalar = {
    id?: boolean
    projectId?: boolean
    keyId?: boolean
    languageId?: boolean
    value?: boolean
    isReviewed?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    key?: boolean | LocalizationKeyDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type TranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    key?: boolean | LocalizationKeyDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $TranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Translation"
    objects: {
      key: Prisma.$LocalizationKeyPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      keyId: string
      languageId: string
      value: string
      isReviewed: boolean
      reviewedBy: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type TranslationGetPayload<S extends boolean | null | undefined | TranslationDefaultArgs> = $Result.GetResult<Prisma.$TranslationPayload, S>

  type TranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface TranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Translation'], meta: { name: 'Translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {TranslationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationFindUniqueArgs>(args: SelectSubset<T, TranslationFindUniqueArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationFindFirstArgs>(args?: SelectSubset<T, TranslationFindFirstArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationWithIdOnly = await prisma.translation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationFindManyArgs>(args?: SelectSubset<T, TranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Translation.
     * @param {TranslationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends TranslationCreateArgs>(args: SelectSubset<T, TranslationCreateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Translations.
     * @param {TranslationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationCreateManyArgs>(args?: SelectSubset<T, TranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Translations and returns the data saved in the database.
     * @param {TranslationCreateManyAndReturnArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Translations and only return the `id`
     * const translationWithIdOnly = await prisma.translation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Translation.
     * @param {TranslationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends TranslationDeleteArgs>(args: SelectSubset<T, TranslationDeleteArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Translation.
     * @param {TranslationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationUpdateArgs>(args: SelectSubset<T, TranslationUpdateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Translations.
     * @param {TranslationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationDeleteManyArgs>(args?: SelectSubset<T, TranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationUpdateManyArgs>(args: SelectSubset<T, TranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {TranslationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends TranslationUpsertArgs>(args: SelectSubset<T, TranslationUpsertArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends TranslationCountArgs>(
      args?: Subset<T, TranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Translation model
   */
  readonly fields: TranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    key<T extends LocalizationKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalizationKeyDefaultArgs<ExtArgs>>): Prisma__LocalizationKeyClient<$Result.GetResult<Prisma.$LocalizationKeyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Translation model
   */ 
  interface TranslationFieldRefs {
    readonly id: FieldRef<"Translation", 'String'>
    readonly projectId: FieldRef<"Translation", 'String'>
    readonly keyId: FieldRef<"Translation", 'String'>
    readonly languageId: FieldRef<"Translation", 'String'>
    readonly value: FieldRef<"Translation", 'String'>
    readonly isReviewed: FieldRef<"Translation", 'Boolean'>
    readonly reviewedBy: FieldRef<"Translation", 'String'>
    readonly reviewedAt: FieldRef<"Translation", 'DateTime'>
    readonly createdAt: FieldRef<"Translation", 'DateTime'>
    readonly updatedAt: FieldRef<"Translation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Translation findUnique
   */
  export type TranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findUniqueOrThrow
   */
  export type TranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findFirst
   */
  export type TranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findFirstOrThrow
   */
  export type TranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findMany
   */
  export type TranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translations to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation create
   */
  export type TranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a Translation.
     */
    data: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
  }

  /**
   * Translation createMany
   */
  export type TranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Translation createManyAndReturn
   */
  export type TranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Translation update
   */
  export type TranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a Translation.
     */
    data: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
    /**
     * Choose, which Translation to update.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation updateMany
   */
  export type TranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Translations.
     */
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyInput>
    /**
     * Filter which Translations to update
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation upsert
   */
  export type TranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the Translation to update in case it exists.
     */
    where: TranslationWhereUniqueInput
    /**
     * In case the Translation found by the `where` argument doesn't exist, create a new Translation with this data.
     */
    create: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
    /**
     * In case the Translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
  }

  /**
   * Translation delete
   */
  export type TranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter which Translation to delete.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation deleteMany
   */
  export type TranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translations to delete
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation without action
   */
  export type TranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
  }


  /**
   * Model FeatureFlags
   */

  export type AggregateFeatureFlags = {
    _count: FeatureFlagsCountAggregateOutputType | null
    _min: FeatureFlagsMinAggregateOutputType | null
    _max: FeatureFlagsMaxAggregateOutputType | null
  }

  export type FeatureFlagsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    sdkEnabled: boolean | null
    apiTracking: boolean | null
    screenTracking: boolean | null
    crashReporting: boolean | null
    logging: boolean | null
    deviceTracking: boolean | null
    sessionTracking: boolean | null
    businessConfig: boolean | null
    localization: boolean | null
    offlineSupport: boolean | null
    batchEvents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    sdkEnabled: boolean | null
    apiTracking: boolean | null
    screenTracking: boolean | null
    crashReporting: boolean | null
    logging: boolean | null
    deviceTracking: boolean | null
    sessionTracking: boolean | null
    businessConfig: boolean | null
    localization: boolean | null
    offlineSupport: boolean | null
    batchEvents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagsCountAggregateOutputType = {
    id: number
    projectId: number
    sdkEnabled: number
    apiTracking: number
    screenTracking: number
    crashReporting: number
    logging: number
    deviceTracking: number
    sessionTracking: number
    businessConfig: number
    localization: number
    offlineSupport: number
    batchEvents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureFlagsMinAggregateInputType = {
    id?: true
    projectId?: true
    sdkEnabled?: true
    apiTracking?: true
    screenTracking?: true
    crashReporting?: true
    logging?: true
    deviceTracking?: true
    sessionTracking?: true
    businessConfig?: true
    localization?: true
    offlineSupport?: true
    batchEvents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagsMaxAggregateInputType = {
    id?: true
    projectId?: true
    sdkEnabled?: true
    apiTracking?: true
    screenTracking?: true
    crashReporting?: true
    logging?: true
    deviceTracking?: true
    sessionTracking?: true
    businessConfig?: true
    localization?: true
    offlineSupport?: true
    batchEvents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagsCountAggregateInputType = {
    id?: true
    projectId?: true
    sdkEnabled?: true
    apiTracking?: true
    screenTracking?: true
    crashReporting?: true
    logging?: true
    deviceTracking?: true
    sessionTracking?: true
    businessConfig?: true
    localization?: true
    offlineSupport?: true
    batchEvents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureFlagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to aggregate.
     */
    where?: FeatureFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagsOrderByWithRelationInput | FeatureFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureFlags
    **/
    _count?: true | FeatureFlagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureFlagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureFlagsMaxAggregateInputType
  }

  export type GetFeatureFlagsAggregateType<T extends FeatureFlagsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureFlags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureFlags[P]>
      : GetScalarType<T[P], AggregateFeatureFlags[P]>
  }




  export type FeatureFlagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureFlagsWhereInput
    orderBy?: FeatureFlagsOrderByWithAggregationInput | FeatureFlagsOrderByWithAggregationInput[]
    by: FeatureFlagsScalarFieldEnum[] | FeatureFlagsScalarFieldEnum
    having?: FeatureFlagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureFlagsCountAggregateInputType | true
    _min?: FeatureFlagsMinAggregateInputType
    _max?: FeatureFlagsMaxAggregateInputType
  }

  export type FeatureFlagsGroupByOutputType = {
    id: string
    projectId: string
    sdkEnabled: boolean
    apiTracking: boolean
    screenTracking: boolean
    crashReporting: boolean
    logging: boolean
    deviceTracking: boolean
    sessionTracking: boolean
    businessConfig: boolean
    localization: boolean
    offlineSupport: boolean
    batchEvents: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeatureFlagsCountAggregateOutputType | null
    _min: FeatureFlagsMinAggregateOutputType | null
    _max: FeatureFlagsMaxAggregateOutputType | null
  }

  type GetFeatureFlagsGroupByPayload<T extends FeatureFlagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureFlagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureFlagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureFlagsGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureFlagsGroupByOutputType[P]>
        }
      >
    >


  export type FeatureFlagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureFlags"]>

  export type FeatureFlagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureFlags"]>

  export type FeatureFlagsSelectScalar = {
    id?: boolean
    projectId?: boolean
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureFlagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FeatureFlagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $FeatureFlagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureFlags"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      sdkEnabled: boolean
      apiTracking: boolean
      screenTracking: boolean
      crashReporting: boolean
      logging: boolean
      deviceTracking: boolean
      sessionTracking: boolean
      businessConfig: boolean
      localization: boolean
      offlineSupport: boolean
      batchEvents: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureFlags"]>
    composites: {}
  }

  type FeatureFlagsGetPayload<S extends boolean | null | undefined | FeatureFlagsDefaultArgs> = $Result.GetResult<Prisma.$FeatureFlagsPayload, S>

  type FeatureFlagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeatureFlagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeatureFlagsCountAggregateInputType | true
    }

  export interface FeatureFlagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureFlags'], meta: { name: 'FeatureFlags' } }
    /**
     * Find zero or one FeatureFlags that matches the filter.
     * @param {FeatureFlagsFindUniqueArgs} args - Arguments to find a FeatureFlags
     * @example
     * // Get one FeatureFlags
     * const featureFlags = await prisma.featureFlags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFlagsFindUniqueArgs>(args: SelectSubset<T, FeatureFlagsFindUniqueArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeatureFlags that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeatureFlagsFindUniqueOrThrowArgs} args - Arguments to find a FeatureFlags
     * @example
     * // Get one FeatureFlags
     * const featureFlags = await prisma.featureFlags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFlagsFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFlagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsFindFirstArgs} args - Arguments to find a FeatureFlags
     * @example
     * // Get one FeatureFlags
     * const featureFlags = await prisma.featureFlags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFlagsFindFirstArgs>(args?: SelectSubset<T, FeatureFlagsFindFirstArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeatureFlags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsFindFirstOrThrowArgs} args - Arguments to find a FeatureFlags
     * @example
     * // Get one FeatureFlags
     * const featureFlags = await prisma.featureFlags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFlagsFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFlagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureFlags
     * const featureFlags = await prisma.featureFlags.findMany()
     * 
     * // Get first 10 FeatureFlags
     * const featureFlags = await prisma.featureFlags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureFlagsWithIdOnly = await prisma.featureFlags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFlagsFindManyArgs>(args?: SelectSubset<T, FeatureFlagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeatureFlags.
     * @param {FeatureFlagsCreateArgs} args - Arguments to create a FeatureFlags.
     * @example
     * // Create one FeatureFlags
     * const FeatureFlags = await prisma.featureFlags.create({
     *   data: {
     *     // ... data to create a FeatureFlags
     *   }
     * })
     * 
     */
    create<T extends FeatureFlagsCreateArgs>(args: SelectSubset<T, FeatureFlagsCreateArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeatureFlags.
     * @param {FeatureFlagsCreateManyArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlags = await prisma.featureFlags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureFlagsCreateManyArgs>(args?: SelectSubset<T, FeatureFlagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureFlags and returns the data saved in the database.
     * @param {FeatureFlagsCreateManyAndReturnArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlags = await prisma.featureFlags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureFlags and only return the `id`
     * const featureFlagsWithIdOnly = await prisma.featureFlags.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureFlagsCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureFlagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeatureFlags.
     * @param {FeatureFlagsDeleteArgs} args - Arguments to delete one FeatureFlags.
     * @example
     * // Delete one FeatureFlags
     * const FeatureFlags = await prisma.featureFlags.delete({
     *   where: {
     *     // ... filter to delete one FeatureFlags
     *   }
     * })
     * 
     */
    delete<T extends FeatureFlagsDeleteArgs>(args: SelectSubset<T, FeatureFlagsDeleteArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeatureFlags.
     * @param {FeatureFlagsUpdateArgs} args - Arguments to update one FeatureFlags.
     * @example
     * // Update one FeatureFlags
     * const featureFlags = await prisma.featureFlags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureFlagsUpdateArgs>(args: SelectSubset<T, FeatureFlagsUpdateArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeatureFlags.
     * @param {FeatureFlagsDeleteManyArgs} args - Arguments to filter FeatureFlags to delete.
     * @example
     * // Delete a few FeatureFlags
     * const { count } = await prisma.featureFlags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureFlagsDeleteManyArgs>(args?: SelectSubset<T, FeatureFlagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureFlags
     * const featureFlags = await prisma.featureFlags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureFlagsUpdateManyArgs>(args: SelectSubset<T, FeatureFlagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeatureFlags.
     * @param {FeatureFlagsUpsertArgs} args - Arguments to update or create a FeatureFlags.
     * @example
     * // Update or create a FeatureFlags
     * const featureFlags = await prisma.featureFlags.upsert({
     *   create: {
     *     // ... data to create a FeatureFlags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureFlags we want to update
     *   }
     * })
     */
    upsert<T extends FeatureFlagsUpsertArgs>(args: SelectSubset<T, FeatureFlagsUpsertArgs<ExtArgs>>): Prisma__FeatureFlagsClient<$Result.GetResult<Prisma.$FeatureFlagsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsCountArgs} args - Arguments to filter FeatureFlags to count.
     * @example
     * // Count the number of FeatureFlags
     * const count = await prisma.featureFlags.count({
     *   where: {
     *     // ... the filter for the FeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends FeatureFlagsCountArgs>(
      args?: Subset<T, FeatureFlagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureFlagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureFlagsAggregateArgs>(args: Subset<T, FeatureFlagsAggregateArgs>): Prisma.PrismaPromise<GetFeatureFlagsAggregateType<T>>

    /**
     * Group by FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureFlagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureFlagsGroupByArgs['orderBy'] }
        : { orderBy?: FeatureFlagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureFlagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureFlagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureFlags model
   */
  readonly fields: FeatureFlagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureFlags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureFlagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureFlags model
   */ 
  interface FeatureFlagsFieldRefs {
    readonly id: FieldRef<"FeatureFlags", 'String'>
    readonly projectId: FieldRef<"FeatureFlags", 'String'>
    readonly sdkEnabled: FieldRef<"FeatureFlags", 'Boolean'>
    readonly apiTracking: FieldRef<"FeatureFlags", 'Boolean'>
    readonly screenTracking: FieldRef<"FeatureFlags", 'Boolean'>
    readonly crashReporting: FieldRef<"FeatureFlags", 'Boolean'>
    readonly logging: FieldRef<"FeatureFlags", 'Boolean'>
    readonly deviceTracking: FieldRef<"FeatureFlags", 'Boolean'>
    readonly sessionTracking: FieldRef<"FeatureFlags", 'Boolean'>
    readonly businessConfig: FieldRef<"FeatureFlags", 'Boolean'>
    readonly localization: FieldRef<"FeatureFlags", 'Boolean'>
    readonly offlineSupport: FieldRef<"FeatureFlags", 'Boolean'>
    readonly batchEvents: FieldRef<"FeatureFlags", 'Boolean'>
    readonly createdAt: FieldRef<"FeatureFlags", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureFlags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureFlags findUnique
   */
  export type FeatureFlagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where: FeatureFlagsWhereUniqueInput
  }

  /**
   * FeatureFlags findUniqueOrThrow
   */
  export type FeatureFlagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where: FeatureFlagsWhereUniqueInput
  }

  /**
   * FeatureFlags findFirst
   */
  export type FeatureFlagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagsOrderByWithRelationInput | FeatureFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagsScalarFieldEnum | FeatureFlagsScalarFieldEnum[]
  }

  /**
   * FeatureFlags findFirstOrThrow
   */
  export type FeatureFlagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagsOrderByWithRelationInput | FeatureFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagsScalarFieldEnum | FeatureFlagsScalarFieldEnum[]
  }

  /**
   * FeatureFlags findMany
   */
  export type FeatureFlagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagsOrderByWithRelationInput | FeatureFlagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureFlags.
     */
    cursor?: FeatureFlagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    distinct?: FeatureFlagsScalarFieldEnum | FeatureFlagsScalarFieldEnum[]
  }

  /**
   * FeatureFlags create
   */
  export type FeatureFlagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureFlags.
     */
    data: XOR<FeatureFlagsCreateInput, FeatureFlagsUncheckedCreateInput>
  }

  /**
   * FeatureFlags createMany
   */
  export type FeatureFlagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagsCreateManyInput | FeatureFlagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlags createManyAndReturn
   */
  export type FeatureFlagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagsCreateManyInput | FeatureFlagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureFlags update
   */
  export type FeatureFlagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureFlags.
     */
    data: XOR<FeatureFlagsUpdateInput, FeatureFlagsUncheckedUpdateInput>
    /**
     * Choose, which FeatureFlags to update.
     */
    where: FeatureFlagsWhereUniqueInput
  }

  /**
   * FeatureFlags updateMany
   */
  export type FeatureFlagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagsUpdateManyMutationInput, FeatureFlagsUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagsWhereInput
  }

  /**
   * FeatureFlags upsert
   */
  export type FeatureFlagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureFlags to update in case it exists.
     */
    where: FeatureFlagsWhereUniqueInput
    /**
     * In case the FeatureFlags found by the `where` argument doesn't exist, create a new FeatureFlags with this data.
     */
    create: XOR<FeatureFlagsCreateInput, FeatureFlagsUncheckedCreateInput>
    /**
     * In case the FeatureFlags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureFlagsUpdateInput, FeatureFlagsUncheckedUpdateInput>
  }

  /**
   * FeatureFlags delete
   */
  export type FeatureFlagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
    /**
     * Filter which FeatureFlags to delete.
     */
    where: FeatureFlagsWhereUniqueInput
  }

  /**
   * FeatureFlags deleteMany
   */
  export type FeatureFlagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to delete
     */
    where?: FeatureFlagsWhereInput
  }

  /**
   * FeatureFlags without action
   */
  export type FeatureFlagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlags
     */
    select?: FeatureFlagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureFlagsInclude<ExtArgs> | null
  }


  /**
   * Model SdkSettings
   */

  export type AggregateSdkSettings = {
    _count: SdkSettingsCountAggregateOutputType | null
    _avg: SdkSettingsAvgAggregateOutputType | null
    _sum: SdkSettingsSumAggregateOutputType | null
    _min: SdkSettingsMinAggregateOutputType | null
    _max: SdkSettingsMaxAggregateOutputType | null
  }

  export type SdkSettingsAvgAggregateOutputType = {
    maxLogQueueSize: number | null
    maxTraceQueueSize: number | null
    flushIntervalSeconds: number | null
  }

  export type SdkSettingsSumAggregateOutputType = {
    maxLogQueueSize: number | null
    maxTraceQueueSize: number | null
    flushIntervalSeconds: number | null
  }

  export type SdkSettingsMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    trackingMode: string | null
    captureRequestBodies: boolean | null
    captureResponseBodies: boolean | null
    capturePrintStatements: boolean | null
    sanitizeSensitiveData: boolean | null
    maxLogQueueSize: number | null
    maxTraceQueueSize: number | null
    flushIntervalSeconds: number | null
    enableBatching: boolean | null
    minLogLevel: string | null
    verboseErrors: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SdkSettingsMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    trackingMode: string | null
    captureRequestBodies: boolean | null
    captureResponseBodies: boolean | null
    capturePrintStatements: boolean | null
    sanitizeSensitiveData: boolean | null
    maxLogQueueSize: number | null
    maxTraceQueueSize: number | null
    flushIntervalSeconds: number | null
    enableBatching: boolean | null
    minLogLevel: string | null
    verboseErrors: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SdkSettingsCountAggregateOutputType = {
    id: number
    projectId: number
    trackingMode: number
    captureRequestBodies: number
    captureResponseBodies: number
    capturePrintStatements: number
    sanitizeSensitiveData: number
    sensitiveFieldPatterns: number
    maxLogQueueSize: number
    maxTraceQueueSize: number
    flushIntervalSeconds: number
    enableBatching: number
    minLogLevel: number
    verboseErrors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SdkSettingsAvgAggregateInputType = {
    maxLogQueueSize?: true
    maxTraceQueueSize?: true
    flushIntervalSeconds?: true
  }

  export type SdkSettingsSumAggregateInputType = {
    maxLogQueueSize?: true
    maxTraceQueueSize?: true
    flushIntervalSeconds?: true
  }

  export type SdkSettingsMinAggregateInputType = {
    id?: true
    projectId?: true
    trackingMode?: true
    captureRequestBodies?: true
    captureResponseBodies?: true
    capturePrintStatements?: true
    sanitizeSensitiveData?: true
    maxLogQueueSize?: true
    maxTraceQueueSize?: true
    flushIntervalSeconds?: true
    enableBatching?: true
    minLogLevel?: true
    verboseErrors?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SdkSettingsMaxAggregateInputType = {
    id?: true
    projectId?: true
    trackingMode?: true
    captureRequestBodies?: true
    captureResponseBodies?: true
    capturePrintStatements?: true
    sanitizeSensitiveData?: true
    maxLogQueueSize?: true
    maxTraceQueueSize?: true
    flushIntervalSeconds?: true
    enableBatching?: true
    minLogLevel?: true
    verboseErrors?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SdkSettingsCountAggregateInputType = {
    id?: true
    projectId?: true
    trackingMode?: true
    captureRequestBodies?: true
    captureResponseBodies?: true
    capturePrintStatements?: true
    sanitizeSensitiveData?: true
    sensitiveFieldPatterns?: true
    maxLogQueueSize?: true
    maxTraceQueueSize?: true
    flushIntervalSeconds?: true
    enableBatching?: true
    minLogLevel?: true
    verboseErrors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SdkSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SdkSettings to aggregate.
     */
    where?: SdkSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdkSettings to fetch.
     */
    orderBy?: SdkSettingsOrderByWithRelationInput | SdkSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SdkSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdkSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdkSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SdkSettings
    **/
    _count?: true | SdkSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SdkSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SdkSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SdkSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SdkSettingsMaxAggregateInputType
  }

  export type GetSdkSettingsAggregateType<T extends SdkSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSdkSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSdkSettings[P]>
      : GetScalarType<T[P], AggregateSdkSettings[P]>
  }




  export type SdkSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SdkSettingsWhereInput
    orderBy?: SdkSettingsOrderByWithAggregationInput | SdkSettingsOrderByWithAggregationInput[]
    by: SdkSettingsScalarFieldEnum[] | SdkSettingsScalarFieldEnum
    having?: SdkSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SdkSettingsCountAggregateInputType | true
    _avg?: SdkSettingsAvgAggregateInputType
    _sum?: SdkSettingsSumAggregateInputType
    _min?: SdkSettingsMinAggregateInputType
    _max?: SdkSettingsMaxAggregateInputType
  }

  export type SdkSettingsGroupByOutputType = {
    id: string
    projectId: string
    trackingMode: string
    captureRequestBodies: boolean
    captureResponseBodies: boolean
    capturePrintStatements: boolean
    sanitizeSensitiveData: boolean
    sensitiveFieldPatterns: string[]
    maxLogQueueSize: number
    maxTraceQueueSize: number
    flushIntervalSeconds: number
    enableBatching: boolean
    minLogLevel: string
    verboseErrors: boolean
    createdAt: Date
    updatedAt: Date
    _count: SdkSettingsCountAggregateOutputType | null
    _avg: SdkSettingsAvgAggregateOutputType | null
    _sum: SdkSettingsSumAggregateOutputType | null
    _min: SdkSettingsMinAggregateOutputType | null
    _max: SdkSettingsMaxAggregateOutputType | null
  }

  type GetSdkSettingsGroupByPayload<T extends SdkSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SdkSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SdkSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SdkSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SdkSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SdkSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    trackingMode?: boolean
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: boolean
    maxLogQueueSize?: boolean
    maxTraceQueueSize?: boolean
    flushIntervalSeconds?: boolean
    enableBatching?: boolean
    minLogLevel?: boolean
    verboseErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sdkSettings"]>

  export type SdkSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    trackingMode?: boolean
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: boolean
    maxLogQueueSize?: boolean
    maxTraceQueueSize?: boolean
    flushIntervalSeconds?: boolean
    enableBatching?: boolean
    minLogLevel?: boolean
    verboseErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sdkSettings"]>

  export type SdkSettingsSelectScalar = {
    id?: boolean
    projectId?: boolean
    trackingMode?: boolean
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: boolean
    maxLogQueueSize?: boolean
    maxTraceQueueSize?: boolean
    flushIntervalSeconds?: boolean
    enableBatching?: boolean
    minLogLevel?: boolean
    verboseErrors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SdkSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SdkSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SdkSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SdkSettings"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      trackingMode: string
      captureRequestBodies: boolean
      captureResponseBodies: boolean
      capturePrintStatements: boolean
      sanitizeSensitiveData: boolean
      sensitiveFieldPatterns: string[]
      maxLogQueueSize: number
      maxTraceQueueSize: number
      flushIntervalSeconds: number
      enableBatching: boolean
      minLogLevel: string
      verboseErrors: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sdkSettings"]>
    composites: {}
  }

  type SdkSettingsGetPayload<S extends boolean | null | undefined | SdkSettingsDefaultArgs> = $Result.GetResult<Prisma.$SdkSettingsPayload, S>

  type SdkSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SdkSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SdkSettingsCountAggregateInputType | true
    }

  export interface SdkSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SdkSettings'], meta: { name: 'SdkSettings' } }
    /**
     * Find zero or one SdkSettings that matches the filter.
     * @param {SdkSettingsFindUniqueArgs} args - Arguments to find a SdkSettings
     * @example
     * // Get one SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SdkSettingsFindUniqueArgs>(args: SelectSubset<T, SdkSettingsFindUniqueArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SdkSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SdkSettingsFindUniqueOrThrowArgs} args - Arguments to find a SdkSettings
     * @example
     * // Get one SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SdkSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SdkSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SdkSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsFindFirstArgs} args - Arguments to find a SdkSettings
     * @example
     * // Get one SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SdkSettingsFindFirstArgs>(args?: SelectSubset<T, SdkSettingsFindFirstArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SdkSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsFindFirstOrThrowArgs} args - Arguments to find a SdkSettings
     * @example
     * // Get one SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SdkSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SdkSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SdkSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findMany()
     * 
     * // Get first 10 SdkSettings
     * const sdkSettings = await prisma.sdkSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sdkSettingsWithIdOnly = await prisma.sdkSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SdkSettingsFindManyArgs>(args?: SelectSubset<T, SdkSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SdkSettings.
     * @param {SdkSettingsCreateArgs} args - Arguments to create a SdkSettings.
     * @example
     * // Create one SdkSettings
     * const SdkSettings = await prisma.sdkSettings.create({
     *   data: {
     *     // ... data to create a SdkSettings
     *   }
     * })
     * 
     */
    create<T extends SdkSettingsCreateArgs>(args: SelectSubset<T, SdkSettingsCreateArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SdkSettings.
     * @param {SdkSettingsCreateManyArgs} args - Arguments to create many SdkSettings.
     * @example
     * // Create many SdkSettings
     * const sdkSettings = await prisma.sdkSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SdkSettingsCreateManyArgs>(args?: SelectSubset<T, SdkSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SdkSettings and returns the data saved in the database.
     * @param {SdkSettingsCreateManyAndReturnArgs} args - Arguments to create many SdkSettings.
     * @example
     * // Create many SdkSettings
     * const sdkSettings = await prisma.sdkSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SdkSettings and only return the `id`
     * const sdkSettingsWithIdOnly = await prisma.sdkSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SdkSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SdkSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SdkSettings.
     * @param {SdkSettingsDeleteArgs} args - Arguments to delete one SdkSettings.
     * @example
     * // Delete one SdkSettings
     * const SdkSettings = await prisma.sdkSettings.delete({
     *   where: {
     *     // ... filter to delete one SdkSettings
     *   }
     * })
     * 
     */
    delete<T extends SdkSettingsDeleteArgs>(args: SelectSubset<T, SdkSettingsDeleteArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SdkSettings.
     * @param {SdkSettingsUpdateArgs} args - Arguments to update one SdkSettings.
     * @example
     * // Update one SdkSettings
     * const sdkSettings = await prisma.sdkSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SdkSettingsUpdateArgs>(args: SelectSubset<T, SdkSettingsUpdateArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SdkSettings.
     * @param {SdkSettingsDeleteManyArgs} args - Arguments to filter SdkSettings to delete.
     * @example
     * // Delete a few SdkSettings
     * const { count } = await prisma.sdkSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SdkSettingsDeleteManyArgs>(args?: SelectSubset<T, SdkSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SdkSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SdkSettings
     * const sdkSettings = await prisma.sdkSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SdkSettingsUpdateManyArgs>(args: SelectSubset<T, SdkSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SdkSettings.
     * @param {SdkSettingsUpsertArgs} args - Arguments to update or create a SdkSettings.
     * @example
     * // Update or create a SdkSettings
     * const sdkSettings = await prisma.sdkSettings.upsert({
     *   create: {
     *     // ... data to create a SdkSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SdkSettings we want to update
     *   }
     * })
     */
    upsert<T extends SdkSettingsUpsertArgs>(args: SelectSubset<T, SdkSettingsUpsertArgs<ExtArgs>>): Prisma__SdkSettingsClient<$Result.GetResult<Prisma.$SdkSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SdkSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsCountArgs} args - Arguments to filter SdkSettings to count.
     * @example
     * // Count the number of SdkSettings
     * const count = await prisma.sdkSettings.count({
     *   where: {
     *     // ... the filter for the SdkSettings we want to count
     *   }
     * })
    **/
    count<T extends SdkSettingsCountArgs>(
      args?: Subset<T, SdkSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SdkSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SdkSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SdkSettingsAggregateArgs>(args: Subset<T, SdkSettingsAggregateArgs>): Prisma.PrismaPromise<GetSdkSettingsAggregateType<T>>

    /**
     * Group by SdkSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SdkSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SdkSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SdkSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SdkSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SdkSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSdkSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SdkSettings model
   */
  readonly fields: SdkSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SdkSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SdkSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SdkSettings model
   */ 
  interface SdkSettingsFieldRefs {
    readonly id: FieldRef<"SdkSettings", 'String'>
    readonly projectId: FieldRef<"SdkSettings", 'String'>
    readonly trackingMode: FieldRef<"SdkSettings", 'String'>
    readonly captureRequestBodies: FieldRef<"SdkSettings", 'Boolean'>
    readonly captureResponseBodies: FieldRef<"SdkSettings", 'Boolean'>
    readonly capturePrintStatements: FieldRef<"SdkSettings", 'Boolean'>
    readonly sanitizeSensitiveData: FieldRef<"SdkSettings", 'Boolean'>
    readonly sensitiveFieldPatterns: FieldRef<"SdkSettings", 'String[]'>
    readonly maxLogQueueSize: FieldRef<"SdkSettings", 'Int'>
    readonly maxTraceQueueSize: FieldRef<"SdkSettings", 'Int'>
    readonly flushIntervalSeconds: FieldRef<"SdkSettings", 'Int'>
    readonly enableBatching: FieldRef<"SdkSettings", 'Boolean'>
    readonly minLogLevel: FieldRef<"SdkSettings", 'String'>
    readonly verboseErrors: FieldRef<"SdkSettings", 'Boolean'>
    readonly createdAt: FieldRef<"SdkSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SdkSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SdkSettings findUnique
   */
  export type SdkSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SdkSettings to fetch.
     */
    where: SdkSettingsWhereUniqueInput
  }

  /**
   * SdkSettings findUniqueOrThrow
   */
  export type SdkSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SdkSettings to fetch.
     */
    where: SdkSettingsWhereUniqueInput
  }

  /**
   * SdkSettings findFirst
   */
  export type SdkSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SdkSettings to fetch.
     */
    where?: SdkSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdkSettings to fetch.
     */
    orderBy?: SdkSettingsOrderByWithRelationInput | SdkSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SdkSettings.
     */
    cursor?: SdkSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdkSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdkSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SdkSettings.
     */
    distinct?: SdkSettingsScalarFieldEnum | SdkSettingsScalarFieldEnum[]
  }

  /**
   * SdkSettings findFirstOrThrow
   */
  export type SdkSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SdkSettings to fetch.
     */
    where?: SdkSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdkSettings to fetch.
     */
    orderBy?: SdkSettingsOrderByWithRelationInput | SdkSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SdkSettings.
     */
    cursor?: SdkSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdkSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdkSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SdkSettings.
     */
    distinct?: SdkSettingsScalarFieldEnum | SdkSettingsScalarFieldEnum[]
  }

  /**
   * SdkSettings findMany
   */
  export type SdkSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter, which SdkSettings to fetch.
     */
    where?: SdkSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SdkSettings to fetch.
     */
    orderBy?: SdkSettingsOrderByWithRelationInput | SdkSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SdkSettings.
     */
    cursor?: SdkSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SdkSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SdkSettings.
     */
    skip?: number
    distinct?: SdkSettingsScalarFieldEnum | SdkSettingsScalarFieldEnum[]
  }

  /**
   * SdkSettings create
   */
  export type SdkSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a SdkSettings.
     */
    data: XOR<SdkSettingsCreateInput, SdkSettingsUncheckedCreateInput>
  }

  /**
   * SdkSettings createMany
   */
  export type SdkSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SdkSettings.
     */
    data: SdkSettingsCreateManyInput | SdkSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SdkSettings createManyAndReturn
   */
  export type SdkSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SdkSettings.
     */
    data: SdkSettingsCreateManyInput | SdkSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SdkSettings update
   */
  export type SdkSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a SdkSettings.
     */
    data: XOR<SdkSettingsUpdateInput, SdkSettingsUncheckedUpdateInput>
    /**
     * Choose, which SdkSettings to update.
     */
    where: SdkSettingsWhereUniqueInput
  }

  /**
   * SdkSettings updateMany
   */
  export type SdkSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SdkSettings.
     */
    data: XOR<SdkSettingsUpdateManyMutationInput, SdkSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SdkSettings to update
     */
    where?: SdkSettingsWhereInput
  }

  /**
   * SdkSettings upsert
   */
  export type SdkSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the SdkSettings to update in case it exists.
     */
    where: SdkSettingsWhereUniqueInput
    /**
     * In case the SdkSettings found by the `where` argument doesn't exist, create a new SdkSettings with this data.
     */
    create: XOR<SdkSettingsCreateInput, SdkSettingsUncheckedCreateInput>
    /**
     * In case the SdkSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SdkSettingsUpdateInput, SdkSettingsUncheckedUpdateInput>
  }

  /**
   * SdkSettings delete
   */
  export type SdkSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
    /**
     * Filter which SdkSettings to delete.
     */
    where: SdkSettingsWhereUniqueInput
  }

  /**
   * SdkSettings deleteMany
   */
  export type SdkSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SdkSettings to delete
     */
    where?: SdkSettingsWhereInput
  }

  /**
   * SdkSettings without action
   */
  export type SdkSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SdkSettings
     */
    select?: SdkSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SdkSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ConfigCategory
   */

  export type AggregateConfigCategory = {
    _count: ConfigCategoryCountAggregateOutputType | null
    _avg: ConfigCategoryAvgAggregateOutputType | null
    _sum: ConfigCategorySumAggregateOutputType | null
    _min: ConfigCategoryMinAggregateOutputType | null
    _max: ConfigCategoryMaxAggregateOutputType | null
  }

  export type ConfigCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type ConfigCategorySumAggregateOutputType = {
    order: number | null
  }

  export type ConfigCategoryMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    label: string | null
    description: string | null
    icon: string | null
    order: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigCategoryMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    label: string | null
    description: string | null
    icon: string | null
    order: number | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigCategoryCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    label: number
    description: number
    icon: number
    order: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigCategoryAvgAggregateInputType = {
    order?: true
  }

  export type ConfigCategorySumAggregateInputType = {
    order?: true
  }

  export type ConfigCategoryMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    label?: true
    description?: true
    icon?: true
    order?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigCategoryMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    label?: true
    description?: true
    icon?: true
    order?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigCategoryCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    label?: true
    description?: true
    icon?: true
    order?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigCategory to aggregate.
     */
    where?: ConfigCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigCategories to fetch.
     */
    orderBy?: ConfigCategoryOrderByWithRelationInput | ConfigCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigCategories
    **/
    _count?: true | ConfigCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigCategoryMaxAggregateInputType
  }

  export type GetConfigCategoryAggregateType<T extends ConfigCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigCategory[P]>
      : GetScalarType<T[P], AggregateConfigCategory[P]>
  }




  export type ConfigCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigCategoryWhereInput
    orderBy?: ConfigCategoryOrderByWithAggregationInput | ConfigCategoryOrderByWithAggregationInput[]
    by: ConfigCategoryScalarFieldEnum[] | ConfigCategoryScalarFieldEnum
    having?: ConfigCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCategoryCountAggregateInputType | true
    _avg?: ConfigCategoryAvgAggregateInputType
    _sum?: ConfigCategorySumAggregateInputType
    _min?: ConfigCategoryMinAggregateInputType
    _max?: ConfigCategoryMaxAggregateInputType
  }

  export type ConfigCategoryGroupByOutputType = {
    id: string
    projectId: string
    name: string
    label: string | null
    description: string | null
    icon: string | null
    order: number
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConfigCategoryCountAggregateOutputType | null
    _avg: ConfigCategoryAvgAggregateOutputType | null
    _sum: ConfigCategorySumAggregateOutputType | null
    _min: ConfigCategoryMinAggregateOutputType | null
    _max: ConfigCategoryMaxAggregateOutputType | null
  }

  type GetConfigCategoryGroupByPayload<T extends ConfigCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ConfigCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configCategory"]>

  export type ConfigCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configCategory"]>

  export type ConfigCategorySelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    label?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ConfigCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ConfigCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigCategory"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      label: string | null
      description: string | null
      icon: string | null
      order: number
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configCategory"]>
    composites: {}
  }

  type ConfigCategoryGetPayload<S extends boolean | null | undefined | ConfigCategoryDefaultArgs> = $Result.GetResult<Prisma.$ConfigCategoryPayload, S>

  type ConfigCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigCategoryCountAggregateInputType | true
    }

  export interface ConfigCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigCategory'], meta: { name: 'ConfigCategory' } }
    /**
     * Find zero or one ConfigCategory that matches the filter.
     * @param {ConfigCategoryFindUniqueArgs} args - Arguments to find a ConfigCategory
     * @example
     * // Get one ConfigCategory
     * const configCategory = await prisma.configCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigCategoryFindUniqueArgs>(args: SelectSubset<T, ConfigCategoryFindUniqueArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfigCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigCategoryFindUniqueOrThrowArgs} args - Arguments to find a ConfigCategory
     * @example
     * // Get one ConfigCategory
     * const configCategory = await prisma.configCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfigCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryFindFirstArgs} args - Arguments to find a ConfigCategory
     * @example
     * // Get one ConfigCategory
     * const configCategory = await prisma.configCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigCategoryFindFirstArgs>(args?: SelectSubset<T, ConfigCategoryFindFirstArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfigCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryFindFirstOrThrowArgs} args - Arguments to find a ConfigCategory
     * @example
     * // Get one ConfigCategory
     * const configCategory = await prisma.configCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfigCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigCategories
     * const configCategories = await prisma.configCategory.findMany()
     * 
     * // Get first 10 ConfigCategories
     * const configCategories = await prisma.configCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configCategoryWithIdOnly = await prisma.configCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigCategoryFindManyArgs>(args?: SelectSubset<T, ConfigCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfigCategory.
     * @param {ConfigCategoryCreateArgs} args - Arguments to create a ConfigCategory.
     * @example
     * // Create one ConfigCategory
     * const ConfigCategory = await prisma.configCategory.create({
     *   data: {
     *     // ... data to create a ConfigCategory
     *   }
     * })
     * 
     */
    create<T extends ConfigCategoryCreateArgs>(args: SelectSubset<T, ConfigCategoryCreateArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfigCategories.
     * @param {ConfigCategoryCreateManyArgs} args - Arguments to create many ConfigCategories.
     * @example
     * // Create many ConfigCategories
     * const configCategory = await prisma.configCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigCategoryCreateManyArgs>(args?: SelectSubset<T, ConfigCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigCategories and returns the data saved in the database.
     * @param {ConfigCategoryCreateManyAndReturnArgs} args - Arguments to create many ConfigCategories.
     * @example
     * // Create many ConfigCategories
     * const configCategory = await prisma.configCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigCategories and only return the `id`
     * const configCategoryWithIdOnly = await prisma.configCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfigCategory.
     * @param {ConfigCategoryDeleteArgs} args - Arguments to delete one ConfigCategory.
     * @example
     * // Delete one ConfigCategory
     * const ConfigCategory = await prisma.configCategory.delete({
     *   where: {
     *     // ... filter to delete one ConfigCategory
     *   }
     * })
     * 
     */
    delete<T extends ConfigCategoryDeleteArgs>(args: SelectSubset<T, ConfigCategoryDeleteArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfigCategory.
     * @param {ConfigCategoryUpdateArgs} args - Arguments to update one ConfigCategory.
     * @example
     * // Update one ConfigCategory
     * const configCategory = await prisma.configCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigCategoryUpdateArgs>(args: SelectSubset<T, ConfigCategoryUpdateArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfigCategories.
     * @param {ConfigCategoryDeleteManyArgs} args - Arguments to filter ConfigCategories to delete.
     * @example
     * // Delete a few ConfigCategories
     * const { count } = await prisma.configCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigCategoryDeleteManyArgs>(args?: SelectSubset<T, ConfigCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigCategories
     * const configCategory = await prisma.configCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigCategoryUpdateManyArgs>(args: SelectSubset<T, ConfigCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigCategory.
     * @param {ConfigCategoryUpsertArgs} args - Arguments to update or create a ConfigCategory.
     * @example
     * // Update or create a ConfigCategory
     * const configCategory = await prisma.configCategory.upsert({
     *   create: {
     *     // ... data to create a ConfigCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigCategory we want to update
     *   }
     * })
     */
    upsert<T extends ConfigCategoryUpsertArgs>(args: SelectSubset<T, ConfigCategoryUpsertArgs<ExtArgs>>): Prisma__ConfigCategoryClient<$Result.GetResult<Prisma.$ConfigCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfigCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryCountArgs} args - Arguments to filter ConfigCategories to count.
     * @example
     * // Count the number of ConfigCategories
     * const count = await prisma.configCategory.count({
     *   where: {
     *     // ... the filter for the ConfigCategories we want to count
     *   }
     * })
    **/
    count<T extends ConfigCategoryCountArgs>(
      args?: Subset<T, ConfigCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigCategoryAggregateArgs>(args: Subset<T, ConfigCategoryAggregateArgs>): Prisma.PrismaPromise<GetConfigCategoryAggregateType<T>>

    /**
     * Group by ConfigCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ConfigCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigCategory model
   */
  readonly fields: ConfigCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigCategory model
   */ 
  interface ConfigCategoryFieldRefs {
    readonly id: FieldRef<"ConfigCategory", 'String'>
    readonly projectId: FieldRef<"ConfigCategory", 'String'>
    readonly name: FieldRef<"ConfigCategory", 'String'>
    readonly label: FieldRef<"ConfigCategory", 'String'>
    readonly description: FieldRef<"ConfigCategory", 'String'>
    readonly icon: FieldRef<"ConfigCategory", 'String'>
    readonly order: FieldRef<"ConfigCategory", 'Int'>
    readonly isEnabled: FieldRef<"ConfigCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ConfigCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfigCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigCategory findUnique
   */
  export type ConfigCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigCategory to fetch.
     */
    where: ConfigCategoryWhereUniqueInput
  }

  /**
   * ConfigCategory findUniqueOrThrow
   */
  export type ConfigCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigCategory to fetch.
     */
    where: ConfigCategoryWhereUniqueInput
  }

  /**
   * ConfigCategory findFirst
   */
  export type ConfigCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigCategory to fetch.
     */
    where?: ConfigCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigCategories to fetch.
     */
    orderBy?: ConfigCategoryOrderByWithRelationInput | ConfigCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigCategories.
     */
    cursor?: ConfigCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigCategories.
     */
    distinct?: ConfigCategoryScalarFieldEnum | ConfigCategoryScalarFieldEnum[]
  }

  /**
   * ConfigCategory findFirstOrThrow
   */
  export type ConfigCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigCategory to fetch.
     */
    where?: ConfigCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigCategories to fetch.
     */
    orderBy?: ConfigCategoryOrderByWithRelationInput | ConfigCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigCategories.
     */
    cursor?: ConfigCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigCategories.
     */
    distinct?: ConfigCategoryScalarFieldEnum | ConfigCategoryScalarFieldEnum[]
  }

  /**
   * ConfigCategory findMany
   */
  export type ConfigCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigCategories to fetch.
     */
    where?: ConfigCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigCategories to fetch.
     */
    orderBy?: ConfigCategoryOrderByWithRelationInput | ConfigCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigCategories.
     */
    cursor?: ConfigCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigCategories.
     */
    skip?: number
    distinct?: ConfigCategoryScalarFieldEnum | ConfigCategoryScalarFieldEnum[]
  }

  /**
   * ConfigCategory create
   */
  export type ConfigCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigCategory.
     */
    data: XOR<ConfigCategoryCreateInput, ConfigCategoryUncheckedCreateInput>
  }

  /**
   * ConfigCategory createMany
   */
  export type ConfigCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigCategories.
     */
    data: ConfigCategoryCreateManyInput | ConfigCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigCategory createManyAndReturn
   */
  export type ConfigCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfigCategories.
     */
    data: ConfigCategoryCreateManyInput | ConfigCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigCategory update
   */
  export type ConfigCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigCategory.
     */
    data: XOR<ConfigCategoryUpdateInput, ConfigCategoryUncheckedUpdateInput>
    /**
     * Choose, which ConfigCategory to update.
     */
    where: ConfigCategoryWhereUniqueInput
  }

  /**
   * ConfigCategory updateMany
   */
  export type ConfigCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigCategories.
     */
    data: XOR<ConfigCategoryUpdateManyMutationInput, ConfigCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ConfigCategories to update
     */
    where?: ConfigCategoryWhereInput
  }

  /**
   * ConfigCategory upsert
   */
  export type ConfigCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigCategory to update in case it exists.
     */
    where: ConfigCategoryWhereUniqueInput
    /**
     * In case the ConfigCategory found by the `where` argument doesn't exist, create a new ConfigCategory with this data.
     */
    create: XOR<ConfigCategoryCreateInput, ConfigCategoryUncheckedCreateInput>
    /**
     * In case the ConfigCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigCategoryUpdateInput, ConfigCategoryUncheckedUpdateInput>
  }

  /**
   * ConfigCategory delete
   */
  export type ConfigCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
    /**
     * Filter which ConfigCategory to delete.
     */
    where: ConfigCategoryWhereUniqueInput
  }

  /**
   * ConfigCategory deleteMany
   */
  export type ConfigCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigCategories to delete
     */
    where?: ConfigCategoryWhereInput
  }

  /**
   * ConfigCategory without action
   */
  export type ConfigCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCategory
     */
    select?: ConfigCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
    maxProjects: number | null
    maxDevices: number | null
    maxMockEndpoints: number | null
    maxApiEndpoints: number | null
    maxApiRequests: number | null
    maxLogs: number | null
    maxSessions: number | null
    maxCrashes: number | null
    maxBusinessConfigKeys: number | null
    maxLocalizationLanguages: number | null
    maxLocalizationKeys: number | null
    retentionDays: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
    maxProjects: number | null
    maxDevices: number | null
    maxMockEndpoints: number | null
    maxApiEndpoints: number | null
    maxApiRequests: number | null
    maxLogs: number | null
    maxSessions: number | null
    maxCrashes: number | null
    maxBusinessConfigKeys: number | null
    maxLocalizationLanguages: number | null
    maxLocalizationKeys: number | null
    retentionDays: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: string | null
    isActive: boolean | null
    isPublic: boolean | null
    maxProjects: number | null
    maxDevices: number | null
    maxMockEndpoints: number | null
    maxApiEndpoints: number | null
    maxApiRequests: number | null
    maxLogs: number | null
    maxSessions: number | null
    maxCrashes: number | null
    maxBusinessConfigKeys: number | null
    maxLocalizationLanguages: number | null
    maxLocalizationKeys: number | null
    retentionDays: number | null
    allowApiTracking: boolean | null
    allowScreenTracking: boolean | null
    allowCrashReporting: boolean | null
    allowLogging: boolean | null
    allowBusinessConfig: boolean | null
    allowLocalization: boolean | null
    allowCustomDomains: boolean | null
    allowWebhooks: boolean | null
    allowTeamMembers: boolean | null
    allowPrioritySupport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: string | null
    isActive: boolean | null
    isPublic: boolean | null
    maxProjects: number | null
    maxDevices: number | null
    maxMockEndpoints: number | null
    maxApiEndpoints: number | null
    maxApiRequests: number | null
    maxLogs: number | null
    maxSessions: number | null
    maxCrashes: number | null
    maxBusinessConfigKeys: number | null
    maxLocalizationLanguages: number | null
    maxLocalizationKeys: number | null
    retentionDays: number | null
    allowApiTracking: boolean | null
    allowScreenTracking: boolean | null
    allowCrashReporting: boolean | null
    allowLogging: boolean | null
    allowBusinessConfig: boolean | null
    allowLocalization: boolean | null
    allowCustomDomains: boolean | null
    allowWebhooks: boolean | null
    allowTeamMembers: boolean | null
    allowPrioritySupport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    price: number
    currency: number
    interval: number
    isActive: number
    isPublic: number
    maxProjects: number
    maxDevices: number
    maxMockEndpoints: number
    maxApiEndpoints: number
    maxApiRequests: number
    maxLogs: number
    maxSessions: number
    maxCrashes: number
    maxBusinessConfigKeys: number
    maxLocalizationLanguages: number
    maxLocalizationKeys: number
    retentionDays: number
    allowApiTracking: number
    allowScreenTracking: number
    allowCrashReporting: number
    allowLogging: number
    allowBusinessConfig: number
    allowLocalization: number
    allowCustomDomains: number
    allowWebhooks: number
    allowTeamMembers: number
    allowPrioritySupport: number
    features: number
    enforcementConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
    maxProjects?: true
    maxDevices?: true
    maxMockEndpoints?: true
    maxApiEndpoints?: true
    maxApiRequests?: true
    maxLogs?: true
    maxSessions?: true
    maxCrashes?: true
    maxBusinessConfigKeys?: true
    maxLocalizationLanguages?: true
    maxLocalizationKeys?: true
    retentionDays?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
    maxProjects?: true
    maxDevices?: true
    maxMockEndpoints?: true
    maxApiEndpoints?: true
    maxApiRequests?: true
    maxLogs?: true
    maxSessions?: true
    maxCrashes?: true
    maxBusinessConfigKeys?: true
    maxLocalizationLanguages?: true
    maxLocalizationKeys?: true
    retentionDays?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    isActive?: true
    isPublic?: true
    maxProjects?: true
    maxDevices?: true
    maxMockEndpoints?: true
    maxApiEndpoints?: true
    maxApiRequests?: true
    maxLogs?: true
    maxSessions?: true
    maxCrashes?: true
    maxBusinessConfigKeys?: true
    maxLocalizationLanguages?: true
    maxLocalizationKeys?: true
    retentionDays?: true
    allowApiTracking?: true
    allowScreenTracking?: true
    allowCrashReporting?: true
    allowLogging?: true
    allowBusinessConfig?: true
    allowLocalization?: true
    allowCustomDomains?: true
    allowWebhooks?: true
    allowTeamMembers?: true
    allowPrioritySupport?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    isActive?: true
    isPublic?: true
    maxProjects?: true
    maxDevices?: true
    maxMockEndpoints?: true
    maxApiEndpoints?: true
    maxApiRequests?: true
    maxLogs?: true
    maxSessions?: true
    maxCrashes?: true
    maxBusinessConfigKeys?: true
    maxLocalizationLanguages?: true
    maxLocalizationKeys?: true
    retentionDays?: true
    allowApiTracking?: true
    allowScreenTracking?: true
    allowCrashReporting?: true
    allowLogging?: true
    allowBusinessConfig?: true
    allowLocalization?: true
    allowCustomDomains?: true
    allowWebhooks?: true
    allowTeamMembers?: true
    allowPrioritySupport?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    isActive?: true
    isPublic?: true
    maxProjects?: true
    maxDevices?: true
    maxMockEndpoints?: true
    maxApiEndpoints?: true
    maxApiRequests?: true
    maxLogs?: true
    maxSessions?: true
    maxCrashes?: true
    maxBusinessConfigKeys?: true
    maxLocalizationLanguages?: true
    maxLocalizationKeys?: true
    retentionDays?: true
    allowApiTracking?: true
    allowScreenTracking?: true
    allowCrashReporting?: true
    allowLogging?: true
    allowBusinessConfig?: true
    allowLocalization?: true
    allowCustomDomains?: true
    allowWebhooks?: true
    allowTeamMembers?: true
    allowPrioritySupport?: true
    features?: true
    enforcementConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    price: number
    currency: string
    interval: string
    isActive: boolean
    isPublic: boolean
    maxProjects: number | null
    maxDevices: number | null
    maxMockEndpoints: number | null
    maxApiEndpoints: number | null
    maxApiRequests: number | null
    maxLogs: number | null
    maxSessions: number | null
    maxCrashes: number | null
    maxBusinessConfigKeys: number | null
    maxLocalizationLanguages: number | null
    maxLocalizationKeys: number | null
    retentionDays: number | null
    allowApiTracking: boolean
    allowScreenTracking: boolean
    allowCrashReporting: boolean
    allowLogging: boolean
    allowBusinessConfig: boolean
    allowLocalization: boolean
    allowCustomDomains: boolean
    allowWebhooks: boolean
    allowTeamMembers: boolean
    allowPrioritySupport: boolean
    features: JsonValue | null
    enforcementConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: boolean
    maxDevices?: boolean
    maxMockEndpoints?: boolean
    maxApiEndpoints?: boolean
    maxApiRequests?: boolean
    maxLogs?: boolean
    maxSessions?: boolean
    maxCrashes?: boolean
    maxBusinessConfigKeys?: boolean
    maxLocalizationLanguages?: boolean
    maxLocalizationKeys?: boolean
    retentionDays?: boolean
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: boolean
    enforcementConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: boolean
    maxDevices?: boolean
    maxMockEndpoints?: boolean
    maxApiEndpoints?: boolean
    maxApiRequests?: boolean
    maxLogs?: boolean
    maxSessions?: boolean
    maxCrashes?: boolean
    maxBusinessConfigKeys?: boolean
    maxLocalizationLanguages?: boolean
    maxLocalizationKeys?: boolean
    retentionDays?: boolean
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: boolean
    enforcementConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: boolean
    maxDevices?: boolean
    maxMockEndpoints?: boolean
    maxApiEndpoints?: boolean
    maxApiRequests?: boolean
    maxLogs?: boolean
    maxSessions?: boolean
    maxCrashes?: boolean
    maxBusinessConfigKeys?: boolean
    maxLocalizationLanguages?: boolean
    maxLocalizationKeys?: boolean
    retentionDays?: boolean
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: boolean
    enforcementConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      price: number
      currency: string
      interval: string
      isActive: boolean
      isPublic: boolean
      maxProjects: number | null
      maxDevices: number | null
      maxMockEndpoints: number | null
      maxApiEndpoints: number | null
      maxApiRequests: number | null
      maxLogs: number | null
      maxSessions: number | null
      maxCrashes: number | null
      maxBusinessConfigKeys: number | null
      maxLocalizationLanguages: number | null
      maxLocalizationKeys: number | null
      retentionDays: number | null
      allowApiTracking: boolean
      allowScreenTracking: boolean
      allowCrashReporting: boolean
      allowLogging: boolean
      allowBusinessConfig: boolean
      allowLocalization: boolean
      allowCustomDomains: boolean
      allowWebhooks: boolean
      allowTeamMembers: boolean
      allowPrioritySupport: boolean
      features: Prisma.JsonValue | null
      enforcementConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly displayName: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Float'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly interval: FieldRef<"Plan", 'String'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly isPublic: FieldRef<"Plan", 'Boolean'>
    readonly maxProjects: FieldRef<"Plan", 'Int'>
    readonly maxDevices: FieldRef<"Plan", 'Int'>
    readonly maxMockEndpoints: FieldRef<"Plan", 'Int'>
    readonly maxApiEndpoints: FieldRef<"Plan", 'Int'>
    readonly maxApiRequests: FieldRef<"Plan", 'Int'>
    readonly maxLogs: FieldRef<"Plan", 'Int'>
    readonly maxSessions: FieldRef<"Plan", 'Int'>
    readonly maxCrashes: FieldRef<"Plan", 'Int'>
    readonly maxBusinessConfigKeys: FieldRef<"Plan", 'Int'>
    readonly maxLocalizationLanguages: FieldRef<"Plan", 'Int'>
    readonly maxLocalizationKeys: FieldRef<"Plan", 'Int'>
    readonly retentionDays: FieldRef<"Plan", 'Int'>
    readonly allowApiTracking: FieldRef<"Plan", 'Boolean'>
    readonly allowScreenTracking: FieldRef<"Plan", 'Boolean'>
    readonly allowCrashReporting: FieldRef<"Plan", 'Boolean'>
    readonly allowLogging: FieldRef<"Plan", 'Boolean'>
    readonly allowBusinessConfig: FieldRef<"Plan", 'Boolean'>
    readonly allowLocalization: FieldRef<"Plan", 'Boolean'>
    readonly allowCustomDomains: FieldRef<"Plan", 'Boolean'>
    readonly allowWebhooks: FieldRef<"Plan", 'Boolean'>
    readonly allowTeamMembers: FieldRef<"Plan", 'Boolean'>
    readonly allowPrioritySupport: FieldRef<"Plan", 'Boolean'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly enforcementConfig: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    quotaMaxProjects: number | null
    quotaMaxDevices: number | null
    quotaMaxMockEndpoints: number | null
    quotaMaxApiEndpoints: number | null
    quotaMaxApiRequests: number | null
    quotaMaxLogs: number | null
    quotaMaxSessions: number | null
    quotaMaxCrashes: number | null
    quotaMaxBusinessConfigKeys: number | null
    quotaMaxLocalizationLanguages: number | null
    quotaMaxLocalizationKeys: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    quotaMaxProjects: number | null
    quotaMaxDevices: number | null
    quotaMaxMockEndpoints: number | null
    quotaMaxApiEndpoints: number | null
    quotaMaxApiRequests: number | null
    quotaMaxLogs: number | null
    quotaMaxSessions: number | null
    quotaMaxCrashes: number | null
    quotaMaxBusinessConfigKeys: number | null
    quotaMaxLocalizationLanguages: number | null
    quotaMaxLocalizationKeys: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: string | null
    enabled: boolean | null
    trialStartDate: Date | null
    trialEndDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelledAt: Date | null
    cancelledReason: string | null
    disabledBy: string | null
    disabledAt: Date | null
    enabledBy: string | null
    enabledAt: Date | null
    quotaMaxProjects: number | null
    quotaMaxDevices: number | null
    quotaMaxMockEndpoints: number | null
    quotaMaxApiEndpoints: number | null
    quotaMaxApiRequests: number | null
    quotaMaxLogs: number | null
    quotaMaxSessions: number | null
    quotaMaxCrashes: number | null
    quotaMaxBusinessConfigKeys: number | null
    quotaMaxLocalizationLanguages: number | null
    quotaMaxLocalizationKeys: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: string | null
    enabled: boolean | null
    trialStartDate: Date | null
    trialEndDate: Date | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelledAt: Date | null
    cancelledReason: string | null
    disabledBy: string | null
    disabledAt: Date | null
    enabledBy: string | null
    enabledAt: Date | null
    quotaMaxProjects: number | null
    quotaMaxDevices: number | null
    quotaMaxMockEndpoints: number | null
    quotaMaxApiEndpoints: number | null
    quotaMaxApiRequests: number | null
    quotaMaxLogs: number | null
    quotaMaxSessions: number | null
    quotaMaxCrashes: number | null
    quotaMaxBusinessConfigKeys: number | null
    quotaMaxLocalizationLanguages: number | null
    quotaMaxLocalizationKeys: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    status: number
    enabled: number
    trialStartDate: number
    trialEndDate: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelledAt: number
    cancelledReason: number
    disabledBy: number
    disabledAt: number
    enabledBy: number
    enabledAt: number
    quotaMaxProjects: number
    quotaMaxDevices: number
    quotaMaxMockEndpoints: number
    quotaMaxApiEndpoints: number
    quotaMaxApiRequests: number
    quotaMaxLogs: number
    quotaMaxSessions: number
    quotaMaxCrashes: number
    quotaMaxBusinessConfigKeys: number
    quotaMaxLocalizationLanguages: number
    quotaMaxLocalizationKeys: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    quotaMaxProjects?: true
    quotaMaxDevices?: true
    quotaMaxMockEndpoints?: true
    quotaMaxApiEndpoints?: true
    quotaMaxApiRequests?: true
    quotaMaxLogs?: true
    quotaMaxSessions?: true
    quotaMaxCrashes?: true
    quotaMaxBusinessConfigKeys?: true
    quotaMaxLocalizationLanguages?: true
    quotaMaxLocalizationKeys?: true
  }

  export type SubscriptionSumAggregateInputType = {
    quotaMaxProjects?: true
    quotaMaxDevices?: true
    quotaMaxMockEndpoints?: true
    quotaMaxApiEndpoints?: true
    quotaMaxApiRequests?: true
    quotaMaxLogs?: true
    quotaMaxSessions?: true
    quotaMaxCrashes?: true
    quotaMaxBusinessConfigKeys?: true
    quotaMaxLocalizationLanguages?: true
    quotaMaxLocalizationKeys?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    enabled?: true
    trialStartDate?: true
    trialEndDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelledReason?: true
    disabledBy?: true
    disabledAt?: true
    enabledBy?: true
    enabledAt?: true
    quotaMaxProjects?: true
    quotaMaxDevices?: true
    quotaMaxMockEndpoints?: true
    quotaMaxApiEndpoints?: true
    quotaMaxApiRequests?: true
    quotaMaxLogs?: true
    quotaMaxSessions?: true
    quotaMaxCrashes?: true
    quotaMaxBusinessConfigKeys?: true
    quotaMaxLocalizationLanguages?: true
    quotaMaxLocalizationKeys?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    enabled?: true
    trialStartDate?: true
    trialEndDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelledReason?: true
    disabledBy?: true
    disabledAt?: true
    enabledBy?: true
    enabledAt?: true
    quotaMaxProjects?: true
    quotaMaxDevices?: true
    quotaMaxMockEndpoints?: true
    quotaMaxApiEndpoints?: true
    quotaMaxApiRequests?: true
    quotaMaxLogs?: true
    quotaMaxSessions?: true
    quotaMaxCrashes?: true
    quotaMaxBusinessConfigKeys?: true
    quotaMaxLocalizationLanguages?: true
    quotaMaxLocalizationKeys?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    enabled?: true
    trialStartDate?: true
    trialEndDate?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelledAt?: true
    cancelledReason?: true
    disabledBy?: true
    disabledAt?: true
    enabledBy?: true
    enabledAt?: true
    quotaMaxProjects?: true
    quotaMaxDevices?: true
    quotaMaxMockEndpoints?: true
    quotaMaxApiEndpoints?: true
    quotaMaxApiRequests?: true
    quotaMaxLogs?: true
    quotaMaxSessions?: true
    quotaMaxCrashes?: true
    quotaMaxBusinessConfigKeys?: true
    quotaMaxLocalizationLanguages?: true
    quotaMaxLocalizationKeys?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    status: string
    enabled: boolean
    trialStartDate: Date
    trialEndDate: Date
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelledAt: Date | null
    cancelledReason: string | null
    disabledBy: string | null
    disabledAt: Date | null
    enabledBy: string | null
    enabledAt: Date | null
    quotaMaxProjects: number | null
    quotaMaxDevices: number | null
    quotaMaxMockEndpoints: number | null
    quotaMaxApiEndpoints: number | null
    quotaMaxApiRequests: number | null
    quotaMaxLogs: number | null
    quotaMaxSessions: number | null
    quotaMaxCrashes: number | null
    quotaMaxBusinessConfigKeys: number | null
    quotaMaxLocalizationLanguages: number | null
    quotaMaxLocalizationKeys: number | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    enabled?: boolean
    trialStartDate?: boolean
    trialEndDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    disabledBy?: boolean
    disabledAt?: boolean
    enabledBy?: boolean
    enabledAt?: boolean
    quotaMaxProjects?: boolean
    quotaMaxDevices?: boolean
    quotaMaxMockEndpoints?: boolean
    quotaMaxApiEndpoints?: boolean
    quotaMaxApiRequests?: boolean
    quotaMaxLogs?: boolean
    quotaMaxSessions?: boolean
    quotaMaxCrashes?: boolean
    quotaMaxBusinessConfigKeys?: boolean
    quotaMaxLocalizationLanguages?: boolean
    quotaMaxLocalizationKeys?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    enforcementState?: boolean | Subscription$enforcementStateArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    enabled?: boolean
    trialStartDate?: boolean
    trialEndDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    disabledBy?: boolean
    disabledAt?: boolean
    enabledBy?: boolean
    enabledAt?: boolean
    quotaMaxProjects?: boolean
    quotaMaxDevices?: boolean
    quotaMaxMockEndpoints?: boolean
    quotaMaxApiEndpoints?: boolean
    quotaMaxApiRequests?: boolean
    quotaMaxLogs?: boolean
    quotaMaxSessions?: boolean
    quotaMaxCrashes?: boolean
    quotaMaxBusinessConfigKeys?: boolean
    quotaMaxLocalizationLanguages?: boolean
    quotaMaxLocalizationKeys?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    enabled?: boolean
    trialStartDate?: boolean
    trialEndDate?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    disabledBy?: boolean
    disabledAt?: boolean
    enabledBy?: boolean
    enabledAt?: boolean
    quotaMaxProjects?: boolean
    quotaMaxDevices?: boolean
    quotaMaxMockEndpoints?: boolean
    quotaMaxApiEndpoints?: boolean
    quotaMaxApiRequests?: boolean
    quotaMaxLogs?: boolean
    quotaMaxSessions?: boolean
    quotaMaxCrashes?: boolean
    quotaMaxBusinessConfigKeys?: boolean
    quotaMaxLocalizationLanguages?: boolean
    quotaMaxLocalizationKeys?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    enforcementState?: boolean | Subscription$enforcementStateArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      enforcementState: Prisma.$EnforcementStatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      status: string
      enabled: boolean
      trialStartDate: Date
      trialEndDate: Date
      currentPeriodStart: Date
      currentPeriodEnd: Date
      cancelledAt: Date | null
      cancelledReason: string | null
      disabledBy: string | null
      disabledAt: Date | null
      enabledBy: string | null
      enabledAt: Date | null
      quotaMaxProjects: number | null
      quotaMaxDevices: number | null
      quotaMaxMockEndpoints: number | null
      quotaMaxApiEndpoints: number | null
      quotaMaxApiRequests: number | null
      quotaMaxLogs: number | null
      quotaMaxSessions: number | null
      quotaMaxCrashes: number | null
      quotaMaxBusinessConfigKeys: number | null
      quotaMaxLocalizationLanguages: number | null
      quotaMaxLocalizationKeys: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    enforcementState<T extends Subscription$enforcementStateArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$enforcementStateArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly enabled: FieldRef<"Subscription", 'Boolean'>
    readonly trialStartDate: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndDate: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledReason: FieldRef<"Subscription", 'String'>
    readonly disabledBy: FieldRef<"Subscription", 'String'>
    readonly disabledAt: FieldRef<"Subscription", 'DateTime'>
    readonly enabledBy: FieldRef<"Subscription", 'String'>
    readonly enabledAt: FieldRef<"Subscription", 'DateTime'>
    readonly quotaMaxProjects: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxDevices: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxMockEndpoints: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxApiEndpoints: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxApiRequests: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxLogs: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxSessions: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxCrashes: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxBusinessConfigKeys: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxLocalizationLanguages: FieldRef<"Subscription", 'Int'>
    readonly quotaMaxLocalizationKeys: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription.enforcementState
   */
  export type Subscription$enforcementStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    where?: EnforcementStateWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model EnforcementState
   */

  export type AggregateEnforcementState = {
    _count: EnforcementStateCountAggregateOutputType | null
    _min: EnforcementStateMinAggregateOutputType | null
    _max: EnforcementStateMaxAggregateOutputType | null
  }

  export type EnforcementStateMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    state: string | null
    warnEnteredAt: Date | null
    graceEnteredAt: Date | null
    graceEndsAt: Date | null
    degradedEnteredAt: Date | null
    lastEvaluatedAt: Date | null
    nextEvaluationAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnforcementStateMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    state: string | null
    warnEnteredAt: Date | null
    graceEnteredAt: Date | null
    graceEndsAt: Date | null
    degradedEnteredAt: Date | null
    lastEvaluatedAt: Date | null
    nextEvaluationAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnforcementStateCountAggregateOutputType = {
    id: number
    subscriptionId: number
    state: number
    warnEnteredAt: number
    graceEnteredAt: number
    graceEndsAt: number
    degradedEnteredAt: number
    effectivePolicy: number
    triggeredMetrics: number
    lastEvaluatedAt: number
    nextEvaluationAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnforcementStateMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    state?: true
    warnEnteredAt?: true
    graceEnteredAt?: true
    graceEndsAt?: true
    degradedEnteredAt?: true
    lastEvaluatedAt?: true
    nextEvaluationAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnforcementStateMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    state?: true
    warnEnteredAt?: true
    graceEnteredAt?: true
    graceEndsAt?: true
    degradedEnteredAt?: true
    lastEvaluatedAt?: true
    nextEvaluationAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnforcementStateCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    state?: true
    warnEnteredAt?: true
    graceEnteredAt?: true
    graceEndsAt?: true
    degradedEnteredAt?: true
    effectivePolicy?: true
    triggeredMetrics?: true
    lastEvaluatedAt?: true
    nextEvaluationAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnforcementStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnforcementState to aggregate.
     */
    where?: EnforcementStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnforcementStates to fetch.
     */
    orderBy?: EnforcementStateOrderByWithRelationInput | EnforcementStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnforcementStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnforcementStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnforcementStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnforcementStates
    **/
    _count?: true | EnforcementStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnforcementStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnforcementStateMaxAggregateInputType
  }

  export type GetEnforcementStateAggregateType<T extends EnforcementStateAggregateArgs> = {
        [P in keyof T & keyof AggregateEnforcementState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnforcementState[P]>
      : GetScalarType<T[P], AggregateEnforcementState[P]>
  }




  export type EnforcementStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnforcementStateWhereInput
    orderBy?: EnforcementStateOrderByWithAggregationInput | EnforcementStateOrderByWithAggregationInput[]
    by: EnforcementStateScalarFieldEnum[] | EnforcementStateScalarFieldEnum
    having?: EnforcementStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnforcementStateCountAggregateInputType | true
    _min?: EnforcementStateMinAggregateInputType
    _max?: EnforcementStateMaxAggregateInputType
  }

  export type EnforcementStateGroupByOutputType = {
    id: string
    subscriptionId: string
    state: string
    warnEnteredAt: Date | null
    graceEnteredAt: Date | null
    graceEndsAt: Date | null
    degradedEnteredAt: Date | null
    effectivePolicy: JsonValue | null
    triggeredMetrics: JsonValue | null
    lastEvaluatedAt: Date
    nextEvaluationAt: Date
    createdAt: Date
    updatedAt: Date
    _count: EnforcementStateCountAggregateOutputType | null
    _min: EnforcementStateMinAggregateOutputType | null
    _max: EnforcementStateMaxAggregateOutputType | null
  }

  type GetEnforcementStateGroupByPayload<T extends EnforcementStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnforcementStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnforcementStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnforcementStateGroupByOutputType[P]>
            : GetScalarType<T[P], EnforcementStateGroupByOutputType[P]>
        }
      >
    >


  export type EnforcementStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    state?: boolean
    warnEnteredAt?: boolean
    graceEnteredAt?: boolean
    graceEndsAt?: boolean
    degradedEnteredAt?: boolean
    effectivePolicy?: boolean
    triggeredMetrics?: boolean
    lastEvaluatedAt?: boolean
    nextEvaluationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enforcementState"]>

  export type EnforcementStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    state?: boolean
    warnEnteredAt?: boolean
    graceEnteredAt?: boolean
    graceEndsAt?: boolean
    degradedEnteredAt?: boolean
    effectivePolicy?: boolean
    triggeredMetrics?: boolean
    lastEvaluatedAt?: boolean
    nextEvaluationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enforcementState"]>

  export type EnforcementStateSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    state?: boolean
    warnEnteredAt?: boolean
    graceEnteredAt?: boolean
    graceEndsAt?: boolean
    degradedEnteredAt?: boolean
    effectivePolicy?: boolean
    triggeredMetrics?: boolean
    lastEvaluatedAt?: boolean
    nextEvaluationAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnforcementStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type EnforcementStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $EnforcementStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnforcementState"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      state: string
      warnEnteredAt: Date | null
      graceEnteredAt: Date | null
      graceEndsAt: Date | null
      degradedEnteredAt: Date | null
      effectivePolicy: Prisma.JsonValue | null
      triggeredMetrics: Prisma.JsonValue | null
      lastEvaluatedAt: Date
      nextEvaluationAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enforcementState"]>
    composites: {}
  }

  type EnforcementStateGetPayload<S extends boolean | null | undefined | EnforcementStateDefaultArgs> = $Result.GetResult<Prisma.$EnforcementStatePayload, S>

  type EnforcementStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnforcementStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnforcementStateCountAggregateInputType | true
    }

  export interface EnforcementStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnforcementState'], meta: { name: 'EnforcementState' } }
    /**
     * Find zero or one EnforcementState that matches the filter.
     * @param {EnforcementStateFindUniqueArgs} args - Arguments to find a EnforcementState
     * @example
     * // Get one EnforcementState
     * const enforcementState = await prisma.enforcementState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnforcementStateFindUniqueArgs>(args: SelectSubset<T, EnforcementStateFindUniqueArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EnforcementState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnforcementStateFindUniqueOrThrowArgs} args - Arguments to find a EnforcementState
     * @example
     * // Get one EnforcementState
     * const enforcementState = await prisma.enforcementState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnforcementStateFindUniqueOrThrowArgs>(args: SelectSubset<T, EnforcementStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EnforcementState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateFindFirstArgs} args - Arguments to find a EnforcementState
     * @example
     * // Get one EnforcementState
     * const enforcementState = await prisma.enforcementState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnforcementStateFindFirstArgs>(args?: SelectSubset<T, EnforcementStateFindFirstArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EnforcementState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateFindFirstOrThrowArgs} args - Arguments to find a EnforcementState
     * @example
     * // Get one EnforcementState
     * const enforcementState = await prisma.enforcementState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnforcementStateFindFirstOrThrowArgs>(args?: SelectSubset<T, EnforcementStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EnforcementStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnforcementStates
     * const enforcementStates = await prisma.enforcementState.findMany()
     * 
     * // Get first 10 EnforcementStates
     * const enforcementStates = await prisma.enforcementState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enforcementStateWithIdOnly = await prisma.enforcementState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnforcementStateFindManyArgs>(args?: SelectSubset<T, EnforcementStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EnforcementState.
     * @param {EnforcementStateCreateArgs} args - Arguments to create a EnforcementState.
     * @example
     * // Create one EnforcementState
     * const EnforcementState = await prisma.enforcementState.create({
     *   data: {
     *     // ... data to create a EnforcementState
     *   }
     * })
     * 
     */
    create<T extends EnforcementStateCreateArgs>(args: SelectSubset<T, EnforcementStateCreateArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EnforcementStates.
     * @param {EnforcementStateCreateManyArgs} args - Arguments to create many EnforcementStates.
     * @example
     * // Create many EnforcementStates
     * const enforcementState = await prisma.enforcementState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnforcementStateCreateManyArgs>(args?: SelectSubset<T, EnforcementStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnforcementStates and returns the data saved in the database.
     * @param {EnforcementStateCreateManyAndReturnArgs} args - Arguments to create many EnforcementStates.
     * @example
     * // Create many EnforcementStates
     * const enforcementState = await prisma.enforcementState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnforcementStates and only return the `id`
     * const enforcementStateWithIdOnly = await prisma.enforcementState.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnforcementStateCreateManyAndReturnArgs>(args?: SelectSubset<T, EnforcementStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EnforcementState.
     * @param {EnforcementStateDeleteArgs} args - Arguments to delete one EnforcementState.
     * @example
     * // Delete one EnforcementState
     * const EnforcementState = await prisma.enforcementState.delete({
     *   where: {
     *     // ... filter to delete one EnforcementState
     *   }
     * })
     * 
     */
    delete<T extends EnforcementStateDeleteArgs>(args: SelectSubset<T, EnforcementStateDeleteArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EnforcementState.
     * @param {EnforcementStateUpdateArgs} args - Arguments to update one EnforcementState.
     * @example
     * // Update one EnforcementState
     * const enforcementState = await prisma.enforcementState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnforcementStateUpdateArgs>(args: SelectSubset<T, EnforcementStateUpdateArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EnforcementStates.
     * @param {EnforcementStateDeleteManyArgs} args - Arguments to filter EnforcementStates to delete.
     * @example
     * // Delete a few EnforcementStates
     * const { count } = await prisma.enforcementState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnforcementStateDeleteManyArgs>(args?: SelectSubset<T, EnforcementStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnforcementStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnforcementStates
     * const enforcementState = await prisma.enforcementState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnforcementStateUpdateManyArgs>(args: SelectSubset<T, EnforcementStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EnforcementState.
     * @param {EnforcementStateUpsertArgs} args - Arguments to update or create a EnforcementState.
     * @example
     * // Update or create a EnforcementState
     * const enforcementState = await prisma.enforcementState.upsert({
     *   create: {
     *     // ... data to create a EnforcementState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnforcementState we want to update
     *   }
     * })
     */
    upsert<T extends EnforcementStateUpsertArgs>(args: SelectSubset<T, EnforcementStateUpsertArgs<ExtArgs>>): Prisma__EnforcementStateClient<$Result.GetResult<Prisma.$EnforcementStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EnforcementStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateCountArgs} args - Arguments to filter EnforcementStates to count.
     * @example
     * // Count the number of EnforcementStates
     * const count = await prisma.enforcementState.count({
     *   where: {
     *     // ... the filter for the EnforcementStates we want to count
     *   }
     * })
    **/
    count<T extends EnforcementStateCountArgs>(
      args?: Subset<T, EnforcementStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnforcementStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnforcementState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnforcementStateAggregateArgs>(args: Subset<T, EnforcementStateAggregateArgs>): Prisma.PrismaPromise<GetEnforcementStateAggregateType<T>>

    /**
     * Group by EnforcementState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnforcementStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnforcementStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnforcementStateGroupByArgs['orderBy'] }
        : { orderBy?: EnforcementStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnforcementStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnforcementStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnforcementState model
   */
  readonly fields: EnforcementStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnforcementState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnforcementStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnforcementState model
   */ 
  interface EnforcementStateFieldRefs {
    readonly id: FieldRef<"EnforcementState", 'String'>
    readonly subscriptionId: FieldRef<"EnforcementState", 'String'>
    readonly state: FieldRef<"EnforcementState", 'String'>
    readonly warnEnteredAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly graceEnteredAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly graceEndsAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly degradedEnteredAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly effectivePolicy: FieldRef<"EnforcementState", 'Json'>
    readonly triggeredMetrics: FieldRef<"EnforcementState", 'Json'>
    readonly lastEvaluatedAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly nextEvaluationAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly createdAt: FieldRef<"EnforcementState", 'DateTime'>
    readonly updatedAt: FieldRef<"EnforcementState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EnforcementState findUnique
   */
  export type EnforcementStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter, which EnforcementState to fetch.
     */
    where: EnforcementStateWhereUniqueInput
  }

  /**
   * EnforcementState findUniqueOrThrow
   */
  export type EnforcementStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter, which EnforcementState to fetch.
     */
    where: EnforcementStateWhereUniqueInput
  }

  /**
   * EnforcementState findFirst
   */
  export type EnforcementStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter, which EnforcementState to fetch.
     */
    where?: EnforcementStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnforcementStates to fetch.
     */
    orderBy?: EnforcementStateOrderByWithRelationInput | EnforcementStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnforcementStates.
     */
    cursor?: EnforcementStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnforcementStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnforcementStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnforcementStates.
     */
    distinct?: EnforcementStateScalarFieldEnum | EnforcementStateScalarFieldEnum[]
  }

  /**
   * EnforcementState findFirstOrThrow
   */
  export type EnforcementStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter, which EnforcementState to fetch.
     */
    where?: EnforcementStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnforcementStates to fetch.
     */
    orderBy?: EnforcementStateOrderByWithRelationInput | EnforcementStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnforcementStates.
     */
    cursor?: EnforcementStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnforcementStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnforcementStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnforcementStates.
     */
    distinct?: EnforcementStateScalarFieldEnum | EnforcementStateScalarFieldEnum[]
  }

  /**
   * EnforcementState findMany
   */
  export type EnforcementStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter, which EnforcementStates to fetch.
     */
    where?: EnforcementStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnforcementStates to fetch.
     */
    orderBy?: EnforcementStateOrderByWithRelationInput | EnforcementStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnforcementStates.
     */
    cursor?: EnforcementStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnforcementStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnforcementStates.
     */
    skip?: number
    distinct?: EnforcementStateScalarFieldEnum | EnforcementStateScalarFieldEnum[]
  }

  /**
   * EnforcementState create
   */
  export type EnforcementStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * The data needed to create a EnforcementState.
     */
    data: XOR<EnforcementStateCreateInput, EnforcementStateUncheckedCreateInput>
  }

  /**
   * EnforcementState createMany
   */
  export type EnforcementStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnforcementStates.
     */
    data: EnforcementStateCreateManyInput | EnforcementStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnforcementState createManyAndReturn
   */
  export type EnforcementStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EnforcementStates.
     */
    data: EnforcementStateCreateManyInput | EnforcementStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnforcementState update
   */
  export type EnforcementStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * The data needed to update a EnforcementState.
     */
    data: XOR<EnforcementStateUpdateInput, EnforcementStateUncheckedUpdateInput>
    /**
     * Choose, which EnforcementState to update.
     */
    where: EnforcementStateWhereUniqueInput
  }

  /**
   * EnforcementState updateMany
   */
  export type EnforcementStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnforcementStates.
     */
    data: XOR<EnforcementStateUpdateManyMutationInput, EnforcementStateUncheckedUpdateManyInput>
    /**
     * Filter which EnforcementStates to update
     */
    where?: EnforcementStateWhereInput
  }

  /**
   * EnforcementState upsert
   */
  export type EnforcementStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * The filter to search for the EnforcementState to update in case it exists.
     */
    where: EnforcementStateWhereUniqueInput
    /**
     * In case the EnforcementState found by the `where` argument doesn't exist, create a new EnforcementState with this data.
     */
    create: XOR<EnforcementStateCreateInput, EnforcementStateUncheckedCreateInput>
    /**
     * In case the EnforcementState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnforcementStateUpdateInput, EnforcementStateUncheckedUpdateInput>
  }

  /**
   * EnforcementState delete
   */
  export type EnforcementStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
    /**
     * Filter which EnforcementState to delete.
     */
    where: EnforcementStateWhereUniqueInput
  }

  /**
   * EnforcementState deleteMany
   */
  export type EnforcementStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnforcementStates to delete
     */
    where?: EnforcementStateWhereInput
  }

  /**
   * EnforcementState without action
   */
  export type EnforcementStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnforcementState
     */
    select?: EnforcementStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnforcementStateInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    invoiceNumber: string | null
    status: string | null
    amount: number | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    dueDate: Date | null
    paidAt: Date | null
    pdfUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    invoiceNumber: string | null
    status: string | null
    amount: number | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    dueDate: Date | null
    paidAt: Date | null
    pdfUrl: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    subscriptionId: number
    invoiceNumber: number
    status: number
    amount: number
    currency: number
    periodStart: number
    periodEnd: number
    dueDate: number
    paidAt: number
    pdfUrl: number
    lineItems: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    status?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    pdfUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    status?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    pdfUrl?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    invoiceNumber?: true
    status?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    dueDate?: true
    paidAt?: true
    pdfUrl?: true
    lineItems?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    subscriptionId: string
    invoiceNumber: string
    status: string
    amount: number
    currency: string
    periodStart: Date
    periodEnd: Date
    dueDate: Date
    paidAt: Date | null
    pdfUrl: string | null
    lineItems: JsonValue | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    pdfUrl?: boolean
    lineItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    pdfUrl?: boolean
    lineItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    dueDate?: boolean
    paidAt?: boolean
    pdfUrl?: boolean
    lineItems?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      invoiceNumber: string
      status: string
      amount: number
      currency: string
      periodStart: Date
      periodEnd: Date
      dueDate: Date
      paidAt: Date | null
      pdfUrl: string | null
      lineItems: Prisma.JsonValue | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly subscriptionId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly periodStart: FieldRef<"Invoice", 'DateTime'>
    readonly periodEnd: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly lineItems: FieldRef<"Invoice", 'Json'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Build
   */

  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildAvgAggregateOutputType = {
    version: number | null
    configCount: number | null
    translationCount: number | null
  }

  export type BuildSumAggregateOutputType = {
    version: number | null
    configCount: number | null
    translationCount: number | null
  }

  export type BuildMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    version: number | null
    name: string | null
    description: string | null
    mode: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    configCount: number | null
    translationCount: number | null
  }

  export type BuildMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    version: number | null
    name: string | null
    description: string | null
    mode: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    configCount: number | null
    translationCount: number | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    projectId: number
    version: number
    name: number
    description: number
    mode: number
    isActive: number
    createdBy: number
    createdAt: number
    businessConfigSnapshot: number
    localizationSnapshot: number
    configCount: number
    translationCount: number
    _all: number
  }


  export type BuildAvgAggregateInputType = {
    version?: true
    configCount?: true
    translationCount?: true
  }

  export type BuildSumAggregateInputType = {
    version?: true
    configCount?: true
    translationCount?: true
  }

  export type BuildMinAggregateInputType = {
    id?: true
    projectId?: true
    version?: true
    name?: true
    description?: true
    mode?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    configCount?: true
    translationCount?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    projectId?: true
    version?: true
    name?: true
    description?: true
    mode?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    configCount?: true
    translationCount?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    projectId?: true
    version?: true
    name?: true
    description?: true
    mode?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    businessConfigSnapshot?: true
    localizationSnapshot?: true
    configCount?: true
    translationCount?: true
    _all?: true
  }

  export type BuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Build to aggregate.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithAggregationInput | BuildOrderByWithAggregationInput[]
    by: BuildScalarFieldEnum[] | BuildScalarFieldEnum
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _avg?: BuildAvgAggregateInputType
    _sum?: BuildSumAggregateInputType
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }

  export type BuildGroupByOutputType = {
    id: string
    projectId: string
    version: number
    name: string | null
    description: string | null
    mode: string | null
    isActive: boolean
    createdBy: string | null
    createdAt: Date
    businessConfigSnapshot: JsonValue | null
    localizationSnapshot: JsonValue | null
    configCount: number
    translationCount: number
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    mode?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    businessConfigSnapshot?: boolean
    localizationSnapshot?: boolean
    configCount?: boolean
    translationCount?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    features?: boolean | Build$featuresArgs<ExtArgs>
    changeLogs?: boolean | Build$changeLogsArgs<ExtArgs>
    previewMode?: boolean | Build$previewModeArgs<ExtArgs>
    productionMode?: boolean | Build$productionModeArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["build"]>

  export type BuildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    mode?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    businessConfigSnapshot?: boolean
    localizationSnapshot?: boolean
    configCount?: boolean
    translationCount?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["build"]>

  export type BuildSelectScalar = {
    id?: boolean
    projectId?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    mode?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    businessConfigSnapshot?: boolean
    localizationSnapshot?: boolean
    configCount?: boolean
    translationCount?: boolean
  }

  export type BuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    features?: boolean | Build$featuresArgs<ExtArgs>
    changeLogs?: boolean | Build$changeLogsArgs<ExtArgs>
    previewMode?: boolean | Build$previewModeArgs<ExtArgs>
    productionMode?: boolean | Build$productionModeArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Build"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      features: Prisma.$BuildFeaturePayload<ExtArgs>[]
      changeLogs: Prisma.$BuildChangeLogPayload<ExtArgs>[]
      previewMode: Prisma.$BuildModePayload<ExtArgs> | null
      productionMode: Prisma.$BuildModePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      version: number
      name: string | null
      description: string | null
      mode: string | null
      isActive: boolean
      createdBy: string | null
      createdAt: Date
      businessConfigSnapshot: Prisma.JsonValue | null
      localizationSnapshot: Prisma.JsonValue | null
      configCount: number
      translationCount: number
    }, ExtArgs["result"]["build"]>
    composites: {}
  }

  type BuildGetPayload<S extends boolean | null | undefined | BuildDefaultArgs> = $Result.GetResult<Prisma.$BuildPayload, S>

  type BuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildCountAggregateInputType | true
    }

  export interface BuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Build'], meta: { name: 'Build' } }
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildFindUniqueArgs>(args: SelectSubset<T, BuildFindUniqueArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Build that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildFindFirstArgs>(args?: SelectSubset<T, BuildFindFirstArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Build that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildFindManyArgs>(args?: SelectSubset<T, BuildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
     */
    create<T extends BuildCreateArgs>(args: SelectSubset<T, BuildCreateArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Builds.
     * @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     * @example
     * // Create many Builds
     * const build = await prisma.build.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildCreateManyArgs>(args?: SelectSubset<T, BuildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Builds and returns the data saved in the database.
     * @param {BuildCreateManyAndReturnArgs} args - Arguments to create many Builds.
     * @example
     * // Create many Builds
     * const build = await prisma.build.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Builds and only return the `id`
     * const buildWithIdOnly = await prisma.build.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
     */
    delete<T extends BuildDeleteArgs>(args: SelectSubset<T, BuildDeleteArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildUpdateArgs>(args: SelectSubset<T, BuildUpdateArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildDeleteManyArgs>(args?: SelectSubset<T, BuildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildUpdateManyArgs>(args: SelectSubset<T, BuildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
     */
    upsert<T extends BuildUpsertArgs>(args: SelectSubset<T, BuildUpsertArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): Prisma.PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Build model
   */
  readonly fields: BuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    features<T extends Build$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Build$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findMany"> | Null>
    changeLogs<T extends Build$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Build$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    previewMode<T extends Build$previewModeArgs<ExtArgs> = {}>(args?: Subset<T, Build$previewModeArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productionMode<T extends Build$productionModeArgs<ExtArgs> = {}>(args?: Subset<T, Build$productionModeArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Build model
   */ 
  interface BuildFieldRefs {
    readonly id: FieldRef<"Build", 'String'>
    readonly projectId: FieldRef<"Build", 'String'>
    readonly version: FieldRef<"Build", 'Int'>
    readonly name: FieldRef<"Build", 'String'>
    readonly description: FieldRef<"Build", 'String'>
    readonly mode: FieldRef<"Build", 'String'>
    readonly isActive: FieldRef<"Build", 'Boolean'>
    readonly createdBy: FieldRef<"Build", 'String'>
    readonly createdAt: FieldRef<"Build", 'DateTime'>
    readonly businessConfigSnapshot: FieldRef<"Build", 'Json'>
    readonly localizationSnapshot: FieldRef<"Build", 'Json'>
    readonly configCount: FieldRef<"Build", 'Int'>
    readonly translationCount: FieldRef<"Build", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Build findUnique
   */
  export type BuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }

  /**
   * Build findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }

  /**
   * Build findFirst
   */
  export type BuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }

  /**
   * Build findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }

  /**
   * Build findMany
   */
  export type BuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Builds to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }

  /**
   * Build create
   */
  export type BuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to create a Build.
     */
    data: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }

  /**
   * Build createMany
   */
  export type BuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Builds.
     */
    data: BuildCreateManyInput | BuildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Build createManyAndReturn
   */
  export type BuildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Builds.
     */
    data: BuildCreateManyInput | BuildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Build update
   */
  export type BuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to update a Build.
     */
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     */
    where: BuildWhereUniqueInput
  }

  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Builds.
     */
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     */
    where?: BuildWhereInput
  }

  /**
   * Build upsert
   */
  export type BuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The filter to search for the Build to update in case it exists.
     */
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     */
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }

  /**
   * Build delete
   */
  export type BuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter which Build to delete.
     */
    where: BuildWhereUniqueInput
  }

  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Builds to delete
     */
    where?: BuildWhereInput
  }

  /**
   * Build.features
   */
  export type Build$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    where?: BuildFeatureWhereInput
    orderBy?: BuildFeatureOrderByWithRelationInput | BuildFeatureOrderByWithRelationInput[]
    cursor?: BuildFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildFeatureScalarFieldEnum | BuildFeatureScalarFieldEnum[]
  }

  /**
   * Build.changeLogs
   */
  export type Build$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    where?: BuildChangeLogWhereInput
    orderBy?: BuildChangeLogOrderByWithRelationInput | BuildChangeLogOrderByWithRelationInput[]
    cursor?: BuildChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildChangeLogScalarFieldEnum | BuildChangeLogScalarFieldEnum[]
  }

  /**
   * Build.previewMode
   */
  export type Build$previewModeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    where?: BuildModeWhereInput
  }

  /**
   * Build.productionMode
   */
  export type Build$productionModeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    where?: BuildModeWhereInput
  }

  /**
   * Build without action
   */
  export type BuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
  }


  /**
   * Model BuildFeature
   */

  export type AggregateBuildFeature = {
    _count: BuildFeatureCountAggregateOutputType | null
    _avg: BuildFeatureAvgAggregateOutputType | null
    _sum: BuildFeatureSumAggregateOutputType | null
    _min: BuildFeatureMinAggregateOutputType | null
    _max: BuildFeatureMaxAggregateOutputType | null
  }

  export type BuildFeatureAvgAggregateOutputType = {
    itemCount: number | null
  }

  export type BuildFeatureSumAggregateOutputType = {
    itemCount: number | null
  }

  export type BuildFeatureMinAggregateOutputType = {
    id: string | null
    buildId: string | null
    featureType: string | null
    itemCount: number | null
    createdAt: Date | null
  }

  export type BuildFeatureMaxAggregateOutputType = {
    id: string | null
    buildId: string | null
    featureType: string | null
    itemCount: number | null
    createdAt: Date | null
  }

  export type BuildFeatureCountAggregateOutputType = {
    id: number
    buildId: number
    featureType: number
    snapshotData: number
    itemCount: number
    createdAt: number
    _all: number
  }


  export type BuildFeatureAvgAggregateInputType = {
    itemCount?: true
  }

  export type BuildFeatureSumAggregateInputType = {
    itemCount?: true
  }

  export type BuildFeatureMinAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    itemCount?: true
    createdAt?: true
  }

  export type BuildFeatureMaxAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    itemCount?: true
    createdAt?: true
  }

  export type BuildFeatureCountAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    snapshotData?: true
    itemCount?: true
    createdAt?: true
    _all?: true
  }

  export type BuildFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildFeature to aggregate.
     */
    where?: BuildFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildFeatures to fetch.
     */
    orderBy?: BuildFeatureOrderByWithRelationInput | BuildFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildFeatures
    **/
    _count?: true | BuildFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildFeatureMaxAggregateInputType
  }

  export type GetBuildFeatureAggregateType<T extends BuildFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildFeature[P]>
      : GetScalarType<T[P], AggregateBuildFeature[P]>
  }




  export type BuildFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildFeatureWhereInput
    orderBy?: BuildFeatureOrderByWithAggregationInput | BuildFeatureOrderByWithAggregationInput[]
    by: BuildFeatureScalarFieldEnum[] | BuildFeatureScalarFieldEnum
    having?: BuildFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildFeatureCountAggregateInputType | true
    _avg?: BuildFeatureAvgAggregateInputType
    _sum?: BuildFeatureSumAggregateInputType
    _min?: BuildFeatureMinAggregateInputType
    _max?: BuildFeatureMaxAggregateInputType
  }

  export type BuildFeatureGroupByOutputType = {
    id: string
    buildId: string
    featureType: string
    snapshotData: JsonValue
    itemCount: number
    createdAt: Date
    _count: BuildFeatureCountAggregateOutputType | null
    _avg: BuildFeatureAvgAggregateOutputType | null
    _sum: BuildFeatureSumAggregateOutputType | null
    _min: BuildFeatureMinAggregateOutputType | null
    _max: BuildFeatureMaxAggregateOutputType | null
  }

  type GetBuildFeatureGroupByPayload<T extends BuildFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], BuildFeatureGroupByOutputType[P]>
        }
      >
    >


  export type BuildFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    snapshotData?: boolean
    itemCount?: boolean
    createdAt?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildFeature"]>

  export type BuildFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    snapshotData?: boolean
    itemCount?: boolean
    createdAt?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildFeature"]>

  export type BuildFeatureSelectScalar = {
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    snapshotData?: boolean
    itemCount?: boolean
    createdAt?: boolean
  }

  export type BuildFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }
  export type BuildFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }

  export type $BuildFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildFeature"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildId: string
      featureType: string
      snapshotData: Prisma.JsonValue
      itemCount: number
      createdAt: Date
    }, ExtArgs["result"]["buildFeature"]>
    composites: {}
  }

  type BuildFeatureGetPayload<S extends boolean | null | undefined | BuildFeatureDefaultArgs> = $Result.GetResult<Prisma.$BuildFeaturePayload, S>

  type BuildFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildFeatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildFeatureCountAggregateInputType | true
    }

  export interface BuildFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildFeature'], meta: { name: 'BuildFeature' } }
    /**
     * Find zero or one BuildFeature that matches the filter.
     * @param {BuildFeatureFindUniqueArgs} args - Arguments to find a BuildFeature
     * @example
     * // Get one BuildFeature
     * const buildFeature = await prisma.buildFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildFeatureFindUniqueArgs>(args: SelectSubset<T, BuildFeatureFindUniqueArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuildFeature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildFeatureFindUniqueOrThrowArgs} args - Arguments to find a BuildFeature
     * @example
     * // Get one BuildFeature
     * const buildFeature = await prisma.buildFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuildFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureFindFirstArgs} args - Arguments to find a BuildFeature
     * @example
     * // Get one BuildFeature
     * const buildFeature = await prisma.buildFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildFeatureFindFirstArgs>(args?: SelectSubset<T, BuildFeatureFindFirstArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuildFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureFindFirstOrThrowArgs} args - Arguments to find a BuildFeature
     * @example
     * // Get one BuildFeature
     * const buildFeature = await prisma.buildFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuildFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildFeatures
     * const buildFeatures = await prisma.buildFeature.findMany()
     * 
     * // Get first 10 BuildFeatures
     * const buildFeatures = await prisma.buildFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildFeatureWithIdOnly = await prisma.buildFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildFeatureFindManyArgs>(args?: SelectSubset<T, BuildFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuildFeature.
     * @param {BuildFeatureCreateArgs} args - Arguments to create a BuildFeature.
     * @example
     * // Create one BuildFeature
     * const BuildFeature = await prisma.buildFeature.create({
     *   data: {
     *     // ... data to create a BuildFeature
     *   }
     * })
     * 
     */
    create<T extends BuildFeatureCreateArgs>(args: SelectSubset<T, BuildFeatureCreateArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuildFeatures.
     * @param {BuildFeatureCreateManyArgs} args - Arguments to create many BuildFeatures.
     * @example
     * // Create many BuildFeatures
     * const buildFeature = await prisma.buildFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildFeatureCreateManyArgs>(args?: SelectSubset<T, BuildFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuildFeatures and returns the data saved in the database.
     * @param {BuildFeatureCreateManyAndReturnArgs} args - Arguments to create many BuildFeatures.
     * @example
     * // Create many BuildFeatures
     * const buildFeature = await prisma.buildFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuildFeatures and only return the `id`
     * const buildFeatureWithIdOnly = await prisma.buildFeature.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuildFeature.
     * @param {BuildFeatureDeleteArgs} args - Arguments to delete one BuildFeature.
     * @example
     * // Delete one BuildFeature
     * const BuildFeature = await prisma.buildFeature.delete({
     *   where: {
     *     // ... filter to delete one BuildFeature
     *   }
     * })
     * 
     */
    delete<T extends BuildFeatureDeleteArgs>(args: SelectSubset<T, BuildFeatureDeleteArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuildFeature.
     * @param {BuildFeatureUpdateArgs} args - Arguments to update one BuildFeature.
     * @example
     * // Update one BuildFeature
     * const buildFeature = await prisma.buildFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildFeatureUpdateArgs>(args: SelectSubset<T, BuildFeatureUpdateArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuildFeatures.
     * @param {BuildFeatureDeleteManyArgs} args - Arguments to filter BuildFeatures to delete.
     * @example
     * // Delete a few BuildFeatures
     * const { count } = await prisma.buildFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildFeatureDeleteManyArgs>(args?: SelectSubset<T, BuildFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildFeatures
     * const buildFeature = await prisma.buildFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildFeatureUpdateManyArgs>(args: SelectSubset<T, BuildFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildFeature.
     * @param {BuildFeatureUpsertArgs} args - Arguments to update or create a BuildFeature.
     * @example
     * // Update or create a BuildFeature
     * const buildFeature = await prisma.buildFeature.upsert({
     *   create: {
     *     // ... data to create a BuildFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildFeature we want to update
     *   }
     * })
     */
    upsert<T extends BuildFeatureUpsertArgs>(args: SelectSubset<T, BuildFeatureUpsertArgs<ExtArgs>>): Prisma__BuildFeatureClient<$Result.GetResult<Prisma.$BuildFeaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuildFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureCountArgs} args - Arguments to filter BuildFeatures to count.
     * @example
     * // Count the number of BuildFeatures
     * const count = await prisma.buildFeature.count({
     *   where: {
     *     // ... the filter for the BuildFeatures we want to count
     *   }
     * })
    **/
    count<T extends BuildFeatureCountArgs>(
      args?: Subset<T, BuildFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildFeatureAggregateArgs>(args: Subset<T, BuildFeatureAggregateArgs>): Prisma.PrismaPromise<GetBuildFeatureAggregateType<T>>

    /**
     * Group by BuildFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildFeatureGroupByArgs['orderBy'] }
        : { orderBy?: BuildFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildFeature model
   */
  readonly fields: BuildFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuildFeature model
   */ 
  interface BuildFeatureFieldRefs {
    readonly id: FieldRef<"BuildFeature", 'String'>
    readonly buildId: FieldRef<"BuildFeature", 'String'>
    readonly featureType: FieldRef<"BuildFeature", 'String'>
    readonly snapshotData: FieldRef<"BuildFeature", 'Json'>
    readonly itemCount: FieldRef<"BuildFeature", 'Int'>
    readonly createdAt: FieldRef<"BuildFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuildFeature findUnique
   */
  export type BuildFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BuildFeature to fetch.
     */
    where: BuildFeatureWhereUniqueInput
  }

  /**
   * BuildFeature findUniqueOrThrow
   */
  export type BuildFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BuildFeature to fetch.
     */
    where: BuildFeatureWhereUniqueInput
  }

  /**
   * BuildFeature findFirst
   */
  export type BuildFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BuildFeature to fetch.
     */
    where?: BuildFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildFeatures to fetch.
     */
    orderBy?: BuildFeatureOrderByWithRelationInput | BuildFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildFeatures.
     */
    cursor?: BuildFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildFeatures.
     */
    distinct?: BuildFeatureScalarFieldEnum | BuildFeatureScalarFieldEnum[]
  }

  /**
   * BuildFeature findFirstOrThrow
   */
  export type BuildFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BuildFeature to fetch.
     */
    where?: BuildFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildFeatures to fetch.
     */
    orderBy?: BuildFeatureOrderByWithRelationInput | BuildFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildFeatures.
     */
    cursor?: BuildFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildFeatures.
     */
    distinct?: BuildFeatureScalarFieldEnum | BuildFeatureScalarFieldEnum[]
  }

  /**
   * BuildFeature findMany
   */
  export type BuildFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter, which BuildFeatures to fetch.
     */
    where?: BuildFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildFeatures to fetch.
     */
    orderBy?: BuildFeatureOrderByWithRelationInput | BuildFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildFeatures.
     */
    cursor?: BuildFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildFeatures.
     */
    skip?: number
    distinct?: BuildFeatureScalarFieldEnum | BuildFeatureScalarFieldEnum[]
  }

  /**
   * BuildFeature create
   */
  export type BuildFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildFeature.
     */
    data: XOR<BuildFeatureCreateInput, BuildFeatureUncheckedCreateInput>
  }

  /**
   * BuildFeature createMany
   */
  export type BuildFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildFeatures.
     */
    data: BuildFeatureCreateManyInput | BuildFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildFeature createManyAndReturn
   */
  export type BuildFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuildFeatures.
     */
    data: BuildFeatureCreateManyInput | BuildFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuildFeature update
   */
  export type BuildFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildFeature.
     */
    data: XOR<BuildFeatureUpdateInput, BuildFeatureUncheckedUpdateInput>
    /**
     * Choose, which BuildFeature to update.
     */
    where: BuildFeatureWhereUniqueInput
  }

  /**
   * BuildFeature updateMany
   */
  export type BuildFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildFeatures.
     */
    data: XOR<BuildFeatureUpdateManyMutationInput, BuildFeatureUncheckedUpdateManyInput>
    /**
     * Filter which BuildFeatures to update
     */
    where?: BuildFeatureWhereInput
  }

  /**
   * BuildFeature upsert
   */
  export type BuildFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildFeature to update in case it exists.
     */
    where: BuildFeatureWhereUniqueInput
    /**
     * In case the BuildFeature found by the `where` argument doesn't exist, create a new BuildFeature with this data.
     */
    create: XOR<BuildFeatureCreateInput, BuildFeatureUncheckedCreateInput>
    /**
     * In case the BuildFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildFeatureUpdateInput, BuildFeatureUncheckedUpdateInput>
  }

  /**
   * BuildFeature delete
   */
  export type BuildFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
    /**
     * Filter which BuildFeature to delete.
     */
    where: BuildFeatureWhereUniqueInput
  }

  /**
   * BuildFeature deleteMany
   */
  export type BuildFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildFeatures to delete
     */
    where?: BuildFeatureWhereInput
  }

  /**
   * BuildFeature without action
   */
  export type BuildFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildFeature
     */
    select?: BuildFeatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildFeatureInclude<ExtArgs> | null
  }


  /**
   * Model BuildMode
   */

  export type AggregateBuildMode = {
    _count: BuildModeCountAggregateOutputType | null
    _min: BuildModeMinAggregateOutputType | null
    _max: BuildModeMaxAggregateOutputType | null
  }

  export type BuildModeMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    previewBuildId: string | null
    productionBuildId: string | null
    updatedAt: Date | null
  }

  export type BuildModeMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    previewBuildId: string | null
    productionBuildId: string | null
    updatedAt: Date | null
  }

  export type BuildModeCountAggregateOutputType = {
    id: number
    projectId: number
    previewBuildId: number
    productionBuildId: number
    updatedAt: number
    _all: number
  }


  export type BuildModeMinAggregateInputType = {
    id?: true
    projectId?: true
    previewBuildId?: true
    productionBuildId?: true
    updatedAt?: true
  }

  export type BuildModeMaxAggregateInputType = {
    id?: true
    projectId?: true
    previewBuildId?: true
    productionBuildId?: true
    updatedAt?: true
  }

  export type BuildModeCountAggregateInputType = {
    id?: true
    projectId?: true
    previewBuildId?: true
    productionBuildId?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildModeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildMode to aggregate.
     */
    where?: BuildModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildModes to fetch.
     */
    orderBy?: BuildModeOrderByWithRelationInput | BuildModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildModes
    **/
    _count?: true | BuildModeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildModeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildModeMaxAggregateInputType
  }

  export type GetBuildModeAggregateType<T extends BuildModeAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildMode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildMode[P]>
      : GetScalarType<T[P], AggregateBuildMode[P]>
  }




  export type BuildModeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildModeWhereInput
    orderBy?: BuildModeOrderByWithAggregationInput | BuildModeOrderByWithAggregationInput[]
    by: BuildModeScalarFieldEnum[] | BuildModeScalarFieldEnum
    having?: BuildModeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildModeCountAggregateInputType | true
    _min?: BuildModeMinAggregateInputType
    _max?: BuildModeMaxAggregateInputType
  }

  export type BuildModeGroupByOutputType = {
    id: string
    projectId: string
    previewBuildId: string | null
    productionBuildId: string | null
    updatedAt: Date
    _count: BuildModeCountAggregateOutputType | null
    _min: BuildModeMinAggregateOutputType | null
    _max: BuildModeMaxAggregateOutputType | null
  }

  type GetBuildModeGroupByPayload<T extends BuildModeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildModeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildModeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildModeGroupByOutputType[P]>
            : GetScalarType<T[P], BuildModeGroupByOutputType[P]>
        }
      >
    >


  export type BuildModeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    previewBuildId?: boolean
    productionBuildId?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previewBuild?: boolean | BuildMode$previewBuildArgs<ExtArgs>
    productionBuild?: boolean | BuildMode$productionBuildArgs<ExtArgs>
  }, ExtArgs["result"]["buildMode"]>

  export type BuildModeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    previewBuildId?: boolean
    productionBuildId?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previewBuild?: boolean | BuildMode$previewBuildArgs<ExtArgs>
    productionBuild?: boolean | BuildMode$productionBuildArgs<ExtArgs>
  }, ExtArgs["result"]["buildMode"]>

  export type BuildModeSelectScalar = {
    id?: boolean
    projectId?: boolean
    previewBuildId?: boolean
    productionBuildId?: boolean
    updatedAt?: boolean
  }

  export type BuildModeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previewBuild?: boolean | BuildMode$previewBuildArgs<ExtArgs>
    productionBuild?: boolean | BuildMode$productionBuildArgs<ExtArgs>
  }
  export type BuildModeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previewBuild?: boolean | BuildMode$previewBuildArgs<ExtArgs>
    productionBuild?: boolean | BuildMode$productionBuildArgs<ExtArgs>
  }

  export type $BuildModePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildMode"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      previewBuild: Prisma.$BuildPayload<ExtArgs> | null
      productionBuild: Prisma.$BuildPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      previewBuildId: string | null
      productionBuildId: string | null
      updatedAt: Date
    }, ExtArgs["result"]["buildMode"]>
    composites: {}
  }

  type BuildModeGetPayload<S extends boolean | null | undefined | BuildModeDefaultArgs> = $Result.GetResult<Prisma.$BuildModePayload, S>

  type BuildModeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildModeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildModeCountAggregateInputType | true
    }

  export interface BuildModeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildMode'], meta: { name: 'BuildMode' } }
    /**
     * Find zero or one BuildMode that matches the filter.
     * @param {BuildModeFindUniqueArgs} args - Arguments to find a BuildMode
     * @example
     * // Get one BuildMode
     * const buildMode = await prisma.buildMode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildModeFindUniqueArgs>(args: SelectSubset<T, BuildModeFindUniqueArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuildMode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildModeFindUniqueOrThrowArgs} args - Arguments to find a BuildMode
     * @example
     * // Get one BuildMode
     * const buildMode = await prisma.buildMode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildModeFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildModeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuildMode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeFindFirstArgs} args - Arguments to find a BuildMode
     * @example
     * // Get one BuildMode
     * const buildMode = await prisma.buildMode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildModeFindFirstArgs>(args?: SelectSubset<T, BuildModeFindFirstArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuildMode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeFindFirstOrThrowArgs} args - Arguments to find a BuildMode
     * @example
     * // Get one BuildMode
     * const buildMode = await prisma.buildMode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildModeFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildModeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuildModes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildModes
     * const buildModes = await prisma.buildMode.findMany()
     * 
     * // Get first 10 BuildModes
     * const buildModes = await prisma.buildMode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildModeWithIdOnly = await prisma.buildMode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildModeFindManyArgs>(args?: SelectSubset<T, BuildModeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuildMode.
     * @param {BuildModeCreateArgs} args - Arguments to create a BuildMode.
     * @example
     * // Create one BuildMode
     * const BuildMode = await prisma.buildMode.create({
     *   data: {
     *     // ... data to create a BuildMode
     *   }
     * })
     * 
     */
    create<T extends BuildModeCreateArgs>(args: SelectSubset<T, BuildModeCreateArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuildModes.
     * @param {BuildModeCreateManyArgs} args - Arguments to create many BuildModes.
     * @example
     * // Create many BuildModes
     * const buildMode = await prisma.buildMode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildModeCreateManyArgs>(args?: SelectSubset<T, BuildModeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuildModes and returns the data saved in the database.
     * @param {BuildModeCreateManyAndReturnArgs} args - Arguments to create many BuildModes.
     * @example
     * // Create many BuildModes
     * const buildMode = await prisma.buildMode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuildModes and only return the `id`
     * const buildModeWithIdOnly = await prisma.buildMode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildModeCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildModeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuildMode.
     * @param {BuildModeDeleteArgs} args - Arguments to delete one BuildMode.
     * @example
     * // Delete one BuildMode
     * const BuildMode = await prisma.buildMode.delete({
     *   where: {
     *     // ... filter to delete one BuildMode
     *   }
     * })
     * 
     */
    delete<T extends BuildModeDeleteArgs>(args: SelectSubset<T, BuildModeDeleteArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuildMode.
     * @param {BuildModeUpdateArgs} args - Arguments to update one BuildMode.
     * @example
     * // Update one BuildMode
     * const buildMode = await prisma.buildMode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildModeUpdateArgs>(args: SelectSubset<T, BuildModeUpdateArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuildModes.
     * @param {BuildModeDeleteManyArgs} args - Arguments to filter BuildModes to delete.
     * @example
     * // Delete a few BuildModes
     * const { count } = await prisma.buildMode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildModeDeleteManyArgs>(args?: SelectSubset<T, BuildModeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildModes
     * const buildMode = await prisma.buildMode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildModeUpdateManyArgs>(args: SelectSubset<T, BuildModeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildMode.
     * @param {BuildModeUpsertArgs} args - Arguments to update or create a BuildMode.
     * @example
     * // Update or create a BuildMode
     * const buildMode = await prisma.buildMode.upsert({
     *   create: {
     *     // ... data to create a BuildMode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildMode we want to update
     *   }
     * })
     */
    upsert<T extends BuildModeUpsertArgs>(args: SelectSubset<T, BuildModeUpsertArgs<ExtArgs>>): Prisma__BuildModeClient<$Result.GetResult<Prisma.$BuildModePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuildModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeCountArgs} args - Arguments to filter BuildModes to count.
     * @example
     * // Count the number of BuildModes
     * const count = await prisma.buildMode.count({
     *   where: {
     *     // ... the filter for the BuildModes we want to count
     *   }
     * })
    **/
    count<T extends BuildModeCountArgs>(
      args?: Subset<T, BuildModeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildModeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildModeAggregateArgs>(args: Subset<T, BuildModeAggregateArgs>): Prisma.PrismaPromise<GetBuildModeAggregateType<T>>

    /**
     * Group by BuildMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildModeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildModeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildModeGroupByArgs['orderBy'] }
        : { orderBy?: BuildModeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildModeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildModeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildMode model
   */
  readonly fields: BuildModeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildMode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildModeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    previewBuild<T extends BuildMode$previewBuildArgs<ExtArgs> = {}>(args?: Subset<T, BuildMode$previewBuildArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productionBuild<T extends BuildMode$productionBuildArgs<ExtArgs> = {}>(args?: Subset<T, BuildMode$productionBuildArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuildMode model
   */ 
  interface BuildModeFieldRefs {
    readonly id: FieldRef<"BuildMode", 'String'>
    readonly projectId: FieldRef<"BuildMode", 'String'>
    readonly previewBuildId: FieldRef<"BuildMode", 'String'>
    readonly productionBuildId: FieldRef<"BuildMode", 'String'>
    readonly updatedAt: FieldRef<"BuildMode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuildMode findUnique
   */
  export type BuildModeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter, which BuildMode to fetch.
     */
    where: BuildModeWhereUniqueInput
  }

  /**
   * BuildMode findUniqueOrThrow
   */
  export type BuildModeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter, which BuildMode to fetch.
     */
    where: BuildModeWhereUniqueInput
  }

  /**
   * BuildMode findFirst
   */
  export type BuildModeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter, which BuildMode to fetch.
     */
    where?: BuildModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildModes to fetch.
     */
    orderBy?: BuildModeOrderByWithRelationInput | BuildModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildModes.
     */
    cursor?: BuildModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildModes.
     */
    distinct?: BuildModeScalarFieldEnum | BuildModeScalarFieldEnum[]
  }

  /**
   * BuildMode findFirstOrThrow
   */
  export type BuildModeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter, which BuildMode to fetch.
     */
    where?: BuildModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildModes to fetch.
     */
    orderBy?: BuildModeOrderByWithRelationInput | BuildModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildModes.
     */
    cursor?: BuildModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildModes.
     */
    distinct?: BuildModeScalarFieldEnum | BuildModeScalarFieldEnum[]
  }

  /**
   * BuildMode findMany
   */
  export type BuildModeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter, which BuildModes to fetch.
     */
    where?: BuildModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildModes to fetch.
     */
    orderBy?: BuildModeOrderByWithRelationInput | BuildModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildModes.
     */
    cursor?: BuildModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildModes.
     */
    skip?: number
    distinct?: BuildModeScalarFieldEnum | BuildModeScalarFieldEnum[]
  }

  /**
   * BuildMode create
   */
  export type BuildModeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildMode.
     */
    data: XOR<BuildModeCreateInput, BuildModeUncheckedCreateInput>
  }

  /**
   * BuildMode createMany
   */
  export type BuildModeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildModes.
     */
    data: BuildModeCreateManyInput | BuildModeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildMode createManyAndReturn
   */
  export type BuildModeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuildModes.
     */
    data: BuildModeCreateManyInput | BuildModeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuildMode update
   */
  export type BuildModeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildMode.
     */
    data: XOR<BuildModeUpdateInput, BuildModeUncheckedUpdateInput>
    /**
     * Choose, which BuildMode to update.
     */
    where: BuildModeWhereUniqueInput
  }

  /**
   * BuildMode updateMany
   */
  export type BuildModeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildModes.
     */
    data: XOR<BuildModeUpdateManyMutationInput, BuildModeUncheckedUpdateManyInput>
    /**
     * Filter which BuildModes to update
     */
    where?: BuildModeWhereInput
  }

  /**
   * BuildMode upsert
   */
  export type BuildModeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildMode to update in case it exists.
     */
    where: BuildModeWhereUniqueInput
    /**
     * In case the BuildMode found by the `where` argument doesn't exist, create a new BuildMode with this data.
     */
    create: XOR<BuildModeCreateInput, BuildModeUncheckedCreateInput>
    /**
     * In case the BuildMode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildModeUpdateInput, BuildModeUncheckedUpdateInput>
  }

  /**
   * BuildMode delete
   */
  export type BuildModeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
    /**
     * Filter which BuildMode to delete.
     */
    where: BuildModeWhereUniqueInput
  }

  /**
   * BuildMode deleteMany
   */
  export type BuildModeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildModes to delete
     */
    where?: BuildModeWhereInput
  }

  /**
   * BuildMode.previewBuild
   */
  export type BuildMode$previewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
  }

  /**
   * BuildMode.productionBuild
   */
  export type BuildMode$productionBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
  }

  /**
   * BuildMode without action
   */
  export type BuildModeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildMode
     */
    select?: BuildModeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildModeInclude<ExtArgs> | null
  }


  /**
   * Model BuildChangeLog
   */

  export type AggregateBuildChangeLog = {
    _count: BuildChangeLogCountAggregateOutputType | null
    _min: BuildChangeLogMinAggregateOutputType | null
    _max: BuildChangeLogMaxAggregateOutputType | null
  }

  export type BuildChangeLogMinAggregateOutputType = {
    id: string | null
    buildId: string | null
    featureType: string | null
    changeType: string | null
    itemKey: string | null
    itemLabel: string | null
    changedBy: string | null
    changedAt: Date | null
  }

  export type BuildChangeLogMaxAggregateOutputType = {
    id: string | null
    buildId: string | null
    featureType: string | null
    changeType: string | null
    itemKey: string | null
    itemLabel: string | null
    changedBy: string | null
    changedAt: Date | null
  }

  export type BuildChangeLogCountAggregateOutputType = {
    id: number
    buildId: number
    featureType: number
    changeType: number
    itemKey: number
    itemLabel: number
    oldValue: number
    newValue: number
    changedBy: number
    changedAt: number
    _all: number
  }


  export type BuildChangeLogMinAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    changeType?: true
    itemKey?: true
    itemLabel?: true
    changedBy?: true
    changedAt?: true
  }

  export type BuildChangeLogMaxAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    changeType?: true
    itemKey?: true
    itemLabel?: true
    changedBy?: true
    changedAt?: true
  }

  export type BuildChangeLogCountAggregateInputType = {
    id?: true
    buildId?: true
    featureType?: true
    changeType?: true
    itemKey?: true
    itemLabel?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    changedAt?: true
    _all?: true
  }

  export type BuildChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildChangeLog to aggregate.
     */
    where?: BuildChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildChangeLogs to fetch.
     */
    orderBy?: BuildChangeLogOrderByWithRelationInput | BuildChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildChangeLogs
    **/
    _count?: true | BuildChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildChangeLogMaxAggregateInputType
  }

  export type GetBuildChangeLogAggregateType<T extends BuildChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildChangeLog[P]>
      : GetScalarType<T[P], AggregateBuildChangeLog[P]>
  }




  export type BuildChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildChangeLogWhereInput
    orderBy?: BuildChangeLogOrderByWithAggregationInput | BuildChangeLogOrderByWithAggregationInput[]
    by: BuildChangeLogScalarFieldEnum[] | BuildChangeLogScalarFieldEnum
    having?: BuildChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildChangeLogCountAggregateInputType | true
    _min?: BuildChangeLogMinAggregateInputType
    _max?: BuildChangeLogMaxAggregateInputType
  }

  export type BuildChangeLogGroupByOutputType = {
    id: string
    buildId: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel: string | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    changedBy: string | null
    changedAt: Date
    _count: BuildChangeLogCountAggregateOutputType | null
    _min: BuildChangeLogMinAggregateOutputType | null
    _max: BuildChangeLogMaxAggregateOutputType | null
  }

  type GetBuildChangeLogGroupByPayload<T extends BuildChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], BuildChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type BuildChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    changeType?: boolean
    itemKey?: boolean
    itemLabel?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changedAt?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildChangeLog"]>

  export type BuildChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    changeType?: boolean
    itemKey?: boolean
    itemLabel?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changedAt?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildChangeLog"]>

  export type BuildChangeLogSelectScalar = {
    id?: boolean
    buildId?: boolean
    featureType?: boolean
    changeType?: boolean
    itemKey?: boolean
    itemLabel?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }

  export type BuildChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }
  export type BuildChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }

  export type $BuildChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildChangeLog"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildId: string
      featureType: string
      changeType: string
      itemKey: string
      itemLabel: string | null
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      changedBy: string | null
      changedAt: Date
    }, ExtArgs["result"]["buildChangeLog"]>
    composites: {}
  }

  type BuildChangeLogGetPayload<S extends boolean | null | undefined | BuildChangeLogDefaultArgs> = $Result.GetResult<Prisma.$BuildChangeLogPayload, S>

  type BuildChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildChangeLogCountAggregateInputType | true
    }

  export interface BuildChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildChangeLog'], meta: { name: 'BuildChangeLog' } }
    /**
     * Find zero or one BuildChangeLog that matches the filter.
     * @param {BuildChangeLogFindUniqueArgs} args - Arguments to find a BuildChangeLog
     * @example
     * // Get one BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildChangeLogFindUniqueArgs>(args: SelectSubset<T, BuildChangeLogFindUniqueArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuildChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildChangeLogFindUniqueOrThrowArgs} args - Arguments to find a BuildChangeLog
     * @example
     * // Get one BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuildChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogFindFirstArgs} args - Arguments to find a BuildChangeLog
     * @example
     * // Get one BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildChangeLogFindFirstArgs>(args?: SelectSubset<T, BuildChangeLogFindFirstArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuildChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogFindFirstOrThrowArgs} args - Arguments to find a BuildChangeLog
     * @example
     * // Get one BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuildChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildChangeLogs
     * const buildChangeLogs = await prisma.buildChangeLog.findMany()
     * 
     * // Get first 10 BuildChangeLogs
     * const buildChangeLogs = await prisma.buildChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildChangeLogWithIdOnly = await prisma.buildChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildChangeLogFindManyArgs>(args?: SelectSubset<T, BuildChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuildChangeLog.
     * @param {BuildChangeLogCreateArgs} args - Arguments to create a BuildChangeLog.
     * @example
     * // Create one BuildChangeLog
     * const BuildChangeLog = await prisma.buildChangeLog.create({
     *   data: {
     *     // ... data to create a BuildChangeLog
     *   }
     * })
     * 
     */
    create<T extends BuildChangeLogCreateArgs>(args: SelectSubset<T, BuildChangeLogCreateArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuildChangeLogs.
     * @param {BuildChangeLogCreateManyArgs} args - Arguments to create many BuildChangeLogs.
     * @example
     * // Create many BuildChangeLogs
     * const buildChangeLog = await prisma.buildChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildChangeLogCreateManyArgs>(args?: SelectSubset<T, BuildChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuildChangeLogs and returns the data saved in the database.
     * @param {BuildChangeLogCreateManyAndReturnArgs} args - Arguments to create many BuildChangeLogs.
     * @example
     * // Create many BuildChangeLogs
     * const buildChangeLog = await prisma.buildChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuildChangeLogs and only return the `id`
     * const buildChangeLogWithIdOnly = await prisma.buildChangeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuildChangeLog.
     * @param {BuildChangeLogDeleteArgs} args - Arguments to delete one BuildChangeLog.
     * @example
     * // Delete one BuildChangeLog
     * const BuildChangeLog = await prisma.buildChangeLog.delete({
     *   where: {
     *     // ... filter to delete one BuildChangeLog
     *   }
     * })
     * 
     */
    delete<T extends BuildChangeLogDeleteArgs>(args: SelectSubset<T, BuildChangeLogDeleteArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuildChangeLog.
     * @param {BuildChangeLogUpdateArgs} args - Arguments to update one BuildChangeLog.
     * @example
     * // Update one BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildChangeLogUpdateArgs>(args: SelectSubset<T, BuildChangeLogUpdateArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuildChangeLogs.
     * @param {BuildChangeLogDeleteManyArgs} args - Arguments to filter BuildChangeLogs to delete.
     * @example
     * // Delete a few BuildChangeLogs
     * const { count } = await prisma.buildChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildChangeLogDeleteManyArgs>(args?: SelectSubset<T, BuildChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildChangeLogs
     * const buildChangeLog = await prisma.buildChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildChangeLogUpdateManyArgs>(args: SelectSubset<T, BuildChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildChangeLog.
     * @param {BuildChangeLogUpsertArgs} args - Arguments to update or create a BuildChangeLog.
     * @example
     * // Update or create a BuildChangeLog
     * const buildChangeLog = await prisma.buildChangeLog.upsert({
     *   create: {
     *     // ... data to create a BuildChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends BuildChangeLogUpsertArgs>(args: SelectSubset<T, BuildChangeLogUpsertArgs<ExtArgs>>): Prisma__BuildChangeLogClient<$Result.GetResult<Prisma.$BuildChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuildChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogCountArgs} args - Arguments to filter BuildChangeLogs to count.
     * @example
     * // Count the number of BuildChangeLogs
     * const count = await prisma.buildChangeLog.count({
     *   where: {
     *     // ... the filter for the BuildChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends BuildChangeLogCountArgs>(
      args?: Subset<T, BuildChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildChangeLogAggregateArgs>(args: Subset<T, BuildChangeLogAggregateArgs>): Prisma.PrismaPromise<GetBuildChangeLogAggregateType<T>>

    /**
     * Group by BuildChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: BuildChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildChangeLog model
   */
  readonly fields: BuildChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuildChangeLog model
   */ 
  interface BuildChangeLogFieldRefs {
    readonly id: FieldRef<"BuildChangeLog", 'String'>
    readonly buildId: FieldRef<"BuildChangeLog", 'String'>
    readonly featureType: FieldRef<"BuildChangeLog", 'String'>
    readonly changeType: FieldRef<"BuildChangeLog", 'String'>
    readonly itemKey: FieldRef<"BuildChangeLog", 'String'>
    readonly itemLabel: FieldRef<"BuildChangeLog", 'String'>
    readonly oldValue: FieldRef<"BuildChangeLog", 'Json'>
    readonly newValue: FieldRef<"BuildChangeLog", 'Json'>
    readonly changedBy: FieldRef<"BuildChangeLog", 'String'>
    readonly changedAt: FieldRef<"BuildChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuildChangeLog findUnique
   */
  export type BuildChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which BuildChangeLog to fetch.
     */
    where: BuildChangeLogWhereUniqueInput
  }

  /**
   * BuildChangeLog findUniqueOrThrow
   */
  export type BuildChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which BuildChangeLog to fetch.
     */
    where: BuildChangeLogWhereUniqueInput
  }

  /**
   * BuildChangeLog findFirst
   */
  export type BuildChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which BuildChangeLog to fetch.
     */
    where?: BuildChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildChangeLogs to fetch.
     */
    orderBy?: BuildChangeLogOrderByWithRelationInput | BuildChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildChangeLogs.
     */
    cursor?: BuildChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildChangeLogs.
     */
    distinct?: BuildChangeLogScalarFieldEnum | BuildChangeLogScalarFieldEnum[]
  }

  /**
   * BuildChangeLog findFirstOrThrow
   */
  export type BuildChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which BuildChangeLog to fetch.
     */
    where?: BuildChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildChangeLogs to fetch.
     */
    orderBy?: BuildChangeLogOrderByWithRelationInput | BuildChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildChangeLogs.
     */
    cursor?: BuildChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildChangeLogs.
     */
    distinct?: BuildChangeLogScalarFieldEnum | BuildChangeLogScalarFieldEnum[]
  }

  /**
   * BuildChangeLog findMany
   */
  export type BuildChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which BuildChangeLogs to fetch.
     */
    where?: BuildChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildChangeLogs to fetch.
     */
    orderBy?: BuildChangeLogOrderByWithRelationInput | BuildChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildChangeLogs.
     */
    cursor?: BuildChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildChangeLogs.
     */
    skip?: number
    distinct?: BuildChangeLogScalarFieldEnum | BuildChangeLogScalarFieldEnum[]
  }

  /**
   * BuildChangeLog create
   */
  export type BuildChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildChangeLog.
     */
    data: XOR<BuildChangeLogCreateInput, BuildChangeLogUncheckedCreateInput>
  }

  /**
   * BuildChangeLog createMany
   */
  export type BuildChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildChangeLogs.
     */
    data: BuildChangeLogCreateManyInput | BuildChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildChangeLog createManyAndReturn
   */
  export type BuildChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuildChangeLogs.
     */
    data: BuildChangeLogCreateManyInput | BuildChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuildChangeLog update
   */
  export type BuildChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildChangeLog.
     */
    data: XOR<BuildChangeLogUpdateInput, BuildChangeLogUncheckedUpdateInput>
    /**
     * Choose, which BuildChangeLog to update.
     */
    where: BuildChangeLogWhereUniqueInput
  }

  /**
   * BuildChangeLog updateMany
   */
  export type BuildChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildChangeLogs.
     */
    data: XOR<BuildChangeLogUpdateManyMutationInput, BuildChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which BuildChangeLogs to update
     */
    where?: BuildChangeLogWhereInput
  }

  /**
   * BuildChangeLog upsert
   */
  export type BuildChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildChangeLog to update in case it exists.
     */
    where: BuildChangeLogWhereUniqueInput
    /**
     * In case the BuildChangeLog found by the `where` argument doesn't exist, create a new BuildChangeLog with this data.
     */
    create: XOR<BuildChangeLogCreateInput, BuildChangeLogUncheckedCreateInput>
    /**
     * In case the BuildChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildChangeLogUpdateInput, BuildChangeLogUncheckedUpdateInput>
  }

  /**
   * BuildChangeLog delete
   */
  export type BuildChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
    /**
     * Filter which BuildChangeLog to delete.
     */
    where: BuildChangeLogWhereUniqueInput
  }

  /**
   * BuildChangeLog deleteMany
   */
  export type BuildChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildChangeLogs to delete
     */
    where?: BuildChangeLogWhereInput
  }

  /**
   * BuildChangeLog without action
   */
  export type BuildChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildChangeLog
     */
    select?: BuildChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model MockEnvironment
   */

  export type AggregateMockEnvironment = {
    _count: MockEnvironmentCountAggregateOutputType | null
    _min: MockEnvironmentMinAggregateOutputType | null
    _max: MockEnvironmentMaxAggregateOutputType | null
  }

  export type MockEnvironmentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    basePath: string | null
    mode: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockEnvironmentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    basePath: string | null
    mode: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockEnvironmentCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    basePath: number
    mode: number
    whitelist: number
    blacklist: number
    isEnabled: number
    isDefault: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MockEnvironmentMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    basePath?: true
    mode?: true
    isEnabled?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockEnvironmentMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    basePath?: true
    mode?: true
    isEnabled?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockEnvironmentCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    basePath?: true
    mode?: true
    whitelist?: true
    blacklist?: true
    isEnabled?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MockEnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockEnvironment to aggregate.
     */
    where?: MockEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEnvironments to fetch.
     */
    orderBy?: MockEnvironmentOrderByWithRelationInput | MockEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockEnvironments
    **/
    _count?: true | MockEnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockEnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockEnvironmentMaxAggregateInputType
  }

  export type GetMockEnvironmentAggregateType<T extends MockEnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMockEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockEnvironment[P]>
      : GetScalarType<T[P], AggregateMockEnvironment[P]>
  }




  export type MockEnvironmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockEnvironmentWhereInput
    orderBy?: MockEnvironmentOrderByWithAggregationInput | MockEnvironmentOrderByWithAggregationInput[]
    by: MockEnvironmentScalarFieldEnum[] | MockEnvironmentScalarFieldEnum
    having?: MockEnvironmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockEnvironmentCountAggregateInputType | true
    _min?: MockEnvironmentMinAggregateInputType
    _max?: MockEnvironmentMaxAggregateInputType
  }

  export type MockEnvironmentGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    basePath: string | null
    mode: string
    whitelist: string[]
    blacklist: string[]
    isEnabled: boolean
    isDefault: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: MockEnvironmentCountAggregateOutputType | null
    _min: MockEnvironmentMinAggregateOutputType | null
    _max: MockEnvironmentMaxAggregateOutputType | null
  }

  type GetMockEnvironmentGroupByPayload<T extends MockEnvironmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockEnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockEnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockEnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], MockEnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type MockEnvironmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    basePath?: boolean
    mode?: boolean
    whitelist?: boolean
    blacklist?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    endpoints?: boolean | MockEnvironment$endpointsArgs<ExtArgs>
    _count?: boolean | MockEnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockEnvironment"]>

  export type MockEnvironmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    basePath?: boolean
    mode?: boolean
    whitelist?: boolean
    blacklist?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockEnvironment"]>

  export type MockEnvironmentSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    basePath?: boolean
    mode?: boolean
    whitelist?: boolean
    blacklist?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MockEnvironmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    endpoints?: boolean | MockEnvironment$endpointsArgs<ExtArgs>
    _count?: boolean | MockEnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MockEnvironmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MockEnvironmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockEnvironment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      endpoints: Prisma.$MockEndpointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      basePath: string | null
      mode: string
      whitelist: string[]
      blacklist: string[]
      isEnabled: boolean
      isDefault: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mockEnvironment"]>
    composites: {}
  }

  type MockEnvironmentGetPayload<S extends boolean | null | undefined | MockEnvironmentDefaultArgs> = $Result.GetResult<Prisma.$MockEnvironmentPayload, S>

  type MockEnvironmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MockEnvironmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MockEnvironmentCountAggregateInputType | true
    }

  export interface MockEnvironmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockEnvironment'], meta: { name: 'MockEnvironment' } }
    /**
     * Find zero or one MockEnvironment that matches the filter.
     * @param {MockEnvironmentFindUniqueArgs} args - Arguments to find a MockEnvironment
     * @example
     * // Get one MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockEnvironmentFindUniqueArgs>(args: SelectSubset<T, MockEnvironmentFindUniqueArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MockEnvironment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MockEnvironmentFindUniqueOrThrowArgs} args - Arguments to find a MockEnvironment
     * @example
     * // Get one MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockEnvironmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MockEnvironmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MockEnvironment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentFindFirstArgs} args - Arguments to find a MockEnvironment
     * @example
     * // Get one MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockEnvironmentFindFirstArgs>(args?: SelectSubset<T, MockEnvironmentFindFirstArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MockEnvironment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentFindFirstOrThrowArgs} args - Arguments to find a MockEnvironment
     * @example
     * // Get one MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockEnvironmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MockEnvironmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MockEnvironments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockEnvironments
     * const mockEnvironments = await prisma.mockEnvironment.findMany()
     * 
     * // Get first 10 MockEnvironments
     * const mockEnvironments = await prisma.mockEnvironment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockEnvironmentWithIdOnly = await prisma.mockEnvironment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockEnvironmentFindManyArgs>(args?: SelectSubset<T, MockEnvironmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MockEnvironment.
     * @param {MockEnvironmentCreateArgs} args - Arguments to create a MockEnvironment.
     * @example
     * // Create one MockEnvironment
     * const MockEnvironment = await prisma.mockEnvironment.create({
     *   data: {
     *     // ... data to create a MockEnvironment
     *   }
     * })
     * 
     */
    create<T extends MockEnvironmentCreateArgs>(args: SelectSubset<T, MockEnvironmentCreateArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MockEnvironments.
     * @param {MockEnvironmentCreateManyArgs} args - Arguments to create many MockEnvironments.
     * @example
     * // Create many MockEnvironments
     * const mockEnvironment = await prisma.mockEnvironment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockEnvironmentCreateManyArgs>(args?: SelectSubset<T, MockEnvironmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockEnvironments and returns the data saved in the database.
     * @param {MockEnvironmentCreateManyAndReturnArgs} args - Arguments to create many MockEnvironments.
     * @example
     * // Create many MockEnvironments
     * const mockEnvironment = await prisma.mockEnvironment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockEnvironments and only return the `id`
     * const mockEnvironmentWithIdOnly = await prisma.mockEnvironment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockEnvironmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MockEnvironmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MockEnvironment.
     * @param {MockEnvironmentDeleteArgs} args - Arguments to delete one MockEnvironment.
     * @example
     * // Delete one MockEnvironment
     * const MockEnvironment = await prisma.mockEnvironment.delete({
     *   where: {
     *     // ... filter to delete one MockEnvironment
     *   }
     * })
     * 
     */
    delete<T extends MockEnvironmentDeleteArgs>(args: SelectSubset<T, MockEnvironmentDeleteArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MockEnvironment.
     * @param {MockEnvironmentUpdateArgs} args - Arguments to update one MockEnvironment.
     * @example
     * // Update one MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockEnvironmentUpdateArgs>(args: SelectSubset<T, MockEnvironmentUpdateArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MockEnvironments.
     * @param {MockEnvironmentDeleteManyArgs} args - Arguments to filter MockEnvironments to delete.
     * @example
     * // Delete a few MockEnvironments
     * const { count } = await prisma.mockEnvironment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockEnvironmentDeleteManyArgs>(args?: SelectSubset<T, MockEnvironmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockEnvironments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockEnvironments
     * const mockEnvironment = await prisma.mockEnvironment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockEnvironmentUpdateManyArgs>(args: SelectSubset<T, MockEnvironmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MockEnvironment.
     * @param {MockEnvironmentUpsertArgs} args - Arguments to update or create a MockEnvironment.
     * @example
     * // Update or create a MockEnvironment
     * const mockEnvironment = await prisma.mockEnvironment.upsert({
     *   create: {
     *     // ... data to create a MockEnvironment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockEnvironment we want to update
     *   }
     * })
     */
    upsert<T extends MockEnvironmentUpsertArgs>(args: SelectSubset<T, MockEnvironmentUpsertArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MockEnvironments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentCountArgs} args - Arguments to filter MockEnvironments to count.
     * @example
     * // Count the number of MockEnvironments
     * const count = await prisma.mockEnvironment.count({
     *   where: {
     *     // ... the filter for the MockEnvironments we want to count
     *   }
     * })
    **/
    count<T extends MockEnvironmentCountArgs>(
      args?: Subset<T, MockEnvironmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockEnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockEnvironment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockEnvironmentAggregateArgs>(args: Subset<T, MockEnvironmentAggregateArgs>): Prisma.PrismaPromise<GetMockEnvironmentAggregateType<T>>

    /**
     * Group by MockEnvironment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEnvironmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockEnvironmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockEnvironmentGroupByArgs['orderBy'] }
        : { orderBy?: MockEnvironmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockEnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockEnvironment model
   */
  readonly fields: MockEnvironmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockEnvironment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockEnvironmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    endpoints<T extends MockEnvironment$endpointsArgs<ExtArgs> = {}>(args?: Subset<T, MockEnvironment$endpointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockEnvironment model
   */ 
  interface MockEnvironmentFieldRefs {
    readonly id: FieldRef<"MockEnvironment", 'String'>
    readonly projectId: FieldRef<"MockEnvironment", 'String'>
    readonly name: FieldRef<"MockEnvironment", 'String'>
    readonly description: FieldRef<"MockEnvironment", 'String'>
    readonly basePath: FieldRef<"MockEnvironment", 'String'>
    readonly mode: FieldRef<"MockEnvironment", 'String'>
    readonly whitelist: FieldRef<"MockEnvironment", 'String[]'>
    readonly blacklist: FieldRef<"MockEnvironment", 'String[]'>
    readonly isEnabled: FieldRef<"MockEnvironment", 'Boolean'>
    readonly isDefault: FieldRef<"MockEnvironment", 'Boolean'>
    readonly createdBy: FieldRef<"MockEnvironment", 'String'>
    readonly createdAt: FieldRef<"MockEnvironment", 'DateTime'>
    readonly updatedAt: FieldRef<"MockEnvironment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockEnvironment findUnique
   */
  export type MockEnvironmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which MockEnvironment to fetch.
     */
    where: MockEnvironmentWhereUniqueInput
  }

  /**
   * MockEnvironment findUniqueOrThrow
   */
  export type MockEnvironmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which MockEnvironment to fetch.
     */
    where: MockEnvironmentWhereUniqueInput
  }

  /**
   * MockEnvironment findFirst
   */
  export type MockEnvironmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which MockEnvironment to fetch.
     */
    where?: MockEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEnvironments to fetch.
     */
    orderBy?: MockEnvironmentOrderByWithRelationInput | MockEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockEnvironments.
     */
    cursor?: MockEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockEnvironments.
     */
    distinct?: MockEnvironmentScalarFieldEnum | MockEnvironmentScalarFieldEnum[]
  }

  /**
   * MockEnvironment findFirstOrThrow
   */
  export type MockEnvironmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which MockEnvironment to fetch.
     */
    where?: MockEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEnvironments to fetch.
     */
    orderBy?: MockEnvironmentOrderByWithRelationInput | MockEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockEnvironments.
     */
    cursor?: MockEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEnvironments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockEnvironments.
     */
    distinct?: MockEnvironmentScalarFieldEnum | MockEnvironmentScalarFieldEnum[]
  }

  /**
   * MockEnvironment findMany
   */
  export type MockEnvironmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which MockEnvironments to fetch.
     */
    where?: MockEnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEnvironments to fetch.
     */
    orderBy?: MockEnvironmentOrderByWithRelationInput | MockEnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockEnvironments.
     */
    cursor?: MockEnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEnvironments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEnvironments.
     */
    skip?: number
    distinct?: MockEnvironmentScalarFieldEnum | MockEnvironmentScalarFieldEnum[]
  }

  /**
   * MockEnvironment create
   */
  export type MockEnvironmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MockEnvironment.
     */
    data: XOR<MockEnvironmentCreateInput, MockEnvironmentUncheckedCreateInput>
  }

  /**
   * MockEnvironment createMany
   */
  export type MockEnvironmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockEnvironments.
     */
    data: MockEnvironmentCreateManyInput | MockEnvironmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockEnvironment createManyAndReturn
   */
  export type MockEnvironmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MockEnvironments.
     */
    data: MockEnvironmentCreateManyInput | MockEnvironmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockEnvironment update
   */
  export type MockEnvironmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MockEnvironment.
     */
    data: XOR<MockEnvironmentUpdateInput, MockEnvironmentUncheckedUpdateInput>
    /**
     * Choose, which MockEnvironment to update.
     */
    where: MockEnvironmentWhereUniqueInput
  }

  /**
   * MockEnvironment updateMany
   */
  export type MockEnvironmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockEnvironments.
     */
    data: XOR<MockEnvironmentUpdateManyMutationInput, MockEnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which MockEnvironments to update
     */
    where?: MockEnvironmentWhereInput
  }

  /**
   * MockEnvironment upsert
   */
  export type MockEnvironmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MockEnvironment to update in case it exists.
     */
    where: MockEnvironmentWhereUniqueInput
    /**
     * In case the MockEnvironment found by the `where` argument doesn't exist, create a new MockEnvironment with this data.
     */
    create: XOR<MockEnvironmentCreateInput, MockEnvironmentUncheckedCreateInput>
    /**
     * In case the MockEnvironment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockEnvironmentUpdateInput, MockEnvironmentUncheckedUpdateInput>
  }

  /**
   * MockEnvironment delete
   */
  export type MockEnvironmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
    /**
     * Filter which MockEnvironment to delete.
     */
    where: MockEnvironmentWhereUniqueInput
  }

  /**
   * MockEnvironment deleteMany
   */
  export type MockEnvironmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockEnvironments to delete
     */
    where?: MockEnvironmentWhereInput
  }

  /**
   * MockEnvironment.endpoints
   */
  export type MockEnvironment$endpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    where?: MockEndpointWhereInput
    orderBy?: MockEndpointOrderByWithRelationInput | MockEndpointOrderByWithRelationInput[]
    cursor?: MockEndpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockEndpointScalarFieldEnum | MockEndpointScalarFieldEnum[]
  }

  /**
   * MockEnvironment without action
   */
  export type MockEnvironmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEnvironment
     */
    select?: MockEnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEnvironmentInclude<ExtArgs> | null
  }


  /**
   * Model MockEndpoint
   */

  export type AggregateMockEndpoint = {
    _count: MockEndpointCountAggregateOutputType | null
    _avg: MockEndpointAvgAggregateOutputType | null
    _sum: MockEndpointSumAggregateOutputType | null
    _min: MockEndpointMinAggregateOutputType | null
    _max: MockEndpointMaxAggregateOutputType | null
  }

  export type MockEndpointAvgAggregateOutputType = {
    order: number | null
  }

  export type MockEndpointSumAggregateOutputType = {
    order: number | null
  }

  export type MockEndpointMinAggregateOutputType = {
    id: string | null
    environmentId: string | null
    path: string | null
    method: string | null
    description: string | null
    isEnabled: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockEndpointMaxAggregateOutputType = {
    id: string | null
    environmentId: string | null
    path: string | null
    method: string | null
    description: string | null
    isEnabled: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockEndpointCountAggregateOutputType = {
    id: number
    environmentId: number
    path: number
    method: number
    description: number
    isEnabled: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MockEndpointAvgAggregateInputType = {
    order?: true
  }

  export type MockEndpointSumAggregateInputType = {
    order?: true
  }

  export type MockEndpointMinAggregateInputType = {
    id?: true
    environmentId?: true
    path?: true
    method?: true
    description?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockEndpointMaxAggregateInputType = {
    id?: true
    environmentId?: true
    path?: true
    method?: true
    description?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockEndpointCountAggregateInputType = {
    id?: true
    environmentId?: true
    path?: true
    method?: true
    description?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MockEndpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockEndpoint to aggregate.
     */
    where?: MockEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEndpoints to fetch.
     */
    orderBy?: MockEndpointOrderByWithRelationInput | MockEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockEndpoints
    **/
    _count?: true | MockEndpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MockEndpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MockEndpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockEndpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockEndpointMaxAggregateInputType
  }

  export type GetMockEndpointAggregateType<T extends MockEndpointAggregateArgs> = {
        [P in keyof T & keyof AggregateMockEndpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockEndpoint[P]>
      : GetScalarType<T[P], AggregateMockEndpoint[P]>
  }




  export type MockEndpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockEndpointWhereInput
    orderBy?: MockEndpointOrderByWithAggregationInput | MockEndpointOrderByWithAggregationInput[]
    by: MockEndpointScalarFieldEnum[] | MockEndpointScalarFieldEnum
    having?: MockEndpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockEndpointCountAggregateInputType | true
    _avg?: MockEndpointAvgAggregateInputType
    _sum?: MockEndpointSumAggregateInputType
    _min?: MockEndpointMinAggregateInputType
    _max?: MockEndpointMaxAggregateInputType
  }

  export type MockEndpointGroupByOutputType = {
    id: string
    environmentId: string
    path: string
    method: string
    description: string | null
    isEnabled: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: MockEndpointCountAggregateOutputType | null
    _avg: MockEndpointAvgAggregateOutputType | null
    _sum: MockEndpointSumAggregateOutputType | null
    _min: MockEndpointMinAggregateOutputType | null
    _max: MockEndpointMaxAggregateOutputType | null
  }

  type GetMockEndpointGroupByPayload<T extends MockEndpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockEndpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockEndpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockEndpointGroupByOutputType[P]>
            : GetScalarType<T[P], MockEndpointGroupByOutputType[P]>
        }
      >
    >


  export type MockEndpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    environmentId?: boolean
    path?: boolean
    method?: boolean
    description?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    environment?: boolean | MockEnvironmentDefaultArgs<ExtArgs>
    responses?: boolean | MockEndpoint$responsesArgs<ExtArgs>
    conditions?: boolean | MockEndpoint$conditionsArgs<ExtArgs>
    _count?: boolean | MockEndpointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockEndpoint"]>

  export type MockEndpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    environmentId?: boolean
    path?: boolean
    method?: boolean
    description?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    environment?: boolean | MockEnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockEndpoint"]>

  export type MockEndpointSelectScalar = {
    id?: boolean
    environmentId?: boolean
    path?: boolean
    method?: boolean
    description?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MockEndpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | MockEnvironmentDefaultArgs<ExtArgs>
    responses?: boolean | MockEndpoint$responsesArgs<ExtArgs>
    conditions?: boolean | MockEndpoint$conditionsArgs<ExtArgs>
    _count?: boolean | MockEndpointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MockEndpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | MockEnvironmentDefaultArgs<ExtArgs>
  }

  export type $MockEndpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockEndpoint"
    objects: {
      environment: Prisma.$MockEnvironmentPayload<ExtArgs>
      responses: Prisma.$MockResponsePayload<ExtArgs>[]
      conditions: Prisma.$MockConditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      environmentId: string
      path: string
      method: string
      description: string | null
      isEnabled: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mockEndpoint"]>
    composites: {}
  }

  type MockEndpointGetPayload<S extends boolean | null | undefined | MockEndpointDefaultArgs> = $Result.GetResult<Prisma.$MockEndpointPayload, S>

  type MockEndpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MockEndpointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MockEndpointCountAggregateInputType | true
    }

  export interface MockEndpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockEndpoint'], meta: { name: 'MockEndpoint' } }
    /**
     * Find zero or one MockEndpoint that matches the filter.
     * @param {MockEndpointFindUniqueArgs} args - Arguments to find a MockEndpoint
     * @example
     * // Get one MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockEndpointFindUniqueArgs>(args: SelectSubset<T, MockEndpointFindUniqueArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MockEndpoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MockEndpointFindUniqueOrThrowArgs} args - Arguments to find a MockEndpoint
     * @example
     * // Get one MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockEndpointFindUniqueOrThrowArgs>(args: SelectSubset<T, MockEndpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MockEndpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointFindFirstArgs} args - Arguments to find a MockEndpoint
     * @example
     * // Get one MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockEndpointFindFirstArgs>(args?: SelectSubset<T, MockEndpointFindFirstArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MockEndpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointFindFirstOrThrowArgs} args - Arguments to find a MockEndpoint
     * @example
     * // Get one MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockEndpointFindFirstOrThrowArgs>(args?: SelectSubset<T, MockEndpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MockEndpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockEndpoints
     * const mockEndpoints = await prisma.mockEndpoint.findMany()
     * 
     * // Get first 10 MockEndpoints
     * const mockEndpoints = await prisma.mockEndpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockEndpointWithIdOnly = await prisma.mockEndpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockEndpointFindManyArgs>(args?: SelectSubset<T, MockEndpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MockEndpoint.
     * @param {MockEndpointCreateArgs} args - Arguments to create a MockEndpoint.
     * @example
     * // Create one MockEndpoint
     * const MockEndpoint = await prisma.mockEndpoint.create({
     *   data: {
     *     // ... data to create a MockEndpoint
     *   }
     * })
     * 
     */
    create<T extends MockEndpointCreateArgs>(args: SelectSubset<T, MockEndpointCreateArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MockEndpoints.
     * @param {MockEndpointCreateManyArgs} args - Arguments to create many MockEndpoints.
     * @example
     * // Create many MockEndpoints
     * const mockEndpoint = await prisma.mockEndpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockEndpointCreateManyArgs>(args?: SelectSubset<T, MockEndpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockEndpoints and returns the data saved in the database.
     * @param {MockEndpointCreateManyAndReturnArgs} args - Arguments to create many MockEndpoints.
     * @example
     * // Create many MockEndpoints
     * const mockEndpoint = await prisma.mockEndpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockEndpoints and only return the `id`
     * const mockEndpointWithIdOnly = await prisma.mockEndpoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockEndpointCreateManyAndReturnArgs>(args?: SelectSubset<T, MockEndpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MockEndpoint.
     * @param {MockEndpointDeleteArgs} args - Arguments to delete one MockEndpoint.
     * @example
     * // Delete one MockEndpoint
     * const MockEndpoint = await prisma.mockEndpoint.delete({
     *   where: {
     *     // ... filter to delete one MockEndpoint
     *   }
     * })
     * 
     */
    delete<T extends MockEndpointDeleteArgs>(args: SelectSubset<T, MockEndpointDeleteArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MockEndpoint.
     * @param {MockEndpointUpdateArgs} args - Arguments to update one MockEndpoint.
     * @example
     * // Update one MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockEndpointUpdateArgs>(args: SelectSubset<T, MockEndpointUpdateArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MockEndpoints.
     * @param {MockEndpointDeleteManyArgs} args - Arguments to filter MockEndpoints to delete.
     * @example
     * // Delete a few MockEndpoints
     * const { count } = await prisma.mockEndpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockEndpointDeleteManyArgs>(args?: SelectSubset<T, MockEndpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockEndpoints
     * const mockEndpoint = await prisma.mockEndpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockEndpointUpdateManyArgs>(args: SelectSubset<T, MockEndpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MockEndpoint.
     * @param {MockEndpointUpsertArgs} args - Arguments to update or create a MockEndpoint.
     * @example
     * // Update or create a MockEndpoint
     * const mockEndpoint = await prisma.mockEndpoint.upsert({
     *   create: {
     *     // ... data to create a MockEndpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockEndpoint we want to update
     *   }
     * })
     */
    upsert<T extends MockEndpointUpsertArgs>(args: SelectSubset<T, MockEndpointUpsertArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MockEndpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointCountArgs} args - Arguments to filter MockEndpoints to count.
     * @example
     * // Count the number of MockEndpoints
     * const count = await prisma.mockEndpoint.count({
     *   where: {
     *     // ... the filter for the MockEndpoints we want to count
     *   }
     * })
    **/
    count<T extends MockEndpointCountArgs>(
      args?: Subset<T, MockEndpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockEndpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockEndpointAggregateArgs>(args: Subset<T, MockEndpointAggregateArgs>): Prisma.PrismaPromise<GetMockEndpointAggregateType<T>>

    /**
     * Group by MockEndpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockEndpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockEndpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockEndpointGroupByArgs['orderBy'] }
        : { orderBy?: MockEndpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockEndpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockEndpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockEndpoint model
   */
  readonly fields: MockEndpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockEndpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockEndpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends MockEnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MockEnvironmentDefaultArgs<ExtArgs>>): Prisma__MockEnvironmentClient<$Result.GetResult<Prisma.$MockEnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends MockEndpoint$responsesArgs<ExtArgs> = {}>(args?: Subset<T, MockEndpoint$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findMany"> | Null>
    conditions<T extends MockEndpoint$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, MockEndpoint$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockEndpoint model
   */ 
  interface MockEndpointFieldRefs {
    readonly id: FieldRef<"MockEndpoint", 'String'>
    readonly environmentId: FieldRef<"MockEndpoint", 'String'>
    readonly path: FieldRef<"MockEndpoint", 'String'>
    readonly method: FieldRef<"MockEndpoint", 'String'>
    readonly description: FieldRef<"MockEndpoint", 'String'>
    readonly isEnabled: FieldRef<"MockEndpoint", 'Boolean'>
    readonly order: FieldRef<"MockEndpoint", 'Int'>
    readonly createdAt: FieldRef<"MockEndpoint", 'DateTime'>
    readonly updatedAt: FieldRef<"MockEndpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockEndpoint findUnique
   */
  export type MockEndpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter, which MockEndpoint to fetch.
     */
    where: MockEndpointWhereUniqueInput
  }

  /**
   * MockEndpoint findUniqueOrThrow
   */
  export type MockEndpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter, which MockEndpoint to fetch.
     */
    where: MockEndpointWhereUniqueInput
  }

  /**
   * MockEndpoint findFirst
   */
  export type MockEndpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter, which MockEndpoint to fetch.
     */
    where?: MockEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEndpoints to fetch.
     */
    orderBy?: MockEndpointOrderByWithRelationInput | MockEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockEndpoints.
     */
    cursor?: MockEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockEndpoints.
     */
    distinct?: MockEndpointScalarFieldEnum | MockEndpointScalarFieldEnum[]
  }

  /**
   * MockEndpoint findFirstOrThrow
   */
  export type MockEndpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter, which MockEndpoint to fetch.
     */
    where?: MockEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEndpoints to fetch.
     */
    orderBy?: MockEndpointOrderByWithRelationInput | MockEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockEndpoints.
     */
    cursor?: MockEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEndpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockEndpoints.
     */
    distinct?: MockEndpointScalarFieldEnum | MockEndpointScalarFieldEnum[]
  }

  /**
   * MockEndpoint findMany
   */
  export type MockEndpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter, which MockEndpoints to fetch.
     */
    where?: MockEndpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockEndpoints to fetch.
     */
    orderBy?: MockEndpointOrderByWithRelationInput | MockEndpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockEndpoints.
     */
    cursor?: MockEndpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockEndpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockEndpoints.
     */
    skip?: number
    distinct?: MockEndpointScalarFieldEnum | MockEndpointScalarFieldEnum[]
  }

  /**
   * MockEndpoint create
   */
  export type MockEndpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * The data needed to create a MockEndpoint.
     */
    data: XOR<MockEndpointCreateInput, MockEndpointUncheckedCreateInput>
  }

  /**
   * MockEndpoint createMany
   */
  export type MockEndpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockEndpoints.
     */
    data: MockEndpointCreateManyInput | MockEndpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockEndpoint createManyAndReturn
   */
  export type MockEndpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MockEndpoints.
     */
    data: MockEndpointCreateManyInput | MockEndpointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockEndpoint update
   */
  export type MockEndpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * The data needed to update a MockEndpoint.
     */
    data: XOR<MockEndpointUpdateInput, MockEndpointUncheckedUpdateInput>
    /**
     * Choose, which MockEndpoint to update.
     */
    where: MockEndpointWhereUniqueInput
  }

  /**
   * MockEndpoint updateMany
   */
  export type MockEndpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockEndpoints.
     */
    data: XOR<MockEndpointUpdateManyMutationInput, MockEndpointUncheckedUpdateManyInput>
    /**
     * Filter which MockEndpoints to update
     */
    where?: MockEndpointWhereInput
  }

  /**
   * MockEndpoint upsert
   */
  export type MockEndpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * The filter to search for the MockEndpoint to update in case it exists.
     */
    where: MockEndpointWhereUniqueInput
    /**
     * In case the MockEndpoint found by the `where` argument doesn't exist, create a new MockEndpoint with this data.
     */
    create: XOR<MockEndpointCreateInput, MockEndpointUncheckedCreateInput>
    /**
     * In case the MockEndpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockEndpointUpdateInput, MockEndpointUncheckedUpdateInput>
  }

  /**
   * MockEndpoint delete
   */
  export type MockEndpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    /**
     * Filter which MockEndpoint to delete.
     */
    where: MockEndpointWhereUniqueInput
  }

  /**
   * MockEndpoint deleteMany
   */
  export type MockEndpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockEndpoints to delete
     */
    where?: MockEndpointWhereInput
  }

  /**
   * MockEndpoint.responses
   */
  export type MockEndpoint$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    where?: MockResponseWhereInput
    orderBy?: MockResponseOrderByWithRelationInput | MockResponseOrderByWithRelationInput[]
    cursor?: MockResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockResponseScalarFieldEnum | MockResponseScalarFieldEnum[]
  }

  /**
   * MockEndpoint.conditions
   */
  export type MockEndpoint$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    where?: MockConditionWhereInput
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    cursor?: MockConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockConditionScalarFieldEnum | MockConditionScalarFieldEnum[]
  }

  /**
   * MockEndpoint without action
   */
  export type MockEndpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
  }


  /**
   * Model MockResponse
   */

  export type AggregateMockResponse = {
    _count: MockResponseCountAggregateOutputType | null
    _avg: MockResponseAvgAggregateOutputType | null
    _sum: MockResponseSumAggregateOutputType | null
    _min: MockResponseMinAggregateOutputType | null
    _max: MockResponseMaxAggregateOutputType | null
  }

  export type MockResponseAvgAggregateOutputType = {
    statusCode: number | null
    delay: number | null
    order: number | null
  }

  export type MockResponseSumAggregateOutputType = {
    statusCode: number | null
    delay: number | null
    order: number | null
  }

  export type MockResponseMinAggregateOutputType = {
    id: string | null
    endpointId: string | null
    statusCode: number | null
    name: string | null
    description: string | null
    delay: number | null
    isDefault: boolean | null
    isEnabled: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockResponseMaxAggregateOutputType = {
    id: string | null
    endpointId: string | null
    statusCode: number | null
    name: string | null
    description: string | null
    delay: number | null
    isDefault: boolean | null
    isEnabled: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MockResponseCountAggregateOutputType = {
    id: number
    endpointId: number
    statusCode: number
    name: number
    description: number
    responseBody: number
    responseHeaders: number
    delay: number
    isDefault: number
    isEnabled: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MockResponseAvgAggregateInputType = {
    statusCode?: true
    delay?: true
    order?: true
  }

  export type MockResponseSumAggregateInputType = {
    statusCode?: true
    delay?: true
    order?: true
  }

  export type MockResponseMinAggregateInputType = {
    id?: true
    endpointId?: true
    statusCode?: true
    name?: true
    description?: true
    delay?: true
    isDefault?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockResponseMaxAggregateInputType = {
    id?: true
    endpointId?: true
    statusCode?: true
    name?: true
    description?: true
    delay?: true
    isDefault?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MockResponseCountAggregateInputType = {
    id?: true
    endpointId?: true
    statusCode?: true
    name?: true
    description?: true
    responseBody?: true
    responseHeaders?: true
    delay?: true
    isDefault?: true
    isEnabled?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MockResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockResponse to aggregate.
     */
    where?: MockResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockResponses to fetch.
     */
    orderBy?: MockResponseOrderByWithRelationInput | MockResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockResponses
    **/
    _count?: true | MockResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MockResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MockResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockResponseMaxAggregateInputType
  }

  export type GetMockResponseAggregateType<T extends MockResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateMockResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockResponse[P]>
      : GetScalarType<T[P], AggregateMockResponse[P]>
  }




  export type MockResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockResponseWhereInput
    orderBy?: MockResponseOrderByWithAggregationInput | MockResponseOrderByWithAggregationInput[]
    by: MockResponseScalarFieldEnum[] | MockResponseScalarFieldEnum
    having?: MockResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockResponseCountAggregateInputType | true
    _avg?: MockResponseAvgAggregateInputType
    _sum?: MockResponseSumAggregateInputType
    _min?: MockResponseMinAggregateInputType
    _max?: MockResponseMaxAggregateInputType
  }

  export type MockResponseGroupByOutputType = {
    id: string
    endpointId: string
    statusCode: number
    name: string | null
    description: string | null
    responseBody: JsonValue | null
    responseHeaders: JsonValue | null
    delay: number
    isDefault: boolean
    isEnabled: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: MockResponseCountAggregateOutputType | null
    _avg: MockResponseAvgAggregateOutputType | null
    _sum: MockResponseSumAggregateOutputType | null
    _min: MockResponseMinAggregateOutputType | null
    _max: MockResponseMaxAggregateOutputType | null
  }

  type GetMockResponseGroupByPayload<T extends MockResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockResponseGroupByOutputType[P]>
            : GetScalarType<T[P], MockResponseGroupByOutputType[P]>
        }
      >
    >


  export type MockResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpointId?: boolean
    statusCode?: boolean
    name?: boolean
    description?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    delay?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endpoint?: boolean | MockEndpointDefaultArgs<ExtArgs>
    conditions?: boolean | MockResponse$conditionsArgs<ExtArgs>
    _count?: boolean | MockResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockResponse"]>

  export type MockResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpointId?: boolean
    statusCode?: boolean
    name?: boolean
    description?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    delay?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endpoint?: boolean | MockEndpointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockResponse"]>

  export type MockResponseSelectScalar = {
    id?: boolean
    endpointId?: boolean
    statusCode?: boolean
    name?: boolean
    description?: boolean
    responseBody?: boolean
    responseHeaders?: boolean
    delay?: boolean
    isDefault?: boolean
    isEnabled?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MockResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoint?: boolean | MockEndpointDefaultArgs<ExtArgs>
    conditions?: boolean | MockResponse$conditionsArgs<ExtArgs>
    _count?: boolean | MockResponseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MockResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endpoint?: boolean | MockEndpointDefaultArgs<ExtArgs>
  }

  export type $MockResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockResponse"
    objects: {
      endpoint: Prisma.$MockEndpointPayload<ExtArgs>
      conditions: Prisma.$MockConditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpointId: string
      statusCode: number
      name: string | null
      description: string | null
      responseBody: Prisma.JsonValue | null
      responseHeaders: Prisma.JsonValue | null
      delay: number
      isDefault: boolean
      isEnabled: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mockResponse"]>
    composites: {}
  }

  type MockResponseGetPayload<S extends boolean | null | undefined | MockResponseDefaultArgs> = $Result.GetResult<Prisma.$MockResponsePayload, S>

  type MockResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MockResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MockResponseCountAggregateInputType | true
    }

  export interface MockResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockResponse'], meta: { name: 'MockResponse' } }
    /**
     * Find zero or one MockResponse that matches the filter.
     * @param {MockResponseFindUniqueArgs} args - Arguments to find a MockResponse
     * @example
     * // Get one MockResponse
     * const mockResponse = await prisma.mockResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockResponseFindUniqueArgs>(args: SelectSubset<T, MockResponseFindUniqueArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MockResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MockResponseFindUniqueOrThrowArgs} args - Arguments to find a MockResponse
     * @example
     * // Get one MockResponse
     * const mockResponse = await prisma.mockResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, MockResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MockResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseFindFirstArgs} args - Arguments to find a MockResponse
     * @example
     * // Get one MockResponse
     * const mockResponse = await prisma.mockResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockResponseFindFirstArgs>(args?: SelectSubset<T, MockResponseFindFirstArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MockResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseFindFirstOrThrowArgs} args - Arguments to find a MockResponse
     * @example
     * // Get one MockResponse
     * const mockResponse = await prisma.mockResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, MockResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MockResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockResponses
     * const mockResponses = await prisma.mockResponse.findMany()
     * 
     * // Get first 10 MockResponses
     * const mockResponses = await prisma.mockResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockResponseWithIdOnly = await prisma.mockResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockResponseFindManyArgs>(args?: SelectSubset<T, MockResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MockResponse.
     * @param {MockResponseCreateArgs} args - Arguments to create a MockResponse.
     * @example
     * // Create one MockResponse
     * const MockResponse = await prisma.mockResponse.create({
     *   data: {
     *     // ... data to create a MockResponse
     *   }
     * })
     * 
     */
    create<T extends MockResponseCreateArgs>(args: SelectSubset<T, MockResponseCreateArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MockResponses.
     * @param {MockResponseCreateManyArgs} args - Arguments to create many MockResponses.
     * @example
     * // Create many MockResponses
     * const mockResponse = await prisma.mockResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockResponseCreateManyArgs>(args?: SelectSubset<T, MockResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockResponses and returns the data saved in the database.
     * @param {MockResponseCreateManyAndReturnArgs} args - Arguments to create many MockResponses.
     * @example
     * // Create many MockResponses
     * const mockResponse = await prisma.mockResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockResponses and only return the `id`
     * const mockResponseWithIdOnly = await prisma.mockResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, MockResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MockResponse.
     * @param {MockResponseDeleteArgs} args - Arguments to delete one MockResponse.
     * @example
     * // Delete one MockResponse
     * const MockResponse = await prisma.mockResponse.delete({
     *   where: {
     *     // ... filter to delete one MockResponse
     *   }
     * })
     * 
     */
    delete<T extends MockResponseDeleteArgs>(args: SelectSubset<T, MockResponseDeleteArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MockResponse.
     * @param {MockResponseUpdateArgs} args - Arguments to update one MockResponse.
     * @example
     * // Update one MockResponse
     * const mockResponse = await prisma.mockResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockResponseUpdateArgs>(args: SelectSubset<T, MockResponseUpdateArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MockResponses.
     * @param {MockResponseDeleteManyArgs} args - Arguments to filter MockResponses to delete.
     * @example
     * // Delete a few MockResponses
     * const { count } = await prisma.mockResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockResponseDeleteManyArgs>(args?: SelectSubset<T, MockResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockResponses
     * const mockResponse = await prisma.mockResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockResponseUpdateManyArgs>(args: SelectSubset<T, MockResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MockResponse.
     * @param {MockResponseUpsertArgs} args - Arguments to update or create a MockResponse.
     * @example
     * // Update or create a MockResponse
     * const mockResponse = await prisma.mockResponse.upsert({
     *   create: {
     *     // ... data to create a MockResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockResponse we want to update
     *   }
     * })
     */
    upsert<T extends MockResponseUpsertArgs>(args: SelectSubset<T, MockResponseUpsertArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MockResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseCountArgs} args - Arguments to filter MockResponses to count.
     * @example
     * // Count the number of MockResponses
     * const count = await prisma.mockResponse.count({
     *   where: {
     *     // ... the filter for the MockResponses we want to count
     *   }
     * })
    **/
    count<T extends MockResponseCountArgs>(
      args?: Subset<T, MockResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockResponseAggregateArgs>(args: Subset<T, MockResponseAggregateArgs>): Prisma.PrismaPromise<GetMockResponseAggregateType<T>>

    /**
     * Group by MockResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockResponseGroupByArgs['orderBy'] }
        : { orderBy?: MockResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockResponse model
   */
  readonly fields: MockResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endpoint<T extends MockEndpointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MockEndpointDefaultArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conditions<T extends MockResponse$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, MockResponse$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockResponse model
   */ 
  interface MockResponseFieldRefs {
    readonly id: FieldRef<"MockResponse", 'String'>
    readonly endpointId: FieldRef<"MockResponse", 'String'>
    readonly statusCode: FieldRef<"MockResponse", 'Int'>
    readonly name: FieldRef<"MockResponse", 'String'>
    readonly description: FieldRef<"MockResponse", 'String'>
    readonly responseBody: FieldRef<"MockResponse", 'Json'>
    readonly responseHeaders: FieldRef<"MockResponse", 'Json'>
    readonly delay: FieldRef<"MockResponse", 'Int'>
    readonly isDefault: FieldRef<"MockResponse", 'Boolean'>
    readonly isEnabled: FieldRef<"MockResponse", 'Boolean'>
    readonly order: FieldRef<"MockResponse", 'Int'>
    readonly createdAt: FieldRef<"MockResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"MockResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockResponse findUnique
   */
  export type MockResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter, which MockResponse to fetch.
     */
    where: MockResponseWhereUniqueInput
  }

  /**
   * MockResponse findUniqueOrThrow
   */
  export type MockResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter, which MockResponse to fetch.
     */
    where: MockResponseWhereUniqueInput
  }

  /**
   * MockResponse findFirst
   */
  export type MockResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter, which MockResponse to fetch.
     */
    where?: MockResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockResponses to fetch.
     */
    orderBy?: MockResponseOrderByWithRelationInput | MockResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockResponses.
     */
    cursor?: MockResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockResponses.
     */
    distinct?: MockResponseScalarFieldEnum | MockResponseScalarFieldEnum[]
  }

  /**
   * MockResponse findFirstOrThrow
   */
  export type MockResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter, which MockResponse to fetch.
     */
    where?: MockResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockResponses to fetch.
     */
    orderBy?: MockResponseOrderByWithRelationInput | MockResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockResponses.
     */
    cursor?: MockResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockResponses.
     */
    distinct?: MockResponseScalarFieldEnum | MockResponseScalarFieldEnum[]
  }

  /**
   * MockResponse findMany
   */
  export type MockResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter, which MockResponses to fetch.
     */
    where?: MockResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockResponses to fetch.
     */
    orderBy?: MockResponseOrderByWithRelationInput | MockResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockResponses.
     */
    cursor?: MockResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockResponses.
     */
    skip?: number
    distinct?: MockResponseScalarFieldEnum | MockResponseScalarFieldEnum[]
  }

  /**
   * MockResponse create
   */
  export type MockResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a MockResponse.
     */
    data: XOR<MockResponseCreateInput, MockResponseUncheckedCreateInput>
  }

  /**
   * MockResponse createMany
   */
  export type MockResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockResponses.
     */
    data: MockResponseCreateManyInput | MockResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockResponse createManyAndReturn
   */
  export type MockResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MockResponses.
     */
    data: MockResponseCreateManyInput | MockResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockResponse update
   */
  export type MockResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a MockResponse.
     */
    data: XOR<MockResponseUpdateInput, MockResponseUncheckedUpdateInput>
    /**
     * Choose, which MockResponse to update.
     */
    where: MockResponseWhereUniqueInput
  }

  /**
   * MockResponse updateMany
   */
  export type MockResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockResponses.
     */
    data: XOR<MockResponseUpdateManyMutationInput, MockResponseUncheckedUpdateManyInput>
    /**
     * Filter which MockResponses to update
     */
    where?: MockResponseWhereInput
  }

  /**
   * MockResponse upsert
   */
  export type MockResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the MockResponse to update in case it exists.
     */
    where: MockResponseWhereUniqueInput
    /**
     * In case the MockResponse found by the `where` argument doesn't exist, create a new MockResponse with this data.
     */
    create: XOR<MockResponseCreateInput, MockResponseUncheckedCreateInput>
    /**
     * In case the MockResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockResponseUpdateInput, MockResponseUncheckedUpdateInput>
  }

  /**
   * MockResponse delete
   */
  export type MockResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    /**
     * Filter which MockResponse to delete.
     */
    where: MockResponseWhereUniqueInput
  }

  /**
   * MockResponse deleteMany
   */
  export type MockResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockResponses to delete
     */
    where?: MockResponseWhereInput
  }

  /**
   * MockResponse.conditions
   */
  export type MockResponse$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    where?: MockConditionWhereInput
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    cursor?: MockConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockConditionScalarFieldEnum | MockConditionScalarFieldEnum[]
  }

  /**
   * MockResponse without action
   */
  export type MockResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
  }


  /**
   * Model MockCondition
   */

  export type AggregateMockCondition = {
    _count: MockConditionCountAggregateOutputType | null
    _avg: MockConditionAvgAggregateOutputType | null
    _sum: MockConditionSumAggregateOutputType | null
    _min: MockConditionMinAggregateOutputType | null
    _max: MockConditionMaxAggregateOutputType | null
  }

  export type MockConditionAvgAggregateOutputType = {
    order: number | null
  }

  export type MockConditionSumAggregateOutputType = {
    order: number | null
  }

  export type MockConditionMinAggregateOutputType = {
    id: string | null
    responseId: string | null
    endpointId: string | null
    type: string | null
    key: string | null
    operator: string | null
    value: string | null
    isCaseSensitive: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type MockConditionMaxAggregateOutputType = {
    id: string | null
    responseId: string | null
    endpointId: string | null
    type: string | null
    key: string | null
    operator: string | null
    value: string | null
    isCaseSensitive: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type MockConditionCountAggregateOutputType = {
    id: number
    responseId: number
    endpointId: number
    type: number
    key: number
    operator: number
    value: number
    isCaseSensitive: number
    order: number
    createdAt: number
    _all: number
  }


  export type MockConditionAvgAggregateInputType = {
    order?: true
  }

  export type MockConditionSumAggregateInputType = {
    order?: true
  }

  export type MockConditionMinAggregateInputType = {
    id?: true
    responseId?: true
    endpointId?: true
    type?: true
    key?: true
    operator?: true
    value?: true
    isCaseSensitive?: true
    order?: true
    createdAt?: true
  }

  export type MockConditionMaxAggregateInputType = {
    id?: true
    responseId?: true
    endpointId?: true
    type?: true
    key?: true
    operator?: true
    value?: true
    isCaseSensitive?: true
    order?: true
    createdAt?: true
  }

  export type MockConditionCountAggregateInputType = {
    id?: true
    responseId?: true
    endpointId?: true
    type?: true
    key?: true
    operator?: true
    value?: true
    isCaseSensitive?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type MockConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockCondition to aggregate.
     */
    where?: MockConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockConditions to fetch.
     */
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockConditions
    **/
    _count?: true | MockConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MockConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MockConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockConditionMaxAggregateInputType
  }

  export type GetMockConditionAggregateType<T extends MockConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateMockCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockCondition[P]>
      : GetScalarType<T[P], AggregateMockCondition[P]>
  }




  export type MockConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockConditionWhereInput
    orderBy?: MockConditionOrderByWithAggregationInput | MockConditionOrderByWithAggregationInput[]
    by: MockConditionScalarFieldEnum[] | MockConditionScalarFieldEnum
    having?: MockConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockConditionCountAggregateInputType | true
    _avg?: MockConditionAvgAggregateInputType
    _sum?: MockConditionSumAggregateInputType
    _min?: MockConditionMinAggregateInputType
    _max?: MockConditionMaxAggregateInputType
  }

  export type MockConditionGroupByOutputType = {
    id: string
    responseId: string | null
    endpointId: string | null
    type: string
    key: string
    operator: string
    value: string | null
    isCaseSensitive: boolean
    order: number
    createdAt: Date
    _count: MockConditionCountAggregateOutputType | null
    _avg: MockConditionAvgAggregateOutputType | null
    _sum: MockConditionSumAggregateOutputType | null
    _min: MockConditionMinAggregateOutputType | null
    _max: MockConditionMaxAggregateOutputType | null
  }

  type GetMockConditionGroupByPayload<T extends MockConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockConditionGroupByOutputType[P]>
            : GetScalarType<T[P], MockConditionGroupByOutputType[P]>
        }
      >
    >


  export type MockConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    endpointId?: boolean
    type?: boolean
    key?: boolean
    operator?: boolean
    value?: boolean
    isCaseSensitive?: boolean
    order?: boolean
    createdAt?: boolean
    response?: boolean | MockCondition$responseArgs<ExtArgs>
    endpoint?: boolean | MockCondition$endpointArgs<ExtArgs>
  }, ExtArgs["result"]["mockCondition"]>

  export type MockConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    endpointId?: boolean
    type?: boolean
    key?: boolean
    operator?: boolean
    value?: boolean
    isCaseSensitive?: boolean
    order?: boolean
    createdAt?: boolean
    response?: boolean | MockCondition$responseArgs<ExtArgs>
    endpoint?: boolean | MockCondition$endpointArgs<ExtArgs>
  }, ExtArgs["result"]["mockCondition"]>

  export type MockConditionSelectScalar = {
    id?: boolean
    responseId?: boolean
    endpointId?: boolean
    type?: boolean
    key?: boolean
    operator?: boolean
    value?: boolean
    isCaseSensitive?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type MockConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | MockCondition$responseArgs<ExtArgs>
    endpoint?: boolean | MockCondition$endpointArgs<ExtArgs>
  }
  export type MockConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | MockCondition$responseArgs<ExtArgs>
    endpoint?: boolean | MockCondition$endpointArgs<ExtArgs>
  }

  export type $MockConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockCondition"
    objects: {
      response: Prisma.$MockResponsePayload<ExtArgs> | null
      endpoint: Prisma.$MockEndpointPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responseId: string | null
      endpointId: string | null
      type: string
      key: string
      operator: string
      value: string | null
      isCaseSensitive: boolean
      order: number
      createdAt: Date
    }, ExtArgs["result"]["mockCondition"]>
    composites: {}
  }

  type MockConditionGetPayload<S extends boolean | null | undefined | MockConditionDefaultArgs> = $Result.GetResult<Prisma.$MockConditionPayload, S>

  type MockConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MockConditionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MockConditionCountAggregateInputType | true
    }

  export interface MockConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockCondition'], meta: { name: 'MockCondition' } }
    /**
     * Find zero or one MockCondition that matches the filter.
     * @param {MockConditionFindUniqueArgs} args - Arguments to find a MockCondition
     * @example
     * // Get one MockCondition
     * const mockCondition = await prisma.mockCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockConditionFindUniqueArgs>(args: SelectSubset<T, MockConditionFindUniqueArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MockCondition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MockConditionFindUniqueOrThrowArgs} args - Arguments to find a MockCondition
     * @example
     * // Get one MockCondition
     * const mockCondition = await prisma.mockCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, MockConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MockCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionFindFirstArgs} args - Arguments to find a MockCondition
     * @example
     * // Get one MockCondition
     * const mockCondition = await prisma.mockCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockConditionFindFirstArgs>(args?: SelectSubset<T, MockConditionFindFirstArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MockCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionFindFirstOrThrowArgs} args - Arguments to find a MockCondition
     * @example
     * // Get one MockCondition
     * const mockCondition = await prisma.mockCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, MockConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MockConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockConditions
     * const mockConditions = await prisma.mockCondition.findMany()
     * 
     * // Get first 10 MockConditions
     * const mockConditions = await prisma.mockCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockConditionWithIdOnly = await prisma.mockCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockConditionFindManyArgs>(args?: SelectSubset<T, MockConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MockCondition.
     * @param {MockConditionCreateArgs} args - Arguments to create a MockCondition.
     * @example
     * // Create one MockCondition
     * const MockCondition = await prisma.mockCondition.create({
     *   data: {
     *     // ... data to create a MockCondition
     *   }
     * })
     * 
     */
    create<T extends MockConditionCreateArgs>(args: SelectSubset<T, MockConditionCreateArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MockConditions.
     * @param {MockConditionCreateManyArgs} args - Arguments to create many MockConditions.
     * @example
     * // Create many MockConditions
     * const mockCondition = await prisma.mockCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockConditionCreateManyArgs>(args?: SelectSubset<T, MockConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockConditions and returns the data saved in the database.
     * @param {MockConditionCreateManyAndReturnArgs} args - Arguments to create many MockConditions.
     * @example
     * // Create many MockConditions
     * const mockCondition = await prisma.mockCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockConditions and only return the `id`
     * const mockConditionWithIdOnly = await prisma.mockCondition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, MockConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MockCondition.
     * @param {MockConditionDeleteArgs} args - Arguments to delete one MockCondition.
     * @example
     * // Delete one MockCondition
     * const MockCondition = await prisma.mockCondition.delete({
     *   where: {
     *     // ... filter to delete one MockCondition
     *   }
     * })
     * 
     */
    delete<T extends MockConditionDeleteArgs>(args: SelectSubset<T, MockConditionDeleteArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MockCondition.
     * @param {MockConditionUpdateArgs} args - Arguments to update one MockCondition.
     * @example
     * // Update one MockCondition
     * const mockCondition = await prisma.mockCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockConditionUpdateArgs>(args: SelectSubset<T, MockConditionUpdateArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MockConditions.
     * @param {MockConditionDeleteManyArgs} args - Arguments to filter MockConditions to delete.
     * @example
     * // Delete a few MockConditions
     * const { count } = await prisma.mockCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockConditionDeleteManyArgs>(args?: SelectSubset<T, MockConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockConditions
     * const mockCondition = await prisma.mockCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockConditionUpdateManyArgs>(args: SelectSubset<T, MockConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MockCondition.
     * @param {MockConditionUpsertArgs} args - Arguments to update or create a MockCondition.
     * @example
     * // Update or create a MockCondition
     * const mockCondition = await prisma.mockCondition.upsert({
     *   create: {
     *     // ... data to create a MockCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockCondition we want to update
     *   }
     * })
     */
    upsert<T extends MockConditionUpsertArgs>(args: SelectSubset<T, MockConditionUpsertArgs<ExtArgs>>): Prisma__MockConditionClient<$Result.GetResult<Prisma.$MockConditionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MockConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionCountArgs} args - Arguments to filter MockConditions to count.
     * @example
     * // Count the number of MockConditions
     * const count = await prisma.mockCondition.count({
     *   where: {
     *     // ... the filter for the MockConditions we want to count
     *   }
     * })
    **/
    count<T extends MockConditionCountArgs>(
      args?: Subset<T, MockConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockConditionAggregateArgs>(args: Subset<T, MockConditionAggregateArgs>): Prisma.PrismaPromise<GetMockConditionAggregateType<T>>

    /**
     * Group by MockCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockConditionGroupByArgs['orderBy'] }
        : { orderBy?: MockConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockCondition model
   */
  readonly fields: MockConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response<T extends MockCondition$responseArgs<ExtArgs> = {}>(args?: Subset<T, MockCondition$responseArgs<ExtArgs>>): Prisma__MockResponseClient<$Result.GetResult<Prisma.$MockResponsePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    endpoint<T extends MockCondition$endpointArgs<ExtArgs> = {}>(args?: Subset<T, MockCondition$endpointArgs<ExtArgs>>): Prisma__MockEndpointClient<$Result.GetResult<Prisma.$MockEndpointPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockCondition model
   */ 
  interface MockConditionFieldRefs {
    readonly id: FieldRef<"MockCondition", 'String'>
    readonly responseId: FieldRef<"MockCondition", 'String'>
    readonly endpointId: FieldRef<"MockCondition", 'String'>
    readonly type: FieldRef<"MockCondition", 'String'>
    readonly key: FieldRef<"MockCondition", 'String'>
    readonly operator: FieldRef<"MockCondition", 'String'>
    readonly value: FieldRef<"MockCondition", 'String'>
    readonly isCaseSensitive: FieldRef<"MockCondition", 'Boolean'>
    readonly order: FieldRef<"MockCondition", 'Int'>
    readonly createdAt: FieldRef<"MockCondition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockCondition findUnique
   */
  export type MockConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter, which MockCondition to fetch.
     */
    where: MockConditionWhereUniqueInput
  }

  /**
   * MockCondition findUniqueOrThrow
   */
  export type MockConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter, which MockCondition to fetch.
     */
    where: MockConditionWhereUniqueInput
  }

  /**
   * MockCondition findFirst
   */
  export type MockConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter, which MockCondition to fetch.
     */
    where?: MockConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockConditions to fetch.
     */
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockConditions.
     */
    cursor?: MockConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockConditions.
     */
    distinct?: MockConditionScalarFieldEnum | MockConditionScalarFieldEnum[]
  }

  /**
   * MockCondition findFirstOrThrow
   */
  export type MockConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter, which MockCondition to fetch.
     */
    where?: MockConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockConditions to fetch.
     */
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockConditions.
     */
    cursor?: MockConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockConditions.
     */
    distinct?: MockConditionScalarFieldEnum | MockConditionScalarFieldEnum[]
  }

  /**
   * MockCondition findMany
   */
  export type MockConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter, which MockConditions to fetch.
     */
    where?: MockConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockConditions to fetch.
     */
    orderBy?: MockConditionOrderByWithRelationInput | MockConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockConditions.
     */
    cursor?: MockConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockConditions.
     */
    skip?: number
    distinct?: MockConditionScalarFieldEnum | MockConditionScalarFieldEnum[]
  }

  /**
   * MockCondition create
   */
  export type MockConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a MockCondition.
     */
    data: XOR<MockConditionCreateInput, MockConditionUncheckedCreateInput>
  }

  /**
   * MockCondition createMany
   */
  export type MockConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockConditions.
     */
    data: MockConditionCreateManyInput | MockConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockCondition createManyAndReturn
   */
  export type MockConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MockConditions.
     */
    data: MockConditionCreateManyInput | MockConditionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockCondition update
   */
  export type MockConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a MockCondition.
     */
    data: XOR<MockConditionUpdateInput, MockConditionUncheckedUpdateInput>
    /**
     * Choose, which MockCondition to update.
     */
    where: MockConditionWhereUniqueInput
  }

  /**
   * MockCondition updateMany
   */
  export type MockConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockConditions.
     */
    data: XOR<MockConditionUpdateManyMutationInput, MockConditionUncheckedUpdateManyInput>
    /**
     * Filter which MockConditions to update
     */
    where?: MockConditionWhereInput
  }

  /**
   * MockCondition upsert
   */
  export type MockConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the MockCondition to update in case it exists.
     */
    where: MockConditionWhereUniqueInput
    /**
     * In case the MockCondition found by the `where` argument doesn't exist, create a new MockCondition with this data.
     */
    create: XOR<MockConditionCreateInput, MockConditionUncheckedCreateInput>
    /**
     * In case the MockCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockConditionUpdateInput, MockConditionUncheckedUpdateInput>
  }

  /**
   * MockCondition delete
   */
  export type MockConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
    /**
     * Filter which MockCondition to delete.
     */
    where: MockConditionWhereUniqueInput
  }

  /**
   * MockCondition deleteMany
   */
  export type MockConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockConditions to delete
     */
    where?: MockConditionWhereInput
  }

  /**
   * MockCondition.response
   */
  export type MockCondition$responseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockResponse
     */
    select?: MockResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockResponseInclude<ExtArgs> | null
    where?: MockResponseWhereInput
  }

  /**
   * MockCondition.endpoint
   */
  export type MockCondition$endpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockEndpoint
     */
    select?: MockEndpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockEndpointInclude<ExtArgs> | null
    where?: MockEndpointWhereInput
  }

  /**
   * MockCondition without action
   */
  export type MockConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockCondition
     */
    select?: MockConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockConditionInclude<ExtArgs> | null
  }


  /**
   * Model ConfigAlert
   */

  export type AggregateConfigAlert = {
    _count: ConfigAlertCountAggregateOutputType | null
    _avg: ConfigAlertAvgAggregateOutputType | null
    _sum: ConfigAlertSumAggregateOutputType | null
    _min: ConfigAlertMinAggregateOutputType | null
    _max: ConfigAlertMaxAggregateOutputType | null
  }

  export type ConfigAlertAvgAggregateOutputType = {
    threshold: number | null
    timeWindow: number | null
    minOccurrences: number | null
    triggerCount: number | null
  }

  export type ConfigAlertSumAggregateOutputType = {
    threshold: number | null
    timeWindow: number | null
    minOccurrences: number | null
    triggerCount: number | null
  }

  export type ConfigAlertMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    configId: string | null
    name: string | null
    description: string | null
    condition: string | null
    threshold: number | null
    operator: string | null
    timeWindow: number | null
    minOccurrences: number | null
    enabled: boolean | null
    webhookUrl: string | null
    lastTriggered: Date | null
    triggerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigAlertMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    configId: string | null
    name: string | null
    description: string | null
    condition: string | null
    threshold: number | null
    operator: string | null
    timeWindow: number | null
    minOccurrences: number | null
    enabled: boolean | null
    webhookUrl: string | null
    lastTriggered: Date | null
    triggerCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigAlertCountAggregateOutputType = {
    id: number
    projectId: number
    configId: number
    name: number
    description: number
    condition: number
    threshold: number
    operator: number
    timeWindow: number
    minOccurrences: number
    enabled: number
    webhookUrl: number
    emailRecipients: number
    lastTriggered: number
    triggerCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigAlertAvgAggregateInputType = {
    threshold?: true
    timeWindow?: true
    minOccurrences?: true
    triggerCount?: true
  }

  export type ConfigAlertSumAggregateInputType = {
    threshold?: true
    timeWindow?: true
    minOccurrences?: true
    triggerCount?: true
  }

  export type ConfigAlertMinAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    name?: true
    description?: true
    condition?: true
    threshold?: true
    operator?: true
    timeWindow?: true
    minOccurrences?: true
    enabled?: true
    webhookUrl?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigAlertMaxAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    name?: true
    description?: true
    condition?: true
    threshold?: true
    operator?: true
    timeWindow?: true
    minOccurrences?: true
    enabled?: true
    webhookUrl?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigAlertCountAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    name?: true
    description?: true
    condition?: true
    threshold?: true
    operator?: true
    timeWindow?: true
    minOccurrences?: true
    enabled?: true
    webhookUrl?: true
    emailRecipients?: true
    lastTriggered?: true
    triggerCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigAlert to aggregate.
     */
    where?: ConfigAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlerts to fetch.
     */
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigAlerts
    **/
    _count?: true | ConfigAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigAlertMaxAggregateInputType
  }

  export type GetConfigAlertAggregateType<T extends ConfigAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigAlert[P]>
      : GetScalarType<T[P], AggregateConfigAlert[P]>
  }




  export type ConfigAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigAlertWhereInput
    orderBy?: ConfigAlertOrderByWithAggregationInput | ConfigAlertOrderByWithAggregationInput[]
    by: ConfigAlertScalarFieldEnum[] | ConfigAlertScalarFieldEnum
    having?: ConfigAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigAlertCountAggregateInputType | true
    _avg?: ConfigAlertAvgAggregateInputType
    _sum?: ConfigAlertSumAggregateInputType
    _min?: ConfigAlertMinAggregateInputType
    _max?: ConfigAlertMaxAggregateInputType
  }

  export type ConfigAlertGroupByOutputType = {
    id: string
    projectId: string
    configId: string | null
    name: string
    description: string | null
    condition: string
    threshold: number
    operator: string
    timeWindow: number
    minOccurrences: number
    enabled: boolean
    webhookUrl: string | null
    emailRecipients: JsonValue | null
    lastTriggered: Date | null
    triggerCount: number
    createdAt: Date
    updatedAt: Date
    _count: ConfigAlertCountAggregateOutputType | null
    _avg: ConfigAlertAvgAggregateOutputType | null
    _sum: ConfigAlertSumAggregateOutputType | null
    _min: ConfigAlertMinAggregateOutputType | null
    _max: ConfigAlertMaxAggregateOutputType | null
  }

  type GetConfigAlertGroupByPayload<T extends ConfigAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigAlertGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigAlertGroupByOutputType[P]>
        }
      >
    >


  export type ConfigAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
    threshold?: boolean
    operator?: boolean
    timeWindow?: boolean
    minOccurrences?: boolean
    enabled?: boolean
    webhookUrl?: boolean
    emailRecipients?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | ConfigAlert$configArgs<ExtArgs>
    events?: boolean | ConfigAlert$eventsArgs<ExtArgs>
    _count?: boolean | ConfigAlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configAlert"]>

  export type ConfigAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
    threshold?: boolean
    operator?: boolean
    timeWindow?: boolean
    minOccurrences?: boolean
    enabled?: boolean
    webhookUrl?: boolean
    emailRecipients?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | ConfigAlert$configArgs<ExtArgs>
  }, ExtArgs["result"]["configAlert"]>

  export type ConfigAlertSelectScalar = {
    id?: boolean
    projectId?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
    threshold?: boolean
    operator?: boolean
    timeWindow?: boolean
    minOccurrences?: boolean
    enabled?: boolean
    webhookUrl?: boolean
    emailRecipients?: boolean
    lastTriggered?: boolean
    triggerCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | ConfigAlert$configArgs<ExtArgs>
    events?: boolean | ConfigAlert$eventsArgs<ExtArgs>
    _count?: boolean | ConfigAlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConfigAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | ConfigAlert$configArgs<ExtArgs>
  }

  export type $ConfigAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigAlert"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      config: Prisma.$BusinessConfigPayload<ExtArgs> | null
      events: Prisma.$ConfigAlertEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      configId: string | null
      name: string
      description: string | null
      condition: string
      threshold: number
      operator: string
      timeWindow: number
      minOccurrences: number
      enabled: boolean
      webhookUrl: string | null
      emailRecipients: Prisma.JsonValue | null
      lastTriggered: Date | null
      triggerCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configAlert"]>
    composites: {}
  }

  type ConfigAlertGetPayload<S extends boolean | null | undefined | ConfigAlertDefaultArgs> = $Result.GetResult<Prisma.$ConfigAlertPayload, S>

  type ConfigAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigAlertCountAggregateInputType | true
    }

  export interface ConfigAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigAlert'], meta: { name: 'ConfigAlert' } }
    /**
     * Find zero or one ConfigAlert that matches the filter.
     * @param {ConfigAlertFindUniqueArgs} args - Arguments to find a ConfigAlert
     * @example
     * // Get one ConfigAlert
     * const configAlert = await prisma.configAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigAlertFindUniqueArgs>(args: SelectSubset<T, ConfigAlertFindUniqueArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfigAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigAlertFindUniqueOrThrowArgs} args - Arguments to find a ConfigAlert
     * @example
     * // Get one ConfigAlert
     * const configAlert = await prisma.configAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfigAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertFindFirstArgs} args - Arguments to find a ConfigAlert
     * @example
     * // Get one ConfigAlert
     * const configAlert = await prisma.configAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigAlertFindFirstArgs>(args?: SelectSubset<T, ConfigAlertFindFirstArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfigAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertFindFirstOrThrowArgs} args - Arguments to find a ConfigAlert
     * @example
     * // Get one ConfigAlert
     * const configAlert = await prisma.configAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfigAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigAlerts
     * const configAlerts = await prisma.configAlert.findMany()
     * 
     * // Get first 10 ConfigAlerts
     * const configAlerts = await prisma.configAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configAlertWithIdOnly = await prisma.configAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigAlertFindManyArgs>(args?: SelectSubset<T, ConfigAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfigAlert.
     * @param {ConfigAlertCreateArgs} args - Arguments to create a ConfigAlert.
     * @example
     * // Create one ConfigAlert
     * const ConfigAlert = await prisma.configAlert.create({
     *   data: {
     *     // ... data to create a ConfigAlert
     *   }
     * })
     * 
     */
    create<T extends ConfigAlertCreateArgs>(args: SelectSubset<T, ConfigAlertCreateArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfigAlerts.
     * @param {ConfigAlertCreateManyArgs} args - Arguments to create many ConfigAlerts.
     * @example
     * // Create many ConfigAlerts
     * const configAlert = await prisma.configAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigAlertCreateManyArgs>(args?: SelectSubset<T, ConfigAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigAlerts and returns the data saved in the database.
     * @param {ConfigAlertCreateManyAndReturnArgs} args - Arguments to create many ConfigAlerts.
     * @example
     * // Create many ConfigAlerts
     * const configAlert = await prisma.configAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigAlerts and only return the `id`
     * const configAlertWithIdOnly = await prisma.configAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfigAlert.
     * @param {ConfigAlertDeleteArgs} args - Arguments to delete one ConfigAlert.
     * @example
     * // Delete one ConfigAlert
     * const ConfigAlert = await prisma.configAlert.delete({
     *   where: {
     *     // ... filter to delete one ConfigAlert
     *   }
     * })
     * 
     */
    delete<T extends ConfigAlertDeleteArgs>(args: SelectSubset<T, ConfigAlertDeleteArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfigAlert.
     * @param {ConfigAlertUpdateArgs} args - Arguments to update one ConfigAlert.
     * @example
     * // Update one ConfigAlert
     * const configAlert = await prisma.configAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigAlertUpdateArgs>(args: SelectSubset<T, ConfigAlertUpdateArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfigAlerts.
     * @param {ConfigAlertDeleteManyArgs} args - Arguments to filter ConfigAlerts to delete.
     * @example
     * // Delete a few ConfigAlerts
     * const { count } = await prisma.configAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigAlertDeleteManyArgs>(args?: SelectSubset<T, ConfigAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigAlerts
     * const configAlert = await prisma.configAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigAlertUpdateManyArgs>(args: SelectSubset<T, ConfigAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigAlert.
     * @param {ConfigAlertUpsertArgs} args - Arguments to update or create a ConfigAlert.
     * @example
     * // Update or create a ConfigAlert
     * const configAlert = await prisma.configAlert.upsert({
     *   create: {
     *     // ... data to create a ConfigAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigAlert we want to update
     *   }
     * })
     */
    upsert<T extends ConfigAlertUpsertArgs>(args: SelectSubset<T, ConfigAlertUpsertArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfigAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertCountArgs} args - Arguments to filter ConfigAlerts to count.
     * @example
     * // Count the number of ConfigAlerts
     * const count = await prisma.configAlert.count({
     *   where: {
     *     // ... the filter for the ConfigAlerts we want to count
     *   }
     * })
    **/
    count<T extends ConfigAlertCountArgs>(
      args?: Subset<T, ConfigAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAlertAggregateArgs>(args: Subset<T, ConfigAlertAggregateArgs>): Prisma.PrismaPromise<GetConfigAlertAggregateType<T>>

    /**
     * Group by ConfigAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigAlertGroupByArgs['orderBy'] }
        : { orderBy?: ConfigAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigAlert model
   */
  readonly fields: ConfigAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    config<T extends ConfigAlert$configArgs<ExtArgs> = {}>(args?: Subset<T, ConfigAlert$configArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends ConfigAlert$eventsArgs<ExtArgs> = {}>(args?: Subset<T, ConfigAlert$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigAlert model
   */ 
  interface ConfigAlertFieldRefs {
    readonly id: FieldRef<"ConfigAlert", 'String'>
    readonly projectId: FieldRef<"ConfigAlert", 'String'>
    readonly configId: FieldRef<"ConfigAlert", 'String'>
    readonly name: FieldRef<"ConfigAlert", 'String'>
    readonly description: FieldRef<"ConfigAlert", 'String'>
    readonly condition: FieldRef<"ConfigAlert", 'String'>
    readonly threshold: FieldRef<"ConfigAlert", 'Float'>
    readonly operator: FieldRef<"ConfigAlert", 'String'>
    readonly timeWindow: FieldRef<"ConfigAlert", 'Int'>
    readonly minOccurrences: FieldRef<"ConfigAlert", 'Int'>
    readonly enabled: FieldRef<"ConfigAlert", 'Boolean'>
    readonly webhookUrl: FieldRef<"ConfigAlert", 'String'>
    readonly emailRecipients: FieldRef<"ConfigAlert", 'Json'>
    readonly lastTriggered: FieldRef<"ConfigAlert", 'DateTime'>
    readonly triggerCount: FieldRef<"ConfigAlert", 'Int'>
    readonly createdAt: FieldRef<"ConfigAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfigAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigAlert findUnique
   */
  export type ConfigAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlert to fetch.
     */
    where: ConfigAlertWhereUniqueInput
  }

  /**
   * ConfigAlert findUniqueOrThrow
   */
  export type ConfigAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlert to fetch.
     */
    where: ConfigAlertWhereUniqueInput
  }

  /**
   * ConfigAlert findFirst
   */
  export type ConfigAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlert to fetch.
     */
    where?: ConfigAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlerts to fetch.
     */
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigAlerts.
     */
    cursor?: ConfigAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigAlerts.
     */
    distinct?: ConfigAlertScalarFieldEnum | ConfigAlertScalarFieldEnum[]
  }

  /**
   * ConfigAlert findFirstOrThrow
   */
  export type ConfigAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlert to fetch.
     */
    where?: ConfigAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlerts to fetch.
     */
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigAlerts.
     */
    cursor?: ConfigAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigAlerts.
     */
    distinct?: ConfigAlertScalarFieldEnum | ConfigAlertScalarFieldEnum[]
  }

  /**
   * ConfigAlert findMany
   */
  export type ConfigAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlerts to fetch.
     */
    where?: ConfigAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlerts to fetch.
     */
    orderBy?: ConfigAlertOrderByWithRelationInput | ConfigAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigAlerts.
     */
    cursor?: ConfigAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlerts.
     */
    skip?: number
    distinct?: ConfigAlertScalarFieldEnum | ConfigAlertScalarFieldEnum[]
  }

  /**
   * ConfigAlert create
   */
  export type ConfigAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigAlert.
     */
    data: XOR<ConfigAlertCreateInput, ConfigAlertUncheckedCreateInput>
  }

  /**
   * ConfigAlert createMany
   */
  export type ConfigAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigAlerts.
     */
    data: ConfigAlertCreateManyInput | ConfigAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigAlert createManyAndReturn
   */
  export type ConfigAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfigAlerts.
     */
    data: ConfigAlertCreateManyInput | ConfigAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigAlert update
   */
  export type ConfigAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigAlert.
     */
    data: XOR<ConfigAlertUpdateInput, ConfigAlertUncheckedUpdateInput>
    /**
     * Choose, which ConfigAlert to update.
     */
    where: ConfigAlertWhereUniqueInput
  }

  /**
   * ConfigAlert updateMany
   */
  export type ConfigAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigAlerts.
     */
    data: XOR<ConfigAlertUpdateManyMutationInput, ConfigAlertUncheckedUpdateManyInput>
    /**
     * Filter which ConfigAlerts to update
     */
    where?: ConfigAlertWhereInput
  }

  /**
   * ConfigAlert upsert
   */
  export type ConfigAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigAlert to update in case it exists.
     */
    where: ConfigAlertWhereUniqueInput
    /**
     * In case the ConfigAlert found by the `where` argument doesn't exist, create a new ConfigAlert with this data.
     */
    create: XOR<ConfigAlertCreateInput, ConfigAlertUncheckedCreateInput>
    /**
     * In case the ConfigAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigAlertUpdateInput, ConfigAlertUncheckedUpdateInput>
  }

  /**
   * ConfigAlert delete
   */
  export type ConfigAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
    /**
     * Filter which ConfigAlert to delete.
     */
    where: ConfigAlertWhereUniqueInput
  }

  /**
   * ConfigAlert deleteMany
   */
  export type ConfigAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigAlerts to delete
     */
    where?: ConfigAlertWhereInput
  }

  /**
   * ConfigAlert.config
   */
  export type ConfigAlert$configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessConfig
     */
    select?: BusinessConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessConfigInclude<ExtArgs> | null
    where?: BusinessConfigWhereInput
  }

  /**
   * ConfigAlert.events
   */
  export type ConfigAlert$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    where?: ConfigAlertEventWhereInput
    orderBy?: ConfigAlertEventOrderByWithRelationInput | ConfigAlertEventOrderByWithRelationInput[]
    cursor?: ConfigAlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigAlertEventScalarFieldEnum | ConfigAlertEventScalarFieldEnum[]
  }

  /**
   * ConfigAlert without action
   */
  export type ConfigAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlert
     */
    select?: ConfigAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertInclude<ExtArgs> | null
  }


  /**
   * Model ConfigAlertEvent
   */

  export type AggregateConfigAlertEvent = {
    _count: ConfigAlertEventCountAggregateOutputType | null
    _min: ConfigAlertEventMinAggregateOutputType | null
    _max: ConfigAlertEventMaxAggregateOutputType | null
  }

  export type ConfigAlertEventMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    projectId: string | null
    configId: string | null
    severity: string | null
    message: string | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    createdAt: Date | null
  }

  export type ConfigAlertEventMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    projectId: string | null
    configId: string | null
    severity: string | null
    message: string | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    createdAt: Date | null
  }

  export type ConfigAlertEventCountAggregateOutputType = {
    id: number
    alertId: number
    projectId: number
    configId: number
    severity: number
    message: number
    metadata: number
    acknowledged: number
    acknowledgedBy: number
    acknowledgedAt: number
    createdAt: number
    _all: number
  }


  export type ConfigAlertEventMinAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    configId?: true
    severity?: true
    message?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    createdAt?: true
  }

  export type ConfigAlertEventMaxAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    configId?: true
    severity?: true
    message?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    createdAt?: true
  }

  export type ConfigAlertEventCountAggregateInputType = {
    id?: true
    alertId?: true
    projectId?: true
    configId?: true
    severity?: true
    message?: true
    metadata?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ConfigAlertEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigAlertEvent to aggregate.
     */
    where?: ConfigAlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlertEvents to fetch.
     */
    orderBy?: ConfigAlertEventOrderByWithRelationInput | ConfigAlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigAlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigAlertEvents
    **/
    _count?: true | ConfigAlertEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigAlertEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigAlertEventMaxAggregateInputType
  }

  export type GetConfigAlertEventAggregateType<T extends ConfigAlertEventAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigAlertEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigAlertEvent[P]>
      : GetScalarType<T[P], AggregateConfigAlertEvent[P]>
  }




  export type ConfigAlertEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigAlertEventWhereInput
    orderBy?: ConfigAlertEventOrderByWithAggregationInput | ConfigAlertEventOrderByWithAggregationInput[]
    by: ConfigAlertEventScalarFieldEnum[] | ConfigAlertEventScalarFieldEnum
    having?: ConfigAlertEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigAlertEventCountAggregateInputType | true
    _min?: ConfigAlertEventMinAggregateInputType
    _max?: ConfigAlertEventMaxAggregateInputType
  }

  export type ConfigAlertEventGroupByOutputType = {
    id: string
    alertId: string
    projectId: string
    configId: string | null
    severity: string
    message: string
    metadata: JsonValue | null
    acknowledged: boolean
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    createdAt: Date
    _count: ConfigAlertEventCountAggregateOutputType | null
    _min: ConfigAlertEventMinAggregateOutputType | null
    _max: ConfigAlertEventMaxAggregateOutputType | null
  }

  type GetConfigAlertEventGroupByPayload<T extends ConfigAlertEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigAlertEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigAlertEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigAlertEventGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigAlertEventGroupByOutputType[P]>
        }
      >
    >


  export type ConfigAlertEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    configId?: boolean
    severity?: boolean
    message?: boolean
    metadata?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    alert?: boolean | ConfigAlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configAlertEvent"]>

  export type ConfigAlertEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    configId?: boolean
    severity?: boolean
    message?: boolean
    metadata?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    alert?: boolean | ConfigAlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configAlertEvent"]>

  export type ConfigAlertEventSelectScalar = {
    id?: boolean
    alertId?: boolean
    projectId?: boolean
    configId?: boolean
    severity?: boolean
    message?: boolean
    metadata?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
  }

  export type ConfigAlertEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | ConfigAlertDefaultArgs<ExtArgs>
  }
  export type ConfigAlertEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | ConfigAlertDefaultArgs<ExtArgs>
  }

  export type $ConfigAlertEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigAlertEvent"
    objects: {
      alert: Prisma.$ConfigAlertPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string
      projectId: string
      configId: string | null
      severity: string
      message: string
      metadata: Prisma.JsonValue | null
      acknowledged: boolean
      acknowledgedBy: string | null
      acknowledgedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["configAlertEvent"]>
    composites: {}
  }

  type ConfigAlertEventGetPayload<S extends boolean | null | undefined | ConfigAlertEventDefaultArgs> = $Result.GetResult<Prisma.$ConfigAlertEventPayload, S>

  type ConfigAlertEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigAlertEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigAlertEventCountAggregateInputType | true
    }

  export interface ConfigAlertEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigAlertEvent'], meta: { name: 'ConfigAlertEvent' } }
    /**
     * Find zero or one ConfigAlertEvent that matches the filter.
     * @param {ConfigAlertEventFindUniqueArgs} args - Arguments to find a ConfigAlertEvent
     * @example
     * // Get one ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigAlertEventFindUniqueArgs>(args: SelectSubset<T, ConfigAlertEventFindUniqueArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfigAlertEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigAlertEventFindUniqueOrThrowArgs} args - Arguments to find a ConfigAlertEvent
     * @example
     * // Get one ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigAlertEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigAlertEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfigAlertEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventFindFirstArgs} args - Arguments to find a ConfigAlertEvent
     * @example
     * // Get one ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigAlertEventFindFirstArgs>(args?: SelectSubset<T, ConfigAlertEventFindFirstArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfigAlertEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventFindFirstOrThrowArgs} args - Arguments to find a ConfigAlertEvent
     * @example
     * // Get one ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigAlertEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigAlertEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfigAlertEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigAlertEvents
     * const configAlertEvents = await prisma.configAlertEvent.findMany()
     * 
     * // Get first 10 ConfigAlertEvents
     * const configAlertEvents = await prisma.configAlertEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configAlertEventWithIdOnly = await prisma.configAlertEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigAlertEventFindManyArgs>(args?: SelectSubset<T, ConfigAlertEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfigAlertEvent.
     * @param {ConfigAlertEventCreateArgs} args - Arguments to create a ConfigAlertEvent.
     * @example
     * // Create one ConfigAlertEvent
     * const ConfigAlertEvent = await prisma.configAlertEvent.create({
     *   data: {
     *     // ... data to create a ConfigAlertEvent
     *   }
     * })
     * 
     */
    create<T extends ConfigAlertEventCreateArgs>(args: SelectSubset<T, ConfigAlertEventCreateArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfigAlertEvents.
     * @param {ConfigAlertEventCreateManyArgs} args - Arguments to create many ConfigAlertEvents.
     * @example
     * // Create many ConfigAlertEvents
     * const configAlertEvent = await prisma.configAlertEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigAlertEventCreateManyArgs>(args?: SelectSubset<T, ConfigAlertEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigAlertEvents and returns the data saved in the database.
     * @param {ConfigAlertEventCreateManyAndReturnArgs} args - Arguments to create many ConfigAlertEvents.
     * @example
     * // Create many ConfigAlertEvents
     * const configAlertEvent = await prisma.configAlertEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigAlertEvents and only return the `id`
     * const configAlertEventWithIdOnly = await prisma.configAlertEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigAlertEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigAlertEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfigAlertEvent.
     * @param {ConfigAlertEventDeleteArgs} args - Arguments to delete one ConfigAlertEvent.
     * @example
     * // Delete one ConfigAlertEvent
     * const ConfigAlertEvent = await prisma.configAlertEvent.delete({
     *   where: {
     *     // ... filter to delete one ConfigAlertEvent
     *   }
     * })
     * 
     */
    delete<T extends ConfigAlertEventDeleteArgs>(args: SelectSubset<T, ConfigAlertEventDeleteArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfigAlertEvent.
     * @param {ConfigAlertEventUpdateArgs} args - Arguments to update one ConfigAlertEvent.
     * @example
     * // Update one ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigAlertEventUpdateArgs>(args: SelectSubset<T, ConfigAlertEventUpdateArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfigAlertEvents.
     * @param {ConfigAlertEventDeleteManyArgs} args - Arguments to filter ConfigAlertEvents to delete.
     * @example
     * // Delete a few ConfigAlertEvents
     * const { count } = await prisma.configAlertEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigAlertEventDeleteManyArgs>(args?: SelectSubset<T, ConfigAlertEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigAlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigAlertEvents
     * const configAlertEvent = await prisma.configAlertEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigAlertEventUpdateManyArgs>(args: SelectSubset<T, ConfigAlertEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigAlertEvent.
     * @param {ConfigAlertEventUpsertArgs} args - Arguments to update or create a ConfigAlertEvent.
     * @example
     * // Update or create a ConfigAlertEvent
     * const configAlertEvent = await prisma.configAlertEvent.upsert({
     *   create: {
     *     // ... data to create a ConfigAlertEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigAlertEvent we want to update
     *   }
     * })
     */
    upsert<T extends ConfigAlertEventUpsertArgs>(args: SelectSubset<T, ConfigAlertEventUpsertArgs<ExtArgs>>): Prisma__ConfigAlertEventClient<$Result.GetResult<Prisma.$ConfigAlertEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfigAlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventCountArgs} args - Arguments to filter ConfigAlertEvents to count.
     * @example
     * // Count the number of ConfigAlertEvents
     * const count = await prisma.configAlertEvent.count({
     *   where: {
     *     // ... the filter for the ConfigAlertEvents we want to count
     *   }
     * })
    **/
    count<T extends ConfigAlertEventCountArgs>(
      args?: Subset<T, ConfigAlertEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigAlertEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigAlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAlertEventAggregateArgs>(args: Subset<T, ConfigAlertEventAggregateArgs>): Prisma.PrismaPromise<GetConfigAlertEventAggregateType<T>>

    /**
     * Group by ConfigAlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAlertEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigAlertEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigAlertEventGroupByArgs['orderBy'] }
        : { orderBy?: ConfigAlertEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigAlertEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigAlertEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigAlertEvent model
   */
  readonly fields: ConfigAlertEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigAlertEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigAlertEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends ConfigAlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConfigAlertDefaultArgs<ExtArgs>>): Prisma__ConfigAlertClient<$Result.GetResult<Prisma.$ConfigAlertPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigAlertEvent model
   */ 
  interface ConfigAlertEventFieldRefs {
    readonly id: FieldRef<"ConfigAlertEvent", 'String'>
    readonly alertId: FieldRef<"ConfigAlertEvent", 'String'>
    readonly projectId: FieldRef<"ConfigAlertEvent", 'String'>
    readonly configId: FieldRef<"ConfigAlertEvent", 'String'>
    readonly severity: FieldRef<"ConfigAlertEvent", 'String'>
    readonly message: FieldRef<"ConfigAlertEvent", 'String'>
    readonly metadata: FieldRef<"ConfigAlertEvent", 'Json'>
    readonly acknowledged: FieldRef<"ConfigAlertEvent", 'Boolean'>
    readonly acknowledgedBy: FieldRef<"ConfigAlertEvent", 'String'>
    readonly acknowledgedAt: FieldRef<"ConfigAlertEvent", 'DateTime'>
    readonly createdAt: FieldRef<"ConfigAlertEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigAlertEvent findUnique
   */
  export type ConfigAlertEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlertEvent to fetch.
     */
    where: ConfigAlertEventWhereUniqueInput
  }

  /**
   * ConfigAlertEvent findUniqueOrThrow
   */
  export type ConfigAlertEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlertEvent to fetch.
     */
    where: ConfigAlertEventWhereUniqueInput
  }

  /**
   * ConfigAlertEvent findFirst
   */
  export type ConfigAlertEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlertEvent to fetch.
     */
    where?: ConfigAlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlertEvents to fetch.
     */
    orderBy?: ConfigAlertEventOrderByWithRelationInput | ConfigAlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigAlertEvents.
     */
    cursor?: ConfigAlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigAlertEvents.
     */
    distinct?: ConfigAlertEventScalarFieldEnum | ConfigAlertEventScalarFieldEnum[]
  }

  /**
   * ConfigAlertEvent findFirstOrThrow
   */
  export type ConfigAlertEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlertEvent to fetch.
     */
    where?: ConfigAlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlertEvents to fetch.
     */
    orderBy?: ConfigAlertEventOrderByWithRelationInput | ConfigAlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigAlertEvents.
     */
    cursor?: ConfigAlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigAlertEvents.
     */
    distinct?: ConfigAlertEventScalarFieldEnum | ConfigAlertEventScalarFieldEnum[]
  }

  /**
   * ConfigAlertEvent findMany
   */
  export type ConfigAlertEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter, which ConfigAlertEvents to fetch.
     */
    where?: ConfigAlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigAlertEvents to fetch.
     */
    orderBy?: ConfigAlertEventOrderByWithRelationInput | ConfigAlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigAlertEvents.
     */
    cursor?: ConfigAlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigAlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigAlertEvents.
     */
    skip?: number
    distinct?: ConfigAlertEventScalarFieldEnum | ConfigAlertEventScalarFieldEnum[]
  }

  /**
   * ConfigAlertEvent create
   */
  export type ConfigAlertEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigAlertEvent.
     */
    data: XOR<ConfigAlertEventCreateInput, ConfigAlertEventUncheckedCreateInput>
  }

  /**
   * ConfigAlertEvent createMany
   */
  export type ConfigAlertEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigAlertEvents.
     */
    data: ConfigAlertEventCreateManyInput | ConfigAlertEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigAlertEvent createManyAndReturn
   */
  export type ConfigAlertEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfigAlertEvents.
     */
    data: ConfigAlertEventCreateManyInput | ConfigAlertEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigAlertEvent update
   */
  export type ConfigAlertEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigAlertEvent.
     */
    data: XOR<ConfigAlertEventUpdateInput, ConfigAlertEventUncheckedUpdateInput>
    /**
     * Choose, which ConfigAlertEvent to update.
     */
    where: ConfigAlertEventWhereUniqueInput
  }

  /**
   * ConfigAlertEvent updateMany
   */
  export type ConfigAlertEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigAlertEvents.
     */
    data: XOR<ConfigAlertEventUpdateManyMutationInput, ConfigAlertEventUncheckedUpdateManyInput>
    /**
     * Filter which ConfigAlertEvents to update
     */
    where?: ConfigAlertEventWhereInput
  }

  /**
   * ConfigAlertEvent upsert
   */
  export type ConfigAlertEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigAlertEvent to update in case it exists.
     */
    where: ConfigAlertEventWhereUniqueInput
    /**
     * In case the ConfigAlertEvent found by the `where` argument doesn't exist, create a new ConfigAlertEvent with this data.
     */
    create: XOR<ConfigAlertEventCreateInput, ConfigAlertEventUncheckedCreateInput>
    /**
     * In case the ConfigAlertEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigAlertEventUpdateInput, ConfigAlertEventUncheckedUpdateInput>
  }

  /**
   * ConfigAlertEvent delete
   */
  export type ConfigAlertEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
    /**
     * Filter which ConfigAlertEvent to delete.
     */
    where: ConfigAlertEventWhereUniqueInput
  }

  /**
   * ConfigAlertEvent deleteMany
   */
  export type ConfigAlertEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigAlertEvents to delete
     */
    where?: ConfigAlertEventWhereInput
  }

  /**
   * ConfigAlertEvent without action
   */
  export type ConfigAlertEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigAlertEvent
     */
    select?: ConfigAlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigAlertEventInclude<ExtArgs> | null
  }


  /**
   * Model ConfigApproval
   */

  export type AggregateConfigApproval = {
    _count: ConfigApprovalCountAggregateOutputType | null
    _avg: ConfigApprovalAvgAggregateOutputType | null
    _sum: ConfigApprovalSumAggregateOutputType | null
    _min: ConfigApprovalMinAggregateOutputType | null
    _max: ConfigApprovalMaxAggregateOutputType | null
  }

  export type ConfigApprovalAvgAggregateOutputType = {
    requiredApprovals: number | null
    currentApprovals: number | null
  }

  export type ConfigApprovalSumAggregateOutputType = {
    requiredApprovals: number | null
    currentApprovals: number | null
  }

  export type ConfigApprovalMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    configId: string | null
    changeType: string | null
    status: string | null
    requiredApprovals: number | null
    currentApprovals: number | null
    requestedBy: string | null
    requestedAt: Date | null
    decidedBy: string | null
    decidedAt: Date | null
    decisionComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigApprovalMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    configId: string | null
    changeType: string | null
    status: string | null
    requiredApprovals: number | null
    currentApprovals: number | null
    requestedBy: string | null
    requestedAt: Date | null
    decidedBy: string | null
    decidedAt: Date | null
    decisionComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigApprovalCountAggregateOutputType = {
    id: number
    projectId: number
    configId: number
    changeType: number
    changeData: number
    status: number
    requiredApprovals: number
    currentApprovals: number
    approvers: number
    approvals: number
    requestedBy: number
    requestedAt: number
    decidedBy: number
    decidedAt: number
    decisionComment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigApprovalAvgAggregateInputType = {
    requiredApprovals?: true
    currentApprovals?: true
  }

  export type ConfigApprovalSumAggregateInputType = {
    requiredApprovals?: true
    currentApprovals?: true
  }

  export type ConfigApprovalMinAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    changeType?: true
    status?: true
    requiredApprovals?: true
    currentApprovals?: true
    requestedBy?: true
    requestedAt?: true
    decidedBy?: true
    decidedAt?: true
    decisionComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigApprovalMaxAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    changeType?: true
    status?: true
    requiredApprovals?: true
    currentApprovals?: true
    requestedBy?: true
    requestedAt?: true
    decidedBy?: true
    decidedAt?: true
    decisionComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigApprovalCountAggregateInputType = {
    id?: true
    projectId?: true
    configId?: true
    changeType?: true
    changeData?: true
    status?: true
    requiredApprovals?: true
    currentApprovals?: true
    approvers?: true
    approvals?: true
    requestedBy?: true
    requestedAt?: true
    decidedBy?: true
    decidedAt?: true
    decisionComment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigApproval to aggregate.
     */
    where?: ConfigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigApprovals to fetch.
     */
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigApprovals
    **/
    _count?: true | ConfigApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigApprovalMaxAggregateInputType
  }

  export type GetConfigApprovalAggregateType<T extends ConfigApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigApproval[P]>
      : GetScalarType<T[P], AggregateConfigApproval[P]>
  }




  export type ConfigApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigApprovalWhereInput
    orderBy?: ConfigApprovalOrderByWithAggregationInput | ConfigApprovalOrderByWithAggregationInput[]
    by: ConfigApprovalScalarFieldEnum[] | ConfigApprovalScalarFieldEnum
    having?: ConfigApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigApprovalCountAggregateInputType | true
    _avg?: ConfigApprovalAvgAggregateInputType
    _sum?: ConfigApprovalSumAggregateInputType
    _min?: ConfigApprovalMinAggregateInputType
    _max?: ConfigApprovalMaxAggregateInputType
  }

  export type ConfigApprovalGroupByOutputType = {
    id: string
    projectId: string
    configId: string
    changeType: string
    changeData: JsonValue
    status: string
    requiredApprovals: number
    currentApprovals: number
    approvers: JsonValue
    approvals: JsonValue
    requestedBy: string
    requestedAt: Date
    decidedBy: string | null
    decidedAt: Date | null
    decisionComment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfigApprovalCountAggregateOutputType | null
    _avg: ConfigApprovalAvgAggregateOutputType | null
    _sum: ConfigApprovalSumAggregateOutputType | null
    _min: ConfigApprovalMinAggregateOutputType | null
    _max: ConfigApprovalMaxAggregateOutputType | null
  }

  type GetConfigApprovalGroupByPayload<T extends ConfigApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ConfigApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    configId?: boolean
    changeType?: boolean
    changeData?: boolean
    status?: boolean
    requiredApprovals?: boolean
    currentApprovals?: boolean
    approvers?: boolean
    approvals?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    decidedBy?: boolean
    decidedAt?: boolean
    decisionComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | BusinessConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configApproval"]>

  export type ConfigApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    configId?: boolean
    changeType?: boolean
    changeData?: boolean
    status?: boolean
    requiredApprovals?: boolean
    currentApprovals?: boolean
    approvers?: boolean
    approvals?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    decidedBy?: boolean
    decidedAt?: boolean
    decisionComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | BusinessConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configApproval"]>

  export type ConfigApprovalSelectScalar = {
    id?: boolean
    projectId?: boolean
    configId?: boolean
    changeType?: boolean
    changeData?: boolean
    status?: boolean
    requiredApprovals?: boolean
    currentApprovals?: boolean
    approvers?: boolean
    approvals?: boolean
    requestedBy?: boolean
    requestedAt?: boolean
    decidedBy?: boolean
    decidedAt?: boolean
    decisionComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | BusinessConfigDefaultArgs<ExtArgs>
  }
  export type ConfigApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    config?: boolean | BusinessConfigDefaultArgs<ExtArgs>
  }

  export type $ConfigApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigApproval"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      config: Prisma.$BusinessConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      configId: string
      changeType: string
      changeData: Prisma.JsonValue
      status: string
      requiredApprovals: number
      currentApprovals: number
      approvers: Prisma.JsonValue
      approvals: Prisma.JsonValue
      requestedBy: string
      requestedAt: Date
      decidedBy: string | null
      decidedAt: Date | null
      decisionComment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configApproval"]>
    composites: {}
  }

  type ConfigApprovalGetPayload<S extends boolean | null | undefined | ConfigApprovalDefaultArgs> = $Result.GetResult<Prisma.$ConfigApprovalPayload, S>

  type ConfigApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigApprovalCountAggregateInputType | true
    }

  export interface ConfigApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigApproval'], meta: { name: 'ConfigApproval' } }
    /**
     * Find zero or one ConfigApproval that matches the filter.
     * @param {ConfigApprovalFindUniqueArgs} args - Arguments to find a ConfigApproval
     * @example
     * // Get one ConfigApproval
     * const configApproval = await prisma.configApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigApprovalFindUniqueArgs>(args: SelectSubset<T, ConfigApprovalFindUniqueArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfigApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigApprovalFindUniqueOrThrowArgs} args - Arguments to find a ConfigApproval
     * @example
     * // Get one ConfigApproval
     * const configApproval = await prisma.configApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfigApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalFindFirstArgs} args - Arguments to find a ConfigApproval
     * @example
     * // Get one ConfigApproval
     * const configApproval = await prisma.configApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigApprovalFindFirstArgs>(args?: SelectSubset<T, ConfigApprovalFindFirstArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfigApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalFindFirstOrThrowArgs} args - Arguments to find a ConfigApproval
     * @example
     * // Get one ConfigApproval
     * const configApproval = await prisma.configApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfigApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigApprovals
     * const configApprovals = await prisma.configApproval.findMany()
     * 
     * // Get first 10 ConfigApprovals
     * const configApprovals = await prisma.configApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configApprovalWithIdOnly = await prisma.configApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigApprovalFindManyArgs>(args?: SelectSubset<T, ConfigApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfigApproval.
     * @param {ConfigApprovalCreateArgs} args - Arguments to create a ConfigApproval.
     * @example
     * // Create one ConfigApproval
     * const ConfigApproval = await prisma.configApproval.create({
     *   data: {
     *     // ... data to create a ConfigApproval
     *   }
     * })
     * 
     */
    create<T extends ConfigApprovalCreateArgs>(args: SelectSubset<T, ConfigApprovalCreateArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfigApprovals.
     * @param {ConfigApprovalCreateManyArgs} args - Arguments to create many ConfigApprovals.
     * @example
     * // Create many ConfigApprovals
     * const configApproval = await prisma.configApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigApprovalCreateManyArgs>(args?: SelectSubset<T, ConfigApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigApprovals and returns the data saved in the database.
     * @param {ConfigApprovalCreateManyAndReturnArgs} args - Arguments to create many ConfigApprovals.
     * @example
     * // Create many ConfigApprovals
     * const configApproval = await prisma.configApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigApprovals and only return the `id`
     * const configApprovalWithIdOnly = await prisma.configApproval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfigApproval.
     * @param {ConfigApprovalDeleteArgs} args - Arguments to delete one ConfigApproval.
     * @example
     * // Delete one ConfigApproval
     * const ConfigApproval = await prisma.configApproval.delete({
     *   where: {
     *     // ... filter to delete one ConfigApproval
     *   }
     * })
     * 
     */
    delete<T extends ConfigApprovalDeleteArgs>(args: SelectSubset<T, ConfigApprovalDeleteArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfigApproval.
     * @param {ConfigApprovalUpdateArgs} args - Arguments to update one ConfigApproval.
     * @example
     * // Update one ConfigApproval
     * const configApproval = await prisma.configApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigApprovalUpdateArgs>(args: SelectSubset<T, ConfigApprovalUpdateArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfigApprovals.
     * @param {ConfigApprovalDeleteManyArgs} args - Arguments to filter ConfigApprovals to delete.
     * @example
     * // Delete a few ConfigApprovals
     * const { count } = await prisma.configApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigApprovalDeleteManyArgs>(args?: SelectSubset<T, ConfigApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigApprovals
     * const configApproval = await prisma.configApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigApprovalUpdateManyArgs>(args: SelectSubset<T, ConfigApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfigApproval.
     * @param {ConfigApprovalUpsertArgs} args - Arguments to update or create a ConfigApproval.
     * @example
     * // Update or create a ConfigApproval
     * const configApproval = await prisma.configApproval.upsert({
     *   create: {
     *     // ... data to create a ConfigApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigApproval we want to update
     *   }
     * })
     */
    upsert<T extends ConfigApprovalUpsertArgs>(args: SelectSubset<T, ConfigApprovalUpsertArgs<ExtArgs>>): Prisma__ConfigApprovalClient<$Result.GetResult<Prisma.$ConfigApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfigApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalCountArgs} args - Arguments to filter ConfigApprovals to count.
     * @example
     * // Count the number of ConfigApprovals
     * const count = await prisma.configApproval.count({
     *   where: {
     *     // ... the filter for the ConfigApprovals we want to count
     *   }
     * })
    **/
    count<T extends ConfigApprovalCountArgs>(
      args?: Subset<T, ConfigApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigApprovalAggregateArgs>(args: Subset<T, ConfigApprovalAggregateArgs>): Prisma.PrismaPromise<GetConfigApprovalAggregateType<T>>

    /**
     * Group by ConfigApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ConfigApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigApproval model
   */
  readonly fields: ConfigApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    config<T extends BusinessConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessConfigDefaultArgs<ExtArgs>>): Prisma__BusinessConfigClient<$Result.GetResult<Prisma.$BusinessConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigApproval model
   */ 
  interface ConfigApprovalFieldRefs {
    readonly id: FieldRef<"ConfigApproval", 'String'>
    readonly projectId: FieldRef<"ConfigApproval", 'String'>
    readonly configId: FieldRef<"ConfigApproval", 'String'>
    readonly changeType: FieldRef<"ConfigApproval", 'String'>
    readonly changeData: FieldRef<"ConfigApproval", 'Json'>
    readonly status: FieldRef<"ConfigApproval", 'String'>
    readonly requiredApprovals: FieldRef<"ConfigApproval", 'Int'>
    readonly currentApprovals: FieldRef<"ConfigApproval", 'Int'>
    readonly approvers: FieldRef<"ConfigApproval", 'Json'>
    readonly approvals: FieldRef<"ConfigApproval", 'Json'>
    readonly requestedBy: FieldRef<"ConfigApproval", 'String'>
    readonly requestedAt: FieldRef<"ConfigApproval", 'DateTime'>
    readonly decidedBy: FieldRef<"ConfigApproval", 'String'>
    readonly decidedAt: FieldRef<"ConfigApproval", 'DateTime'>
    readonly decisionComment: FieldRef<"ConfigApproval", 'String'>
    readonly createdAt: FieldRef<"ConfigApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfigApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigApproval findUnique
   */
  export type ConfigApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ConfigApproval to fetch.
     */
    where: ConfigApprovalWhereUniqueInput
  }

  /**
   * ConfigApproval findUniqueOrThrow
   */
  export type ConfigApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ConfigApproval to fetch.
     */
    where: ConfigApprovalWhereUniqueInput
  }

  /**
   * ConfigApproval findFirst
   */
  export type ConfigApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ConfigApproval to fetch.
     */
    where?: ConfigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigApprovals to fetch.
     */
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigApprovals.
     */
    cursor?: ConfigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigApprovals.
     */
    distinct?: ConfigApprovalScalarFieldEnum | ConfigApprovalScalarFieldEnum[]
  }

  /**
   * ConfigApproval findFirstOrThrow
   */
  export type ConfigApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ConfigApproval to fetch.
     */
    where?: ConfigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigApprovals to fetch.
     */
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigApprovals.
     */
    cursor?: ConfigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigApprovals.
     */
    distinct?: ConfigApprovalScalarFieldEnum | ConfigApprovalScalarFieldEnum[]
  }

  /**
   * ConfigApproval findMany
   */
  export type ConfigApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ConfigApprovals to fetch.
     */
    where?: ConfigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigApprovals to fetch.
     */
    orderBy?: ConfigApprovalOrderByWithRelationInput | ConfigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigApprovals.
     */
    cursor?: ConfigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigApprovals.
     */
    skip?: number
    distinct?: ConfigApprovalScalarFieldEnum | ConfigApprovalScalarFieldEnum[]
  }

  /**
   * ConfigApproval create
   */
  export type ConfigApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigApproval.
     */
    data: XOR<ConfigApprovalCreateInput, ConfigApprovalUncheckedCreateInput>
  }

  /**
   * ConfigApproval createMany
   */
  export type ConfigApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigApprovals.
     */
    data: ConfigApprovalCreateManyInput | ConfigApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigApproval createManyAndReturn
   */
  export type ConfigApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfigApprovals.
     */
    data: ConfigApprovalCreateManyInput | ConfigApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigApproval update
   */
  export type ConfigApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigApproval.
     */
    data: XOR<ConfigApprovalUpdateInput, ConfigApprovalUncheckedUpdateInput>
    /**
     * Choose, which ConfigApproval to update.
     */
    where: ConfigApprovalWhereUniqueInput
  }

  /**
   * ConfigApproval updateMany
   */
  export type ConfigApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigApprovals.
     */
    data: XOR<ConfigApprovalUpdateManyMutationInput, ConfigApprovalUncheckedUpdateManyInput>
    /**
     * Filter which ConfigApprovals to update
     */
    where?: ConfigApprovalWhereInput
  }

  /**
   * ConfigApproval upsert
   */
  export type ConfigApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigApproval to update in case it exists.
     */
    where: ConfigApprovalWhereUniqueInput
    /**
     * In case the ConfigApproval found by the `where` argument doesn't exist, create a new ConfigApproval with this data.
     */
    create: XOR<ConfigApprovalCreateInput, ConfigApprovalUncheckedCreateInput>
    /**
     * In case the ConfigApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigApprovalUpdateInput, ConfigApprovalUncheckedUpdateInput>
  }

  /**
   * ConfigApproval delete
   */
  export type ConfigApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
    /**
     * Filter which ConfigApproval to delete.
     */
    where: ConfigApprovalWhereUniqueInput
  }

  /**
   * ConfigApproval deleteMany
   */
  export type ConfigApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigApprovals to delete
     */
    where?: ConfigApprovalWhereInput
  }

  /**
   * ConfigApproval without action
   */
  export type ConfigApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigApproval
     */
    select?: ConfigApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigApprovalInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfiguration
   */

  export type AggregateSystemConfiguration = {
    _count: SystemConfigurationCountAggregateOutputType | null
    _min: SystemConfigurationMinAggregateOutputType | null
    _max: SystemConfigurationMaxAggregateOutputType | null
  }

  export type SystemConfigurationMinAggregateOutputType = {
    id: string | null
    category: string | null
    key: string | null
    value: string | null
    encrypted: boolean | null
    description: string | null
    isActive: boolean | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigurationMaxAggregateOutputType = {
    id: string | null
    category: string | null
    key: string | null
    value: string | null
    encrypted: boolean | null
    description: string | null
    isActive: boolean | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigurationCountAggregateOutputType = {
    id: number
    category: number
    key: number
    value: number
    encrypted: number
    description: number
    isActive: number
    metadata: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigurationMinAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    encrypted?: true
    description?: true
    isActive?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigurationMaxAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    encrypted?: true
    description?: true
    isActive?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigurationCountAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    encrypted?: true
    description?: true
    isActive?: true
    metadata?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfiguration to aggregate.
     */
    where?: SystemConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigurations to fetch.
     */
    orderBy?: SystemConfigurationOrderByWithRelationInput | SystemConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigurations
    **/
    _count?: true | SystemConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigurationMaxAggregateInputType
  }

  export type GetSystemConfigurationAggregateType<T extends SystemConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfiguration[P]>
      : GetScalarType<T[P], AggregateSystemConfiguration[P]>
  }




  export type SystemConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigurationWhereInput
    orderBy?: SystemConfigurationOrderByWithAggregationInput | SystemConfigurationOrderByWithAggregationInput[]
    by: SystemConfigurationScalarFieldEnum[] | SystemConfigurationScalarFieldEnum
    having?: SystemConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigurationCountAggregateInputType | true
    _min?: SystemConfigurationMinAggregateInputType
    _max?: SystemConfigurationMaxAggregateInputType
  }

  export type SystemConfigurationGroupByOutputType = {
    id: string
    category: string
    key: string
    value: string | null
    encrypted: boolean
    description: string | null
    isActive: boolean
    metadata: JsonValue | null
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigurationCountAggregateOutputType | null
    _min: SystemConfigurationMinAggregateOutputType | null
    _max: SystemConfigurationMaxAggregateOutputType | null
  }

  type GetSystemConfigurationGroupByPayload<T extends SystemConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    encrypted?: boolean
    description?: boolean
    isActive?: boolean
    metadata?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfiguration"]>

  export type SystemConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    encrypted?: boolean
    description?: boolean
    isActive?: boolean
    metadata?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfiguration"]>

  export type SystemConfigurationSelectScalar = {
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    encrypted?: boolean
    description?: boolean
    isActive?: boolean
    metadata?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      key: string
      value: string | null
      encrypted: boolean
      description: string | null
      isActive: boolean
      metadata: Prisma.JsonValue | null
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfiguration"]>
    composites: {}
  }

  type SystemConfigurationGetPayload<S extends boolean | null | undefined | SystemConfigurationDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigurationPayload, S>

  type SystemConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigurationCountAggregateInputType | true
    }

  export interface SystemConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfiguration'], meta: { name: 'SystemConfiguration' } }
    /**
     * Find zero or one SystemConfiguration that matches the filter.
     * @param {SystemConfigurationFindUniqueArgs} args - Arguments to find a SystemConfiguration
     * @example
     * // Get one SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigurationFindUniqueArgs>(args: SelectSubset<T, SystemConfigurationFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfiguration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigurationFindUniqueOrThrowArgs} args - Arguments to find a SystemConfiguration
     * @example
     * // Get one SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationFindFirstArgs} args - Arguments to find a SystemConfiguration
     * @example
     * // Get one SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigurationFindFirstArgs>(args?: SelectSubset<T, SystemConfigurationFindFirstArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationFindFirstOrThrowArgs} args - Arguments to find a SystemConfiguration
     * @example
     * // Get one SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigurations
     * const systemConfigurations = await prisma.systemConfiguration.findMany()
     * 
     * // Get first 10 SystemConfigurations
     * const systemConfigurations = await prisma.systemConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigurationWithIdOnly = await prisma.systemConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigurationFindManyArgs>(args?: SelectSubset<T, SystemConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfiguration.
     * @param {SystemConfigurationCreateArgs} args - Arguments to create a SystemConfiguration.
     * @example
     * // Create one SystemConfiguration
     * const SystemConfiguration = await prisma.systemConfiguration.create({
     *   data: {
     *     // ... data to create a SystemConfiguration
     *   }
     * })
     * 
     */
    create<T extends SystemConfigurationCreateArgs>(args: SelectSubset<T, SystemConfigurationCreateArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigurations.
     * @param {SystemConfigurationCreateManyArgs} args - Arguments to create many SystemConfigurations.
     * @example
     * // Create many SystemConfigurations
     * const systemConfiguration = await prisma.systemConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigurationCreateManyArgs>(args?: SelectSubset<T, SystemConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigurations and returns the data saved in the database.
     * @param {SystemConfigurationCreateManyAndReturnArgs} args - Arguments to create many SystemConfigurations.
     * @example
     * // Create many SystemConfigurations
     * const systemConfiguration = await prisma.systemConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigurations and only return the `id`
     * const systemConfigurationWithIdOnly = await prisma.systemConfiguration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfiguration.
     * @param {SystemConfigurationDeleteArgs} args - Arguments to delete one SystemConfiguration.
     * @example
     * // Delete one SystemConfiguration
     * const SystemConfiguration = await prisma.systemConfiguration.delete({
     *   where: {
     *     // ... filter to delete one SystemConfiguration
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigurationDeleteArgs>(args: SelectSubset<T, SystemConfigurationDeleteArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfiguration.
     * @param {SystemConfigurationUpdateArgs} args - Arguments to update one SystemConfiguration.
     * @example
     * // Update one SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigurationUpdateArgs>(args: SelectSubset<T, SystemConfigurationUpdateArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigurations.
     * @param {SystemConfigurationDeleteManyArgs} args - Arguments to filter SystemConfigurations to delete.
     * @example
     * // Delete a few SystemConfigurations
     * const { count } = await prisma.systemConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigurationDeleteManyArgs>(args?: SelectSubset<T, SystemConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigurations
     * const systemConfiguration = await prisma.systemConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigurationUpdateManyArgs>(args: SelectSubset<T, SystemConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfiguration.
     * @param {SystemConfigurationUpsertArgs} args - Arguments to update or create a SystemConfiguration.
     * @example
     * // Update or create a SystemConfiguration
     * const systemConfiguration = await prisma.systemConfiguration.upsert({
     *   create: {
     *     // ... data to create a SystemConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigurationUpsertArgs>(args: SelectSubset<T, SystemConfigurationUpsertArgs<ExtArgs>>): Prisma__SystemConfigurationClient<$Result.GetResult<Prisma.$SystemConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationCountArgs} args - Arguments to filter SystemConfigurations to count.
     * @example
     * // Count the number of SystemConfigurations
     * const count = await prisma.systemConfiguration.count({
     *   where: {
     *     // ... the filter for the SystemConfigurations we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigurationCountArgs>(
      args?: Subset<T, SystemConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigurationAggregateArgs>(args: Subset<T, SystemConfigurationAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigurationAggregateType<T>>

    /**
     * Group by SystemConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfiguration model
   */
  readonly fields: SystemConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfiguration model
   */ 
  interface SystemConfigurationFieldRefs {
    readonly id: FieldRef<"SystemConfiguration", 'String'>
    readonly category: FieldRef<"SystemConfiguration", 'String'>
    readonly key: FieldRef<"SystemConfiguration", 'String'>
    readonly value: FieldRef<"SystemConfiguration", 'String'>
    readonly encrypted: FieldRef<"SystemConfiguration", 'Boolean'>
    readonly description: FieldRef<"SystemConfiguration", 'String'>
    readonly isActive: FieldRef<"SystemConfiguration", 'Boolean'>
    readonly metadata: FieldRef<"SystemConfiguration", 'Json'>
    readonly updatedBy: FieldRef<"SystemConfiguration", 'String'>
    readonly createdAt: FieldRef<"SystemConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfiguration findUnique
   */
  export type SystemConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfiguration to fetch.
     */
    where: SystemConfigurationWhereUniqueInput
  }

  /**
   * SystemConfiguration findUniqueOrThrow
   */
  export type SystemConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfiguration to fetch.
     */
    where: SystemConfigurationWhereUniqueInput
  }

  /**
   * SystemConfiguration findFirst
   */
  export type SystemConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfiguration to fetch.
     */
    where?: SystemConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigurations to fetch.
     */
    orderBy?: SystemConfigurationOrderByWithRelationInput | SystemConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigurations.
     */
    cursor?: SystemConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigurations.
     */
    distinct?: SystemConfigurationScalarFieldEnum | SystemConfigurationScalarFieldEnum[]
  }

  /**
   * SystemConfiguration findFirstOrThrow
   */
  export type SystemConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfiguration to fetch.
     */
    where?: SystemConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigurations to fetch.
     */
    orderBy?: SystemConfigurationOrderByWithRelationInput | SystemConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigurations.
     */
    cursor?: SystemConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigurations.
     */
    distinct?: SystemConfigurationScalarFieldEnum | SystemConfigurationScalarFieldEnum[]
  }

  /**
   * SystemConfiguration findMany
   */
  export type SystemConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigurations to fetch.
     */
    where?: SystemConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigurations to fetch.
     */
    orderBy?: SystemConfigurationOrderByWithRelationInput | SystemConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigurations.
     */
    cursor?: SystemConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigurations.
     */
    skip?: number
    distinct?: SystemConfigurationScalarFieldEnum | SystemConfigurationScalarFieldEnum[]
  }

  /**
   * SystemConfiguration create
   */
  export type SystemConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfiguration.
     */
    data: XOR<SystemConfigurationCreateInput, SystemConfigurationUncheckedCreateInput>
  }

  /**
   * SystemConfiguration createMany
   */
  export type SystemConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigurations.
     */
    data: SystemConfigurationCreateManyInput | SystemConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfiguration createManyAndReturn
   */
  export type SystemConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigurations.
     */
    data: SystemConfigurationCreateManyInput | SystemConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfiguration update
   */
  export type SystemConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfiguration.
     */
    data: XOR<SystemConfigurationUpdateInput, SystemConfigurationUncheckedUpdateInput>
    /**
     * Choose, which SystemConfiguration to update.
     */
    where: SystemConfigurationWhereUniqueInput
  }

  /**
   * SystemConfiguration updateMany
   */
  export type SystemConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigurations.
     */
    data: XOR<SystemConfigurationUpdateManyMutationInput, SystemConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigurations to update
     */
    where?: SystemConfigurationWhereInput
  }

  /**
   * SystemConfiguration upsert
   */
  export type SystemConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfiguration to update in case it exists.
     */
    where: SystemConfigurationWhereUniqueInput
    /**
     * In case the SystemConfiguration found by the `where` argument doesn't exist, create a new SystemConfiguration with this data.
     */
    create: XOR<SystemConfigurationCreateInput, SystemConfigurationUncheckedCreateInput>
    /**
     * In case the SystemConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigurationUpdateInput, SystemConfigurationUncheckedUpdateInput>
  }

  /**
   * SystemConfiguration delete
   */
  export type SystemConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
    /**
     * Filter which SystemConfiguration to delete.
     */
    where: SystemConfigurationWhereUniqueInput
  }

  /**
   * SystemConfiguration deleteMany
   */
  export type SystemConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigurations to delete
     */
    where?: SystemConfigurationWhereInput
  }

  /**
   * SystemConfiguration without action
   */
  export type SystemConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfiguration
     */
    select?: SystemConfigurationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    isAdmin: 'isAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    apiKey: 'apiKey',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    deviceId: 'deviceId',
    platform: 'platform',
    osVersion: 'osVersion',
    appVersion: 'appVersion',
    model: 'model',
    manufacturer: 'manufacturer',
    metadata: 'metadata',
    lastSeenAt: 'lastSeenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deviceCode: 'deviceCode',
    userId: 'userId',
    userEmail: 'userEmail',
    userName: 'userName',
    debugModeEnabled: 'debugModeEnabled',
    debugModeEnabledAt: 'debugModeEnabledAt',
    debugModeExpiresAt: 'debugModeExpiresAt',
    debugModeEnabledBy: 'debugModeEnabledBy',
    status: 'status',
    deletedAt: 'deletedAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    deviceId: 'deviceId',
    sessionId: 'sessionId',
    level: 'level',
    message: 'message',
    tag: 'tag',
    data: 'data',
    fileName: 'fileName',
    lineNumber: 'lineNumber',
    functionName: 'functionName',
    className: 'className',
    screenName: 'screenName',
    threadName: 'threadName',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const CrashScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    deviceId: 'deviceId',
    message: 'message',
    stackTrace: 'stackTrace',
    metadata: 'metadata',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type CrashScalarFieldEnum = (typeof CrashScalarFieldEnum)[keyof typeof CrashScalarFieldEnum]


  export const ApiTraceScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    deviceId: 'deviceId',
    sessionId: 'sessionId',
    url: 'url',
    method: 'method',
    statusCode: 'statusCode',
    requestHeaders: 'requestHeaders',
    requestBody: 'requestBody',
    responseHeaders: 'responseHeaders',
    responseBody: 'responseBody',
    duration: 'duration',
    error: 'error',
    screenName: 'screenName',
    networkType: 'networkType',
    country: 'country',
    carrier: 'carrier',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    cost: 'cost',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type ApiTraceScalarFieldEnum = (typeof ApiTraceScalarFieldEnum)[keyof typeof ApiTraceScalarFieldEnum]


  export const ApiConfigScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    endpoint: 'endpoint',
    method: 'method',
    name: 'name',
    description: 'description',
    costPerRequest: 'costPerRequest',
    isEnabled: 'isEnabled',
    enableLogs: 'enableLogs',
    captureRequestBody: 'captureRequestBody',
    captureResponseBody: 'captureResponseBody',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiConfigScalarFieldEnum = (typeof ApiConfigScalarFieldEnum)[keyof typeof ApiConfigScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    deviceId: 'deviceId',
    sessionToken: 'sessionToken',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    isActive: 'isActive',
    appVersion: 'appVersion',
    osVersion: 'osVersion',
    locale: 'locale',
    timezone: 'timezone',
    networkType: 'networkType',
    screenFlow: 'screenFlow',
    entryScreen: 'entryScreen',
    exitScreen: 'exitScreen',
    duration: 'duration',
    screenCount: 'screenCount',
    eventCount: 'eventCount',
    errorCount: 'errorCount',
    metadata: 'metadata',
    userProperties: 'userProperties',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    emailEnabled: 'emailEnabled',
    emailAddresses: 'emailAddresses',
    pushEnabled: 'pushEnabled',
    pushToken: 'pushToken',
    smsEnabled: 'smsEnabled',
    smsNumbers: 'smsNumbers',
    webhookEnabled: 'webhookEnabled',
    webhookUrl: 'webhookUrl',
    webhookSecret: 'webhookSecret',
    webhookHeaders: 'webhookHeaders',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const ApiAlertScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    endpoint: 'endpoint',
    method: 'method',
    isEnabled: 'isEnabled',
    monitorStandardErrors: 'monitorStandardErrors',
    standardErrorCodes: 'standardErrorCodes',
    customStatusCodes: 'customStatusCodes',
    bodyErrorField: 'bodyErrorField',
    bodyErrorValues: 'bodyErrorValues',
    headerErrorField: 'headerErrorField',
    headerErrorValues: 'headerErrorValues',
    notifyEmail: 'notifyEmail',
    notifyPush: 'notifyPush',
    notifySms: 'notifySms',
    notifyWebhook: 'notifyWebhook',
    cooldownMinutes: 'cooldownMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiAlertScalarFieldEnum = (typeof ApiAlertScalarFieldEnum)[keyof typeof ApiAlertScalarFieldEnum]


  export const MonitoredErrorScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    projectId: 'projectId',
    errorType: 'errorType',
    errorCode: 'errorCode',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    requestBody: 'requestBody',
    responseBody: 'responseBody',
    firstOccurrence: 'firstOccurrence',
    lastOccurrence: 'lastOccurrence',
    occurrenceCount: 'occurrenceCount',
    affectedDevices: 'affectedDevices',
    affectedSessions: 'affectedSessions',
    lastTraceId: 'lastTraceId',
    lastNotifiedAt: 'lastNotifiedAt',
    notificationCount: 'notificationCount',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonitoredErrorScalarFieldEnum = (typeof MonitoredErrorScalarFieldEnum)[keyof typeof MonitoredErrorScalarFieldEnum]


  export const BusinessConfigScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    key: 'key',
    label: 'label',
    description: 'description',
    valueType: 'valueType',
    stringValue: 'stringValue',
    integerValue: 'integerValue',
    booleanValue: 'booleanValue',
    decimalValue: 'decimalValue',
    jsonValue: 'jsonValue',
    imageUrl: 'imageUrl',
    category: 'category',
    isEnabled: 'isEnabled',
    version: 'version',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessConfigScalarFieldEnum = (typeof BusinessConfigScalarFieldEnum)[keyof typeof BusinessConfigScalarFieldEnum]


  export const UploadedFileScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    filename: 'filename',
    storedName: 'storedName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type UploadedFileScalarFieldEnum = (typeof UploadedFileScalarFieldEnum)[keyof typeof UploadedFileScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    code: 'code',
    name: 'name',
    nativeName: 'nativeName',
    isDefault: 'isDefault',
    isEnabled: 'isEnabled',
    isRTL: 'isRTL',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const LocalizationKeyScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    key: 'key',
    description: 'description',
    category: 'category',
    platform: 'platform',
    maxLength: 'maxLength',
    screenshot: 'screenshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalizationKeyScalarFieldEnum = (typeof LocalizationKeyScalarFieldEnum)[keyof typeof LocalizationKeyScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    keyId: 'keyId',
    languageId: 'languageId',
    value: 'value',
    isReviewed: 'isReviewed',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const FeatureFlagsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    sdkEnabled: 'sdkEnabled',
    apiTracking: 'apiTracking',
    screenTracking: 'screenTracking',
    crashReporting: 'crashReporting',
    logging: 'logging',
    deviceTracking: 'deviceTracking',
    sessionTracking: 'sessionTracking',
    businessConfig: 'businessConfig',
    localization: 'localization',
    offlineSupport: 'offlineSupport',
    batchEvents: 'batchEvents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureFlagsScalarFieldEnum = (typeof FeatureFlagsScalarFieldEnum)[keyof typeof FeatureFlagsScalarFieldEnum]


  export const SdkSettingsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    trackingMode: 'trackingMode',
    captureRequestBodies: 'captureRequestBodies',
    captureResponseBodies: 'captureResponseBodies',
    capturePrintStatements: 'capturePrintStatements',
    sanitizeSensitiveData: 'sanitizeSensitiveData',
    sensitiveFieldPatterns: 'sensitiveFieldPatterns',
    maxLogQueueSize: 'maxLogQueueSize',
    maxTraceQueueSize: 'maxTraceQueueSize',
    flushIntervalSeconds: 'flushIntervalSeconds',
    enableBatching: 'enableBatching',
    minLogLevel: 'minLogLevel',
    verboseErrors: 'verboseErrors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SdkSettingsScalarFieldEnum = (typeof SdkSettingsScalarFieldEnum)[keyof typeof SdkSettingsScalarFieldEnum]


  export const ConfigCategoryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    label: 'label',
    description: 'description',
    icon: 'icon',
    order: 'order',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigCategoryScalarFieldEnum = (typeof ConfigCategoryScalarFieldEnum)[keyof typeof ConfigCategoryScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    isActive: 'isActive',
    isPublic: 'isPublic',
    maxProjects: 'maxProjects',
    maxDevices: 'maxDevices',
    maxMockEndpoints: 'maxMockEndpoints',
    maxApiEndpoints: 'maxApiEndpoints',
    maxApiRequests: 'maxApiRequests',
    maxLogs: 'maxLogs',
    maxSessions: 'maxSessions',
    maxCrashes: 'maxCrashes',
    maxBusinessConfigKeys: 'maxBusinessConfigKeys',
    maxLocalizationLanguages: 'maxLocalizationLanguages',
    maxLocalizationKeys: 'maxLocalizationKeys',
    retentionDays: 'retentionDays',
    allowApiTracking: 'allowApiTracking',
    allowScreenTracking: 'allowScreenTracking',
    allowCrashReporting: 'allowCrashReporting',
    allowLogging: 'allowLogging',
    allowBusinessConfig: 'allowBusinessConfig',
    allowLocalization: 'allowLocalization',
    allowCustomDomains: 'allowCustomDomains',
    allowWebhooks: 'allowWebhooks',
    allowTeamMembers: 'allowTeamMembers',
    allowPrioritySupport: 'allowPrioritySupport',
    features: 'features',
    enforcementConfig: 'enforcementConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    status: 'status',
    enabled: 'enabled',
    trialStartDate: 'trialStartDate',
    trialEndDate: 'trialEndDate',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelledAt: 'cancelledAt',
    cancelledReason: 'cancelledReason',
    disabledBy: 'disabledBy',
    disabledAt: 'disabledAt',
    enabledBy: 'enabledBy',
    enabledAt: 'enabledAt',
    quotaMaxProjects: 'quotaMaxProjects',
    quotaMaxDevices: 'quotaMaxDevices',
    quotaMaxMockEndpoints: 'quotaMaxMockEndpoints',
    quotaMaxApiEndpoints: 'quotaMaxApiEndpoints',
    quotaMaxApiRequests: 'quotaMaxApiRequests',
    quotaMaxLogs: 'quotaMaxLogs',
    quotaMaxSessions: 'quotaMaxSessions',
    quotaMaxCrashes: 'quotaMaxCrashes',
    quotaMaxBusinessConfigKeys: 'quotaMaxBusinessConfigKeys',
    quotaMaxLocalizationLanguages: 'quotaMaxLocalizationLanguages',
    quotaMaxLocalizationKeys: 'quotaMaxLocalizationKeys',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const EnforcementStateScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    state: 'state',
    warnEnteredAt: 'warnEnteredAt',
    graceEnteredAt: 'graceEnteredAt',
    graceEndsAt: 'graceEndsAt',
    degradedEnteredAt: 'degradedEnteredAt',
    effectivePolicy: 'effectivePolicy',
    triggeredMetrics: 'triggeredMetrics',
    lastEvaluatedAt: 'lastEvaluatedAt',
    nextEvaluationAt: 'nextEvaluationAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnforcementStateScalarFieldEnum = (typeof EnforcementStateScalarFieldEnum)[keyof typeof EnforcementStateScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    pdfUrl: 'pdfUrl',
    lineItems: 'lineItems',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const BuildScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    version: 'version',
    name: 'name',
    description: 'description',
    mode: 'mode',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    businessConfigSnapshot: 'businessConfigSnapshot',
    localizationSnapshot: 'localizationSnapshot',
    configCount: 'configCount',
    translationCount: 'translationCount'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const BuildFeatureScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    featureType: 'featureType',
    snapshotData: 'snapshotData',
    itemCount: 'itemCount',
    createdAt: 'createdAt'
  };

  export type BuildFeatureScalarFieldEnum = (typeof BuildFeatureScalarFieldEnum)[keyof typeof BuildFeatureScalarFieldEnum]


  export const BuildModeScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    previewBuildId: 'previewBuildId',
    productionBuildId: 'productionBuildId',
    updatedAt: 'updatedAt'
  };

  export type BuildModeScalarFieldEnum = (typeof BuildModeScalarFieldEnum)[keyof typeof BuildModeScalarFieldEnum]


  export const BuildChangeLogScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    featureType: 'featureType',
    changeType: 'changeType',
    itemKey: 'itemKey',
    itemLabel: 'itemLabel',
    oldValue: 'oldValue',
    newValue: 'newValue',
    changedBy: 'changedBy',
    changedAt: 'changedAt'
  };

  export type BuildChangeLogScalarFieldEnum = (typeof BuildChangeLogScalarFieldEnum)[keyof typeof BuildChangeLogScalarFieldEnum]


  export const MockEnvironmentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    basePath: 'basePath',
    mode: 'mode',
    whitelist: 'whitelist',
    blacklist: 'blacklist',
    isEnabled: 'isEnabled',
    isDefault: 'isDefault',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MockEnvironmentScalarFieldEnum = (typeof MockEnvironmentScalarFieldEnum)[keyof typeof MockEnvironmentScalarFieldEnum]


  export const MockEndpointScalarFieldEnum: {
    id: 'id',
    environmentId: 'environmentId',
    path: 'path',
    method: 'method',
    description: 'description',
    isEnabled: 'isEnabled',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MockEndpointScalarFieldEnum = (typeof MockEndpointScalarFieldEnum)[keyof typeof MockEndpointScalarFieldEnum]


  export const MockResponseScalarFieldEnum: {
    id: 'id',
    endpointId: 'endpointId',
    statusCode: 'statusCode',
    name: 'name',
    description: 'description',
    responseBody: 'responseBody',
    responseHeaders: 'responseHeaders',
    delay: 'delay',
    isDefault: 'isDefault',
    isEnabled: 'isEnabled',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MockResponseScalarFieldEnum = (typeof MockResponseScalarFieldEnum)[keyof typeof MockResponseScalarFieldEnum]


  export const MockConditionScalarFieldEnum: {
    id: 'id',
    responseId: 'responseId',
    endpointId: 'endpointId',
    type: 'type',
    key: 'key',
    operator: 'operator',
    value: 'value',
    isCaseSensitive: 'isCaseSensitive',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type MockConditionScalarFieldEnum = (typeof MockConditionScalarFieldEnum)[keyof typeof MockConditionScalarFieldEnum]


  export const ConfigAlertScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    configId: 'configId',
    name: 'name',
    description: 'description',
    condition: 'condition',
    threshold: 'threshold',
    operator: 'operator',
    timeWindow: 'timeWindow',
    minOccurrences: 'minOccurrences',
    enabled: 'enabled',
    webhookUrl: 'webhookUrl',
    emailRecipients: 'emailRecipients',
    lastTriggered: 'lastTriggered',
    triggerCount: 'triggerCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigAlertScalarFieldEnum = (typeof ConfigAlertScalarFieldEnum)[keyof typeof ConfigAlertScalarFieldEnum]


  export const ConfigAlertEventScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    projectId: 'projectId',
    configId: 'configId',
    severity: 'severity',
    message: 'message',
    metadata: 'metadata',
    acknowledged: 'acknowledged',
    acknowledgedBy: 'acknowledgedBy',
    acknowledgedAt: 'acknowledgedAt',
    createdAt: 'createdAt'
  };

  export type ConfigAlertEventScalarFieldEnum = (typeof ConfigAlertEventScalarFieldEnum)[keyof typeof ConfigAlertEventScalarFieldEnum]


  export const ConfigApprovalScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    configId: 'configId',
    changeType: 'changeType',
    changeData: 'changeData',
    status: 'status',
    requiredApprovals: 'requiredApprovals',
    currentApprovals: 'currentApprovals',
    approvers: 'approvers',
    approvals: 'approvals',
    requestedBy: 'requestedBy',
    requestedAt: 'requestedAt',
    decidedBy: 'decidedBy',
    decidedAt: 'decidedAt',
    decisionComment: 'decisionComment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigApprovalScalarFieldEnum = (typeof ConfigApprovalScalarFieldEnum)[keyof typeof ConfigApprovalScalarFieldEnum]


  export const SystemConfigurationScalarFieldEnum: {
    id: 'id',
    category: 'category',
    key: 'key',
    value: 'value',
    encrypted: 'encrypted',
    description: 'description',
    isActive: 'isActive',
    metadata: 'metadata',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigurationScalarFieldEnum = (typeof SystemConfigurationScalarFieldEnum)[keyof typeof SystemConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    apiKey?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    devices?: DeviceListRelationFilter
    logs?: LogListRelationFilter
    crashes?: CrashListRelationFilter
    apiTraces?: ApiTraceListRelationFilter
    apiConfigs?: ApiConfigListRelationFilter
    sessions?: SessionListRelationFilter
    notificationSettings?: XOR<NotificationSettingsNullableRelationFilter, NotificationSettingsWhereInput> | null
    apiAlerts?: ApiAlertListRelationFilter
    builds?: BuildListRelationFilter
    buildMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
    mockEnvironments?: MockEnvironmentListRelationFilter
    businessConfigs?: BusinessConfigListRelationFilter
    configAlerts?: ConfigAlertListRelationFilter
    configApprovals?: ConfigApprovalListRelationFilter
    languages?: LanguageListRelationFilter
    localizationKeys?: LocalizationKeyListRelationFilter
    featureFlags?: XOR<FeatureFlagsNullableRelationFilter, FeatureFlagsWhereInput> | null
    sdkSettings?: XOR<SdkSettingsNullableRelationFilter, SdkSettingsWhereInput> | null
    configCategories?: ConfigCategoryListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    devices?: DeviceOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    crashes?: CrashOrderByRelationAggregateInput
    apiTraces?: ApiTraceOrderByRelationAggregateInput
    apiConfigs?: ApiConfigOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    notificationSettings?: NotificationSettingsOrderByWithRelationInput
    apiAlerts?: ApiAlertOrderByRelationAggregateInput
    builds?: BuildOrderByRelationAggregateInput
    buildMode?: BuildModeOrderByWithRelationInput
    mockEnvironments?: MockEnvironmentOrderByRelationAggregateInput
    businessConfigs?: BusinessConfigOrderByRelationAggregateInput
    configAlerts?: ConfigAlertOrderByRelationAggregateInput
    configApprovals?: ConfigApprovalOrderByRelationAggregateInput
    languages?: LanguageOrderByRelationAggregateInput
    localizationKeys?: LocalizationKeyOrderByRelationAggregateInput
    featureFlags?: FeatureFlagsOrderByWithRelationInput
    sdkSettings?: SdkSettingsOrderByWithRelationInput
    configCategories?: ConfigCategoryOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiKey?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    devices?: DeviceListRelationFilter
    logs?: LogListRelationFilter
    crashes?: CrashListRelationFilter
    apiTraces?: ApiTraceListRelationFilter
    apiConfigs?: ApiConfigListRelationFilter
    sessions?: SessionListRelationFilter
    notificationSettings?: XOR<NotificationSettingsNullableRelationFilter, NotificationSettingsWhereInput> | null
    apiAlerts?: ApiAlertListRelationFilter
    builds?: BuildListRelationFilter
    buildMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
    mockEnvironments?: MockEnvironmentListRelationFilter
    businessConfigs?: BusinessConfigListRelationFilter
    configAlerts?: ConfigAlertListRelationFilter
    configApprovals?: ConfigApprovalListRelationFilter
    languages?: LanguageListRelationFilter
    localizationKeys?: LocalizationKeyListRelationFilter
    featureFlags?: XOR<FeatureFlagsNullableRelationFilter, FeatureFlagsWhereInput> | null
    sdkSettings?: XOR<SdkSettingsNullableRelationFilter, SdkSettingsWhereInput> | null
    configCategories?: ConfigCategoryListRelationFilter
  }, "id" | "apiKey">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    apiKey?: StringWithAggregatesFilter<"Project"> | string
    userId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    projectId?: StringNullableFilter<"Device"> | string | null
    deviceId?: StringFilter<"Device"> | string
    platform?: StringFilter<"Device"> | string
    osVersion?: StringNullableFilter<"Device"> | string | null
    appVersion?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    manufacturer?: StringNullableFilter<"Device"> | string | null
    metadata?: JsonNullableFilter<"Device">
    lastSeenAt?: DateTimeFilter<"Device"> | Date | string
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    deviceCode?: StringNullableFilter<"Device"> | string | null
    userId?: StringNullableFilter<"Device"> | string | null
    userEmail?: StringNullableFilter<"Device"> | string | null
    userName?: StringNullableFilter<"Device"> | string | null
    debugModeEnabled?: BoolFilter<"Device"> | boolean
    debugModeEnabledAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeExpiresAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeEnabledBy?: StringNullableFilter<"Device"> | string | null
    status?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    logs?: LogListRelationFilter
    crashes?: CrashListRelationFilter
    apiTraces?: ApiTraceListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    deviceId?: SortOrder
    platform?: SortOrder
    osVersion?: SortOrderInput | SortOrder
    appVersion?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceCode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    debugModeEnabled?: SortOrder
    debugModeEnabledAt?: SortOrderInput | SortOrder
    debugModeExpiresAt?: SortOrderInput | SortOrder
    debugModeEnabledBy?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    logs?: LogOrderByRelationAggregateInput
    crashes?: CrashOrderByRelationAggregateInput
    apiTraces?: ApiTraceOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceCode?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    projectId?: StringNullableFilter<"Device"> | string | null
    deviceId?: StringFilter<"Device"> | string
    platform?: StringFilter<"Device"> | string
    osVersion?: StringNullableFilter<"Device"> | string | null
    appVersion?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    manufacturer?: StringNullableFilter<"Device"> | string | null
    metadata?: JsonNullableFilter<"Device">
    lastSeenAt?: DateTimeFilter<"Device"> | Date | string
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    userId?: StringNullableFilter<"Device"> | string | null
    userEmail?: StringNullableFilter<"Device"> | string | null
    userName?: StringNullableFilter<"Device"> | string | null
    debugModeEnabled?: BoolFilter<"Device"> | boolean
    debugModeEnabledAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeExpiresAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeEnabledBy?: StringNullableFilter<"Device"> | string | null
    status?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    logs?: LogListRelationFilter
    crashes?: CrashListRelationFilter
    apiTraces?: ApiTraceListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "deviceCode">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    deviceId?: SortOrder
    platform?: SortOrder
    osVersion?: SortOrderInput | SortOrder
    appVersion?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceCode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    debugModeEnabled?: SortOrder
    debugModeEnabledAt?: SortOrderInput | SortOrder
    debugModeExpiresAt?: SortOrderInput | SortOrder
    debugModeEnabledBy?: SortOrderInput | SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    projectId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    deviceId?: StringWithAggregatesFilter<"Device"> | string
    platform?: StringWithAggregatesFilter<"Device"> | string
    osVersion?: StringNullableWithAggregatesFilter<"Device"> | string | null
    appVersion?: StringNullableWithAggregatesFilter<"Device"> | string | null
    model?: StringNullableWithAggregatesFilter<"Device"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Device"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Device">
    lastSeenAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    deviceCode?: StringNullableWithAggregatesFilter<"Device"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"Device"> | string | null
    userName?: StringNullableWithAggregatesFilter<"Device"> | string | null
    debugModeEnabled?: BoolWithAggregatesFilter<"Device"> | boolean
    debugModeEnabledAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    debugModeExpiresAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    debugModeEnabledBy?: StringNullableWithAggregatesFilter<"Device"> | string | null
    status?: StringWithAggregatesFilter<"Device"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    projectId?: StringFilter<"Log"> | string
    deviceId?: StringNullableFilter<"Log"> | string | null
    sessionId?: StringNullableFilter<"Log"> | string | null
    level?: StringFilter<"Log"> | string
    message?: StringFilter<"Log"> | string
    tag?: StringNullableFilter<"Log"> | string | null
    data?: JsonNullableFilter<"Log">
    fileName?: StringNullableFilter<"Log"> | string | null
    lineNumber?: IntNullableFilter<"Log"> | number | null
    functionName?: StringNullableFilter<"Log"> | string | null
    className?: StringNullableFilter<"Log"> | string | null
    screenName?: StringNullableFilter<"Log"> | string | null
    threadName?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    level?: SortOrder
    message?: SortOrder
    tag?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    lineNumber?: SortOrderInput | SortOrder
    functionName?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    screenName?: SortOrderInput | SortOrder
    threadName?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    projectId?: StringFilter<"Log"> | string
    deviceId?: StringNullableFilter<"Log"> | string | null
    sessionId?: StringNullableFilter<"Log"> | string | null
    level?: StringFilter<"Log"> | string
    message?: StringFilter<"Log"> | string
    tag?: StringNullableFilter<"Log"> | string | null
    data?: JsonNullableFilter<"Log">
    fileName?: StringNullableFilter<"Log"> | string | null
    lineNumber?: IntNullableFilter<"Log"> | number | null
    functionName?: StringNullableFilter<"Log"> | string | null
    className?: StringNullableFilter<"Log"> | string | null
    screenName?: StringNullableFilter<"Log"> | string | null
    threadName?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    level?: SortOrder
    message?: SortOrder
    tag?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    lineNumber?: SortOrderInput | SortOrder
    functionName?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    screenName?: SortOrderInput | SortOrder
    threadName?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    projectId?: StringWithAggregatesFilter<"Log"> | string
    deviceId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    level?: StringWithAggregatesFilter<"Log"> | string
    message?: StringWithAggregatesFilter<"Log"> | string
    tag?: StringNullableWithAggregatesFilter<"Log"> | string | null
    data?: JsonNullableWithAggregatesFilter<"Log">
    fileName?: StringNullableWithAggregatesFilter<"Log"> | string | null
    lineNumber?: IntNullableWithAggregatesFilter<"Log"> | number | null
    functionName?: StringNullableWithAggregatesFilter<"Log"> | string | null
    className?: StringNullableWithAggregatesFilter<"Log"> | string | null
    screenName?: StringNullableWithAggregatesFilter<"Log"> | string | null
    threadName?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
  }

  export type CrashWhereInput = {
    AND?: CrashWhereInput | CrashWhereInput[]
    OR?: CrashWhereInput[]
    NOT?: CrashWhereInput | CrashWhereInput[]
    id?: StringFilter<"Crash"> | string
    projectId?: StringFilter<"Crash"> | string
    deviceId?: StringNullableFilter<"Crash"> | string | null
    message?: StringFilter<"Crash"> | string
    stackTrace?: StringNullableFilter<"Crash"> | string | null
    metadata?: JsonNullableFilter<"Crash">
    timestamp?: DateTimeFilter<"Crash"> | Date | string
    createdAt?: DateTimeFilter<"Crash"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
  }

  export type CrashOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    message?: SortOrder
    stackTrace?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
  }

  export type CrashWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrashWhereInput | CrashWhereInput[]
    OR?: CrashWhereInput[]
    NOT?: CrashWhereInput | CrashWhereInput[]
    projectId?: StringFilter<"Crash"> | string
    deviceId?: StringNullableFilter<"Crash"> | string | null
    message?: StringFilter<"Crash"> | string
    stackTrace?: StringNullableFilter<"Crash"> | string | null
    metadata?: JsonNullableFilter<"Crash">
    timestamp?: DateTimeFilter<"Crash"> | Date | string
    createdAt?: DateTimeFilter<"Crash"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
  }, "id">

  export type CrashOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    message?: SortOrder
    stackTrace?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: CrashCountOrderByAggregateInput
    _max?: CrashMaxOrderByAggregateInput
    _min?: CrashMinOrderByAggregateInput
  }

  export type CrashScalarWhereWithAggregatesInput = {
    AND?: CrashScalarWhereWithAggregatesInput | CrashScalarWhereWithAggregatesInput[]
    OR?: CrashScalarWhereWithAggregatesInput[]
    NOT?: CrashScalarWhereWithAggregatesInput | CrashScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crash"> | string
    projectId?: StringWithAggregatesFilter<"Crash"> | string
    deviceId?: StringNullableWithAggregatesFilter<"Crash"> | string | null
    message?: StringWithAggregatesFilter<"Crash"> | string
    stackTrace?: StringNullableWithAggregatesFilter<"Crash"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Crash">
    timestamp?: DateTimeWithAggregatesFilter<"Crash"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Crash"> | Date | string
  }

  export type ApiTraceWhereInput = {
    AND?: ApiTraceWhereInput | ApiTraceWhereInput[]
    OR?: ApiTraceWhereInput[]
    NOT?: ApiTraceWhereInput | ApiTraceWhereInput[]
    id?: StringFilter<"ApiTrace"> | string
    projectId?: StringFilter<"ApiTrace"> | string
    deviceId?: StringNullableFilter<"ApiTrace"> | string | null
    sessionId?: StringNullableFilter<"ApiTrace"> | string | null
    url?: StringFilter<"ApiTrace"> | string
    method?: StringFilter<"ApiTrace"> | string
    statusCode?: IntNullableFilter<"ApiTrace"> | number | null
    requestHeaders?: JsonNullableFilter<"ApiTrace">
    requestBody?: StringNullableFilter<"ApiTrace"> | string | null
    responseHeaders?: JsonNullableFilter<"ApiTrace">
    responseBody?: StringNullableFilter<"ApiTrace"> | string | null
    duration?: IntNullableFilter<"ApiTrace"> | number | null
    error?: StringNullableFilter<"ApiTrace"> | string | null
    screenName?: StringNullableFilter<"ApiTrace"> | string | null
    networkType?: StringNullableFilter<"ApiTrace"> | string | null
    country?: StringNullableFilter<"ApiTrace"> | string | null
    carrier?: StringNullableFilter<"ApiTrace"> | string | null
    ipAddress?: StringNullableFilter<"ApiTrace"> | string | null
    userAgent?: StringNullableFilter<"ApiTrace"> | string | null
    cost?: FloatNullableFilter<"ApiTrace"> | number | null
    timestamp?: DateTimeFilter<"ApiTrace"> | Date | string
    createdAt?: DateTimeFilter<"ApiTrace"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }

  export type ApiTraceOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    screenName?: SortOrderInput | SortOrder
    networkType?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
  }

  export type ApiTraceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiTraceWhereInput | ApiTraceWhereInput[]
    OR?: ApiTraceWhereInput[]
    NOT?: ApiTraceWhereInput | ApiTraceWhereInput[]
    projectId?: StringFilter<"ApiTrace"> | string
    deviceId?: StringNullableFilter<"ApiTrace"> | string | null
    sessionId?: StringNullableFilter<"ApiTrace"> | string | null
    url?: StringFilter<"ApiTrace"> | string
    method?: StringFilter<"ApiTrace"> | string
    statusCode?: IntNullableFilter<"ApiTrace"> | number | null
    requestHeaders?: JsonNullableFilter<"ApiTrace">
    requestBody?: StringNullableFilter<"ApiTrace"> | string | null
    responseHeaders?: JsonNullableFilter<"ApiTrace">
    responseBody?: StringNullableFilter<"ApiTrace"> | string | null
    duration?: IntNullableFilter<"ApiTrace"> | number | null
    error?: StringNullableFilter<"ApiTrace"> | string | null
    screenName?: StringNullableFilter<"ApiTrace"> | string | null
    networkType?: StringNullableFilter<"ApiTrace"> | string | null
    country?: StringNullableFilter<"ApiTrace"> | string | null
    carrier?: StringNullableFilter<"ApiTrace"> | string | null
    ipAddress?: StringNullableFilter<"ApiTrace"> | string | null
    userAgent?: StringNullableFilter<"ApiTrace"> | string | null
    cost?: FloatNullableFilter<"ApiTrace"> | number | null
    timestamp?: DateTimeFilter<"ApiTrace"> | Date | string
    createdAt?: DateTimeFilter<"ApiTrace"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }, "id">

  export type ApiTraceOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    screenName?: SortOrderInput | SortOrder
    networkType?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: ApiTraceCountOrderByAggregateInput
    _avg?: ApiTraceAvgOrderByAggregateInput
    _max?: ApiTraceMaxOrderByAggregateInput
    _min?: ApiTraceMinOrderByAggregateInput
    _sum?: ApiTraceSumOrderByAggregateInput
  }

  export type ApiTraceScalarWhereWithAggregatesInput = {
    AND?: ApiTraceScalarWhereWithAggregatesInput | ApiTraceScalarWhereWithAggregatesInput[]
    OR?: ApiTraceScalarWhereWithAggregatesInput[]
    NOT?: ApiTraceScalarWhereWithAggregatesInput | ApiTraceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiTrace"> | string
    projectId?: StringWithAggregatesFilter<"ApiTrace"> | string
    deviceId?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    url?: StringWithAggregatesFilter<"ApiTrace"> | string
    method?: StringWithAggregatesFilter<"ApiTrace"> | string
    statusCode?: IntNullableWithAggregatesFilter<"ApiTrace"> | number | null
    requestHeaders?: JsonNullableWithAggregatesFilter<"ApiTrace">
    requestBody?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    responseHeaders?: JsonNullableWithAggregatesFilter<"ApiTrace">
    responseBody?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    duration?: IntNullableWithAggregatesFilter<"ApiTrace"> | number | null
    error?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    screenName?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    networkType?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    country?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ApiTrace"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"ApiTrace"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"ApiTrace"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiTrace"> | Date | string
  }

  export type ApiConfigWhereInput = {
    AND?: ApiConfigWhereInput | ApiConfigWhereInput[]
    OR?: ApiConfigWhereInput[]
    NOT?: ApiConfigWhereInput | ApiConfigWhereInput[]
    id?: StringFilter<"ApiConfig"> | string
    projectId?: StringFilter<"ApiConfig"> | string
    endpoint?: StringFilter<"ApiConfig"> | string
    method?: StringNullableFilter<"ApiConfig"> | string | null
    name?: StringNullableFilter<"ApiConfig"> | string | null
    description?: StringNullableFilter<"ApiConfig"> | string | null
    costPerRequest?: FloatFilter<"ApiConfig"> | number
    isEnabled?: BoolFilter<"ApiConfig"> | boolean
    enableLogs?: BoolFilter<"ApiConfig"> | boolean
    captureRequestBody?: BoolFilter<"ApiConfig"> | boolean
    captureResponseBody?: BoolFilter<"ApiConfig"> | boolean
    metadata?: JsonNullableFilter<"ApiConfig">
    createdAt?: DateTimeFilter<"ApiConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ApiConfig"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ApiConfigOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    costPerRequest?: SortOrder
    isEnabled?: SortOrder
    enableLogs?: SortOrder
    captureRequestBody?: SortOrder
    captureResponseBody?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ApiConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_endpoint_method?: ApiConfigProjectIdEndpointMethodCompoundUniqueInput
    AND?: ApiConfigWhereInput | ApiConfigWhereInput[]
    OR?: ApiConfigWhereInput[]
    NOT?: ApiConfigWhereInput | ApiConfigWhereInput[]
    projectId?: StringFilter<"ApiConfig"> | string
    endpoint?: StringFilter<"ApiConfig"> | string
    method?: StringNullableFilter<"ApiConfig"> | string | null
    name?: StringNullableFilter<"ApiConfig"> | string | null
    description?: StringNullableFilter<"ApiConfig"> | string | null
    costPerRequest?: FloatFilter<"ApiConfig"> | number
    isEnabled?: BoolFilter<"ApiConfig"> | boolean
    enableLogs?: BoolFilter<"ApiConfig"> | boolean
    captureRequestBody?: BoolFilter<"ApiConfig"> | boolean
    captureResponseBody?: BoolFilter<"ApiConfig"> | boolean
    metadata?: JsonNullableFilter<"ApiConfig">
    createdAt?: DateTimeFilter<"ApiConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ApiConfig"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_endpoint_method">

  export type ApiConfigOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    costPerRequest?: SortOrder
    isEnabled?: SortOrder
    enableLogs?: SortOrder
    captureRequestBody?: SortOrder
    captureResponseBody?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiConfigCountOrderByAggregateInput
    _avg?: ApiConfigAvgOrderByAggregateInput
    _max?: ApiConfigMaxOrderByAggregateInput
    _min?: ApiConfigMinOrderByAggregateInput
    _sum?: ApiConfigSumOrderByAggregateInput
  }

  export type ApiConfigScalarWhereWithAggregatesInput = {
    AND?: ApiConfigScalarWhereWithAggregatesInput | ApiConfigScalarWhereWithAggregatesInput[]
    OR?: ApiConfigScalarWhereWithAggregatesInput[]
    NOT?: ApiConfigScalarWhereWithAggregatesInput | ApiConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiConfig"> | string
    projectId?: StringWithAggregatesFilter<"ApiConfig"> | string
    endpoint?: StringWithAggregatesFilter<"ApiConfig"> | string
    method?: StringNullableWithAggregatesFilter<"ApiConfig"> | string | null
    name?: StringNullableWithAggregatesFilter<"ApiConfig"> | string | null
    description?: StringNullableWithAggregatesFilter<"ApiConfig"> | string | null
    costPerRequest?: FloatWithAggregatesFilter<"ApiConfig"> | number
    isEnabled?: BoolWithAggregatesFilter<"ApiConfig"> | boolean
    enableLogs?: BoolWithAggregatesFilter<"ApiConfig"> | boolean
    captureRequestBody?: BoolWithAggregatesFilter<"ApiConfig"> | boolean
    captureResponseBody?: BoolWithAggregatesFilter<"ApiConfig"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"ApiConfig">
    createdAt?: DateTimeWithAggregatesFilter<"ApiConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiConfig"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    projectId?: StringFilter<"Session"> | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    sessionToken?: StringFilter<"Session"> | string
    startedAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isActive?: BoolFilter<"Session"> | boolean
    appVersion?: StringNullableFilter<"Session"> | string | null
    osVersion?: StringNullableFilter<"Session"> | string | null
    locale?: StringNullableFilter<"Session"> | string | null
    timezone?: StringNullableFilter<"Session"> | string | null
    networkType?: StringNullableFilter<"Session"> | string | null
    screenFlow?: StringNullableListFilter<"Session">
    entryScreen?: StringNullableFilter<"Session"> | string | null
    exitScreen?: StringNullableFilter<"Session"> | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    screenCount?: IntFilter<"Session"> | number
    eventCount?: IntFilter<"Session"> | number
    errorCount?: IntFilter<"Session"> | number
    metadata?: JsonNullableFilter<"Session">
    userProperties?: JsonNullableFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    apiTraces?: ApiTraceListRelationFilter
    logs?: LogListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    appVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    networkType?: SortOrderInput | SortOrder
    screenFlow?: SortOrder
    entryScreen?: SortOrderInput | SortOrder
    exitScreen?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userProperties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    apiTraces?: ApiTraceOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    projectId?: StringFilter<"Session"> | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    startedAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isActive?: BoolFilter<"Session"> | boolean
    appVersion?: StringNullableFilter<"Session"> | string | null
    osVersion?: StringNullableFilter<"Session"> | string | null
    locale?: StringNullableFilter<"Session"> | string | null
    timezone?: StringNullableFilter<"Session"> | string | null
    networkType?: StringNullableFilter<"Session"> | string | null
    screenFlow?: StringNullableListFilter<"Session">
    entryScreen?: StringNullableFilter<"Session"> | string | null
    exitScreen?: StringNullableFilter<"Session"> | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    screenCount?: IntFilter<"Session"> | number
    eventCount?: IntFilter<"Session"> | number
    errorCount?: IntFilter<"Session"> | number
    metadata?: JsonNullableFilter<"Session">
    userProperties?: JsonNullableFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
    apiTraces?: ApiTraceListRelationFilter
    logs?: LogListRelationFilter
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    appVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    networkType?: SortOrderInput | SortOrder
    screenFlow?: SortOrder
    entryScreen?: SortOrderInput | SortOrder
    exitScreen?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userProperties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    projectId?: StringWithAggregatesFilter<"Session"> | string
    deviceId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    startedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Session"> | boolean
    appVersion?: StringNullableWithAggregatesFilter<"Session"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"Session"> | string | null
    locale?: StringNullableWithAggregatesFilter<"Session"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"Session"> | string | null
    networkType?: StringNullableWithAggregatesFilter<"Session"> | string | null
    screenFlow?: StringNullableListFilter<"Session">
    entryScreen?: StringNullableWithAggregatesFilter<"Session"> | string | null
    exitScreen?: StringNullableWithAggregatesFilter<"Session"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Session"> | number | null
    screenCount?: IntWithAggregatesFilter<"Session"> | number
    eventCount?: IntWithAggregatesFilter<"Session"> | number
    errorCount?: IntWithAggregatesFilter<"Session"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Session">
    userProperties?: JsonNullableWithAggregatesFilter<"Session">
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    projectId?: StringFilter<"NotificationSettings"> | string
    emailEnabled?: BoolFilter<"NotificationSettings"> | boolean
    emailAddresses?: StringNullableListFilter<"NotificationSettings">
    pushEnabled?: BoolFilter<"NotificationSettings"> | boolean
    pushToken?: StringNullableFilter<"NotificationSettings"> | string | null
    smsEnabled?: BoolFilter<"NotificationSettings"> | boolean
    smsNumbers?: StringNullableListFilter<"NotificationSettings">
    webhookEnabled?: BoolFilter<"NotificationSettings"> | boolean
    webhookUrl?: StringNullableFilter<"NotificationSettings"> | string | null
    webhookSecret?: StringNullableFilter<"NotificationSettings"> | string | null
    webhookHeaders?: JsonNullableFilter<"NotificationSettings">
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    emailEnabled?: SortOrder
    emailAddresses?: SortOrder
    pushEnabled?: SortOrder
    pushToken?: SortOrderInput | SortOrder
    smsEnabled?: SortOrder
    smsNumbers?: SortOrder
    webhookEnabled?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    webhookHeaders?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    emailEnabled?: BoolFilter<"NotificationSettings"> | boolean
    emailAddresses?: StringNullableListFilter<"NotificationSettings">
    pushEnabled?: BoolFilter<"NotificationSettings"> | boolean
    pushToken?: StringNullableFilter<"NotificationSettings"> | string | null
    smsEnabled?: BoolFilter<"NotificationSettings"> | boolean
    smsNumbers?: StringNullableListFilter<"NotificationSettings">
    webhookEnabled?: BoolFilter<"NotificationSettings"> | boolean
    webhookUrl?: StringNullableFilter<"NotificationSettings"> | string | null
    webhookSecret?: StringNullableFilter<"NotificationSettings"> | string | null
    webhookHeaders?: JsonNullableFilter<"NotificationSettings">
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    emailEnabled?: SortOrder
    emailAddresses?: SortOrder
    pushEnabled?: SortOrder
    pushToken?: SortOrderInput | SortOrder
    smsEnabled?: SortOrder
    smsNumbers?: SortOrder
    webhookEnabled?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    webhookHeaders?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    projectId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    emailEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    emailAddresses?: StringNullableListFilter<"NotificationSettings">
    pushEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    pushToken?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    smsEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    smsNumbers?: StringNullableListFilter<"NotificationSettings">
    webhookEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    webhookUrl?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    webhookSecret?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    webhookHeaders?: JsonNullableWithAggregatesFilter<"NotificationSettings">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type ApiAlertWhereInput = {
    AND?: ApiAlertWhereInput | ApiAlertWhereInput[]
    OR?: ApiAlertWhereInput[]
    NOT?: ApiAlertWhereInput | ApiAlertWhereInput[]
    id?: StringFilter<"ApiAlert"> | string
    projectId?: StringFilter<"ApiAlert"> | string
    title?: StringFilter<"ApiAlert"> | string
    description?: StringNullableFilter<"ApiAlert"> | string | null
    endpoint?: StringNullableFilter<"ApiAlert"> | string | null
    method?: StringNullableFilter<"ApiAlert"> | string | null
    isEnabled?: BoolFilter<"ApiAlert"> | boolean
    monitorStandardErrors?: BoolFilter<"ApiAlert"> | boolean
    standardErrorCodes?: IntNullableListFilter<"ApiAlert">
    customStatusCodes?: IntNullableListFilter<"ApiAlert">
    bodyErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    bodyErrorValues?: StringNullableListFilter<"ApiAlert">
    headerErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    headerErrorValues?: StringNullableListFilter<"ApiAlert">
    notifyEmail?: BoolFilter<"ApiAlert"> | boolean
    notifyPush?: BoolFilter<"ApiAlert"> | boolean
    notifySms?: BoolFilter<"ApiAlert"> | boolean
    notifyWebhook?: BoolFilter<"ApiAlert"> | boolean
    cooldownMinutes?: IntFilter<"ApiAlert"> | number
    createdAt?: DateTimeFilter<"ApiAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ApiAlert"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    monitoredErrors?: MonitoredErrorListRelationFilter
  }

  export type ApiAlertOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    monitorStandardErrors?: SortOrder
    standardErrorCodes?: SortOrder
    customStatusCodes?: SortOrder
    bodyErrorField?: SortOrderInput | SortOrder
    bodyErrorValues?: SortOrder
    headerErrorField?: SortOrderInput | SortOrder
    headerErrorValues?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifySms?: SortOrder
    notifyWebhook?: SortOrder
    cooldownMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    monitoredErrors?: MonitoredErrorOrderByRelationAggregateInput
  }

  export type ApiAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiAlertWhereInput | ApiAlertWhereInput[]
    OR?: ApiAlertWhereInput[]
    NOT?: ApiAlertWhereInput | ApiAlertWhereInput[]
    projectId?: StringFilter<"ApiAlert"> | string
    title?: StringFilter<"ApiAlert"> | string
    description?: StringNullableFilter<"ApiAlert"> | string | null
    endpoint?: StringNullableFilter<"ApiAlert"> | string | null
    method?: StringNullableFilter<"ApiAlert"> | string | null
    isEnabled?: BoolFilter<"ApiAlert"> | boolean
    monitorStandardErrors?: BoolFilter<"ApiAlert"> | boolean
    standardErrorCodes?: IntNullableListFilter<"ApiAlert">
    customStatusCodes?: IntNullableListFilter<"ApiAlert">
    bodyErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    bodyErrorValues?: StringNullableListFilter<"ApiAlert">
    headerErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    headerErrorValues?: StringNullableListFilter<"ApiAlert">
    notifyEmail?: BoolFilter<"ApiAlert"> | boolean
    notifyPush?: BoolFilter<"ApiAlert"> | boolean
    notifySms?: BoolFilter<"ApiAlert"> | boolean
    notifyWebhook?: BoolFilter<"ApiAlert"> | boolean
    cooldownMinutes?: IntFilter<"ApiAlert"> | number
    createdAt?: DateTimeFilter<"ApiAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ApiAlert"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    monitoredErrors?: MonitoredErrorListRelationFilter
  }, "id">

  export type ApiAlertOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    monitorStandardErrors?: SortOrder
    standardErrorCodes?: SortOrder
    customStatusCodes?: SortOrder
    bodyErrorField?: SortOrderInput | SortOrder
    bodyErrorValues?: SortOrder
    headerErrorField?: SortOrderInput | SortOrder
    headerErrorValues?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifySms?: SortOrder
    notifyWebhook?: SortOrder
    cooldownMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiAlertCountOrderByAggregateInput
    _avg?: ApiAlertAvgOrderByAggregateInput
    _max?: ApiAlertMaxOrderByAggregateInput
    _min?: ApiAlertMinOrderByAggregateInput
    _sum?: ApiAlertSumOrderByAggregateInput
  }

  export type ApiAlertScalarWhereWithAggregatesInput = {
    AND?: ApiAlertScalarWhereWithAggregatesInput | ApiAlertScalarWhereWithAggregatesInput[]
    OR?: ApiAlertScalarWhereWithAggregatesInput[]
    NOT?: ApiAlertScalarWhereWithAggregatesInput | ApiAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiAlert"> | string
    projectId?: StringWithAggregatesFilter<"ApiAlert"> | string
    title?: StringWithAggregatesFilter<"ApiAlert"> | string
    description?: StringNullableWithAggregatesFilter<"ApiAlert"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"ApiAlert"> | string | null
    method?: StringNullableWithAggregatesFilter<"ApiAlert"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    monitorStandardErrors?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    standardErrorCodes?: IntNullableListFilter<"ApiAlert">
    customStatusCodes?: IntNullableListFilter<"ApiAlert">
    bodyErrorField?: StringNullableWithAggregatesFilter<"ApiAlert"> | string | null
    bodyErrorValues?: StringNullableListFilter<"ApiAlert">
    headerErrorField?: StringNullableWithAggregatesFilter<"ApiAlert"> | string | null
    headerErrorValues?: StringNullableListFilter<"ApiAlert">
    notifyEmail?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    notifyPush?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    notifySms?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    notifyWebhook?: BoolWithAggregatesFilter<"ApiAlert"> | boolean
    cooldownMinutes?: IntWithAggregatesFilter<"ApiAlert"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiAlert"> | Date | string
  }

  export type MonitoredErrorWhereInput = {
    AND?: MonitoredErrorWhereInput | MonitoredErrorWhereInput[]
    OR?: MonitoredErrorWhereInput[]
    NOT?: MonitoredErrorWhereInput | MonitoredErrorWhereInput[]
    id?: StringFilter<"MonitoredError"> | string
    alertId?: StringFilter<"MonitoredError"> | string
    projectId?: StringFilter<"MonitoredError"> | string
    errorType?: StringFilter<"MonitoredError"> | string
    errorCode?: StringFilter<"MonitoredError"> | string
    endpoint?: StringFilter<"MonitoredError"> | string
    method?: StringFilter<"MonitoredError"> | string
    statusCode?: IntNullableFilter<"MonitoredError"> | number | null
    requestBody?: StringNullableFilter<"MonitoredError"> | string | null
    responseBody?: StringNullableFilter<"MonitoredError"> | string | null
    firstOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    lastOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    occurrenceCount?: IntFilter<"MonitoredError"> | number
    affectedDevices?: StringNullableListFilter<"MonitoredError">
    affectedSessions?: StringNullableListFilter<"MonitoredError">
    lastTraceId?: StringNullableFilter<"MonitoredError"> | string | null
    lastNotifiedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    notificationCount?: IntFilter<"MonitoredError"> | number
    isResolved?: BoolFilter<"MonitoredError"> | boolean
    resolvedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    resolvedBy?: StringNullableFilter<"MonitoredError"> | string | null
    notes?: StringNullableFilter<"MonitoredError"> | string | null
    createdAt?: DateTimeFilter<"MonitoredError"> | Date | string
    updatedAt?: DateTimeFilter<"MonitoredError"> | Date | string
    alert?: XOR<ApiAlertRelationFilter, ApiAlertWhereInput>
  }

  export type MonitoredErrorOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    errorType?: SortOrder
    errorCode?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    firstOccurrence?: SortOrder
    lastOccurrence?: SortOrder
    occurrenceCount?: SortOrder
    affectedDevices?: SortOrder
    affectedSessions?: SortOrder
    lastTraceId?: SortOrderInput | SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    notificationCount?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alert?: ApiAlertOrderByWithRelationInput
  }

  export type MonitoredErrorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonitoredErrorWhereInput | MonitoredErrorWhereInput[]
    OR?: MonitoredErrorWhereInput[]
    NOT?: MonitoredErrorWhereInput | MonitoredErrorWhereInput[]
    alertId?: StringFilter<"MonitoredError"> | string
    projectId?: StringFilter<"MonitoredError"> | string
    errorType?: StringFilter<"MonitoredError"> | string
    errorCode?: StringFilter<"MonitoredError"> | string
    endpoint?: StringFilter<"MonitoredError"> | string
    method?: StringFilter<"MonitoredError"> | string
    statusCode?: IntNullableFilter<"MonitoredError"> | number | null
    requestBody?: StringNullableFilter<"MonitoredError"> | string | null
    responseBody?: StringNullableFilter<"MonitoredError"> | string | null
    firstOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    lastOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    occurrenceCount?: IntFilter<"MonitoredError"> | number
    affectedDevices?: StringNullableListFilter<"MonitoredError">
    affectedSessions?: StringNullableListFilter<"MonitoredError">
    lastTraceId?: StringNullableFilter<"MonitoredError"> | string | null
    lastNotifiedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    notificationCount?: IntFilter<"MonitoredError"> | number
    isResolved?: BoolFilter<"MonitoredError"> | boolean
    resolvedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    resolvedBy?: StringNullableFilter<"MonitoredError"> | string | null
    notes?: StringNullableFilter<"MonitoredError"> | string | null
    createdAt?: DateTimeFilter<"MonitoredError"> | Date | string
    updatedAt?: DateTimeFilter<"MonitoredError"> | Date | string
    alert?: XOR<ApiAlertRelationFilter, ApiAlertWhereInput>
  }, "id">

  export type MonitoredErrorOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    errorType?: SortOrder
    errorCode?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    firstOccurrence?: SortOrder
    lastOccurrence?: SortOrder
    occurrenceCount?: SortOrder
    affectedDevices?: SortOrder
    affectedSessions?: SortOrder
    lastTraceId?: SortOrderInput | SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    notificationCount?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonitoredErrorCountOrderByAggregateInput
    _avg?: MonitoredErrorAvgOrderByAggregateInput
    _max?: MonitoredErrorMaxOrderByAggregateInput
    _min?: MonitoredErrorMinOrderByAggregateInput
    _sum?: MonitoredErrorSumOrderByAggregateInput
  }

  export type MonitoredErrorScalarWhereWithAggregatesInput = {
    AND?: MonitoredErrorScalarWhereWithAggregatesInput | MonitoredErrorScalarWhereWithAggregatesInput[]
    OR?: MonitoredErrorScalarWhereWithAggregatesInput[]
    NOT?: MonitoredErrorScalarWhereWithAggregatesInput | MonitoredErrorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonitoredError"> | string
    alertId?: StringWithAggregatesFilter<"MonitoredError"> | string
    projectId?: StringWithAggregatesFilter<"MonitoredError"> | string
    errorType?: StringWithAggregatesFilter<"MonitoredError"> | string
    errorCode?: StringWithAggregatesFilter<"MonitoredError"> | string
    endpoint?: StringWithAggregatesFilter<"MonitoredError"> | string
    method?: StringWithAggregatesFilter<"MonitoredError"> | string
    statusCode?: IntNullableWithAggregatesFilter<"MonitoredError"> | number | null
    requestBody?: StringNullableWithAggregatesFilter<"MonitoredError"> | string | null
    responseBody?: StringNullableWithAggregatesFilter<"MonitoredError"> | string | null
    firstOccurrence?: DateTimeWithAggregatesFilter<"MonitoredError"> | Date | string
    lastOccurrence?: DateTimeWithAggregatesFilter<"MonitoredError"> | Date | string
    occurrenceCount?: IntWithAggregatesFilter<"MonitoredError"> | number
    affectedDevices?: StringNullableListFilter<"MonitoredError">
    affectedSessions?: StringNullableListFilter<"MonitoredError">
    lastTraceId?: StringNullableWithAggregatesFilter<"MonitoredError"> | string | null
    lastNotifiedAt?: DateTimeNullableWithAggregatesFilter<"MonitoredError"> | Date | string | null
    notificationCount?: IntWithAggregatesFilter<"MonitoredError"> | number
    isResolved?: BoolWithAggregatesFilter<"MonitoredError"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"MonitoredError"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"MonitoredError"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MonitoredError"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MonitoredError"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MonitoredError"> | Date | string
  }

  export type BusinessConfigWhereInput = {
    AND?: BusinessConfigWhereInput | BusinessConfigWhereInput[]
    OR?: BusinessConfigWhereInput[]
    NOT?: BusinessConfigWhereInput | BusinessConfigWhereInput[]
    id?: StringFilter<"BusinessConfig"> | string
    projectId?: StringFilter<"BusinessConfig"> | string
    key?: StringFilter<"BusinessConfig"> | string
    label?: StringNullableFilter<"BusinessConfig"> | string | null
    description?: StringNullableFilter<"BusinessConfig"> | string | null
    valueType?: StringFilter<"BusinessConfig"> | string
    stringValue?: StringNullableFilter<"BusinessConfig"> | string | null
    integerValue?: IntNullableFilter<"BusinessConfig"> | number | null
    booleanValue?: BoolNullableFilter<"BusinessConfig"> | boolean | null
    decimalValue?: FloatNullableFilter<"BusinessConfig"> | number | null
    jsonValue?: JsonNullableFilter<"BusinessConfig">
    imageUrl?: StringNullableFilter<"BusinessConfig"> | string | null
    category?: StringNullableFilter<"BusinessConfig"> | string | null
    isEnabled?: BoolFilter<"BusinessConfig"> | boolean
    version?: IntFilter<"BusinessConfig"> | number
    metadata?: JsonNullableFilter<"BusinessConfig">
    createdAt?: DateTimeFilter<"BusinessConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessConfig"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    alerts?: ConfigAlertListRelationFilter
    approvals?: ConfigApprovalListRelationFilter
  }

  export type BusinessConfigOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    label?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    valueType?: SortOrder
    stringValue?: SortOrderInput | SortOrder
    integerValue?: SortOrderInput | SortOrder
    booleanValue?: SortOrderInput | SortOrder
    decimalValue?: SortOrderInput | SortOrder
    jsonValue?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    alerts?: ConfigAlertOrderByRelationAggregateInput
    approvals?: ConfigApprovalOrderByRelationAggregateInput
  }

  export type BusinessConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_key?: BusinessConfigProjectIdKeyCompoundUniqueInput
    AND?: BusinessConfigWhereInput | BusinessConfigWhereInput[]
    OR?: BusinessConfigWhereInput[]
    NOT?: BusinessConfigWhereInput | BusinessConfigWhereInput[]
    projectId?: StringFilter<"BusinessConfig"> | string
    key?: StringFilter<"BusinessConfig"> | string
    label?: StringNullableFilter<"BusinessConfig"> | string | null
    description?: StringNullableFilter<"BusinessConfig"> | string | null
    valueType?: StringFilter<"BusinessConfig"> | string
    stringValue?: StringNullableFilter<"BusinessConfig"> | string | null
    integerValue?: IntNullableFilter<"BusinessConfig"> | number | null
    booleanValue?: BoolNullableFilter<"BusinessConfig"> | boolean | null
    decimalValue?: FloatNullableFilter<"BusinessConfig"> | number | null
    jsonValue?: JsonNullableFilter<"BusinessConfig">
    imageUrl?: StringNullableFilter<"BusinessConfig"> | string | null
    category?: StringNullableFilter<"BusinessConfig"> | string | null
    isEnabled?: BoolFilter<"BusinessConfig"> | boolean
    version?: IntFilter<"BusinessConfig"> | number
    metadata?: JsonNullableFilter<"BusinessConfig">
    createdAt?: DateTimeFilter<"BusinessConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessConfig"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    alerts?: ConfigAlertListRelationFilter
    approvals?: ConfigApprovalListRelationFilter
  }, "id" | "projectId_key">

  export type BusinessConfigOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    label?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    valueType?: SortOrder
    stringValue?: SortOrderInput | SortOrder
    integerValue?: SortOrderInput | SortOrder
    booleanValue?: SortOrderInput | SortOrder
    decimalValue?: SortOrderInput | SortOrder
    jsonValue?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    version?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessConfigCountOrderByAggregateInput
    _avg?: BusinessConfigAvgOrderByAggregateInput
    _max?: BusinessConfigMaxOrderByAggregateInput
    _min?: BusinessConfigMinOrderByAggregateInput
    _sum?: BusinessConfigSumOrderByAggregateInput
  }

  export type BusinessConfigScalarWhereWithAggregatesInput = {
    AND?: BusinessConfigScalarWhereWithAggregatesInput | BusinessConfigScalarWhereWithAggregatesInput[]
    OR?: BusinessConfigScalarWhereWithAggregatesInput[]
    NOT?: BusinessConfigScalarWhereWithAggregatesInput | BusinessConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessConfig"> | string
    projectId?: StringWithAggregatesFilter<"BusinessConfig"> | string
    key?: StringWithAggregatesFilter<"BusinessConfig"> | string
    label?: StringNullableWithAggregatesFilter<"BusinessConfig"> | string | null
    description?: StringNullableWithAggregatesFilter<"BusinessConfig"> | string | null
    valueType?: StringWithAggregatesFilter<"BusinessConfig"> | string
    stringValue?: StringNullableWithAggregatesFilter<"BusinessConfig"> | string | null
    integerValue?: IntNullableWithAggregatesFilter<"BusinessConfig"> | number | null
    booleanValue?: BoolNullableWithAggregatesFilter<"BusinessConfig"> | boolean | null
    decimalValue?: FloatNullableWithAggregatesFilter<"BusinessConfig"> | number | null
    jsonValue?: JsonNullableWithAggregatesFilter<"BusinessConfig">
    imageUrl?: StringNullableWithAggregatesFilter<"BusinessConfig"> | string | null
    category?: StringNullableWithAggregatesFilter<"BusinessConfig"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"BusinessConfig"> | boolean
    version?: IntWithAggregatesFilter<"BusinessConfig"> | number
    metadata?: JsonNullableWithAggregatesFilter<"BusinessConfig">
    createdAt?: DateTimeWithAggregatesFilter<"BusinessConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessConfig"> | Date | string
  }

  export type UploadedFileWhereInput = {
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    id?: StringFilter<"UploadedFile"> | string
    projectId?: StringFilter<"UploadedFile"> | string
    filename?: StringFilter<"UploadedFile"> | string
    storedName?: StringFilter<"UploadedFile"> | string
    mimeType?: StringFilter<"UploadedFile"> | string
    size?: IntFilter<"UploadedFile"> | number
    url?: StringFilter<"UploadedFile"> | string
    uploadedBy?: StringNullableFilter<"UploadedFile"> | string | null
    createdAt?: DateTimeFilter<"UploadedFile"> | Date | string
  }

  export type UploadedFileOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    storedName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UploadedFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UploadedFileWhereInput | UploadedFileWhereInput[]
    OR?: UploadedFileWhereInput[]
    NOT?: UploadedFileWhereInput | UploadedFileWhereInput[]
    projectId?: StringFilter<"UploadedFile"> | string
    filename?: StringFilter<"UploadedFile"> | string
    storedName?: StringFilter<"UploadedFile"> | string
    mimeType?: StringFilter<"UploadedFile"> | string
    size?: IntFilter<"UploadedFile"> | number
    url?: StringFilter<"UploadedFile"> | string
    uploadedBy?: StringNullableFilter<"UploadedFile"> | string | null
    createdAt?: DateTimeFilter<"UploadedFile"> | Date | string
  }, "id">

  export type UploadedFileOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    storedName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UploadedFileCountOrderByAggregateInput
    _avg?: UploadedFileAvgOrderByAggregateInput
    _max?: UploadedFileMaxOrderByAggregateInput
    _min?: UploadedFileMinOrderByAggregateInput
    _sum?: UploadedFileSumOrderByAggregateInput
  }

  export type UploadedFileScalarWhereWithAggregatesInput = {
    AND?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    OR?: UploadedFileScalarWhereWithAggregatesInput[]
    NOT?: UploadedFileScalarWhereWithAggregatesInput | UploadedFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UploadedFile"> | string
    projectId?: StringWithAggregatesFilter<"UploadedFile"> | string
    filename?: StringWithAggregatesFilter<"UploadedFile"> | string
    storedName?: StringWithAggregatesFilter<"UploadedFile"> | string
    mimeType?: StringWithAggregatesFilter<"UploadedFile"> | string
    size?: IntWithAggregatesFilter<"UploadedFile"> | number
    url?: StringWithAggregatesFilter<"UploadedFile"> | string
    uploadedBy?: StringNullableWithAggregatesFilter<"UploadedFile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UploadedFile"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    projectId?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringNullableFilter<"Language"> | string | null
    isDefault?: BoolFilter<"Language"> | boolean
    isEnabled?: BoolFilter<"Language"> | boolean
    isRTL?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    translations?: TranslationListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    isRTL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    translations?: TranslationOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_code?: LanguageProjectIdCodeCompoundUniqueInput
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    projectId?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringNullableFilter<"Language"> | string | null
    isDefault?: BoolFilter<"Language"> | boolean
    isEnabled?: BoolFilter<"Language"> | boolean
    isRTL?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    translations?: TranslationListRelationFilter
  }, "id" | "projectId_code">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    isRTL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    projectId?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    nativeName?: StringNullableWithAggregatesFilter<"Language"> | string | null
    isDefault?: BoolWithAggregatesFilter<"Language"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"Language"> | boolean
    isRTL?: BoolWithAggregatesFilter<"Language"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type LocalizationKeyWhereInput = {
    AND?: LocalizationKeyWhereInput | LocalizationKeyWhereInput[]
    OR?: LocalizationKeyWhereInput[]
    NOT?: LocalizationKeyWhereInput | LocalizationKeyWhereInput[]
    id?: StringFilter<"LocalizationKey"> | string
    projectId?: StringFilter<"LocalizationKey"> | string
    key?: StringFilter<"LocalizationKey"> | string
    description?: StringNullableFilter<"LocalizationKey"> | string | null
    category?: StringNullableFilter<"LocalizationKey"> | string | null
    platform?: StringNullableFilter<"LocalizationKey"> | string | null
    maxLength?: IntNullableFilter<"LocalizationKey"> | number | null
    screenshot?: StringNullableFilter<"LocalizationKey"> | string | null
    createdAt?: DateTimeFilter<"LocalizationKey"> | Date | string
    updatedAt?: DateTimeFilter<"LocalizationKey"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    translations?: TranslationListRelationFilter
  }

  export type LocalizationKeyOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    maxLength?: SortOrderInput | SortOrder
    screenshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    translations?: TranslationOrderByRelationAggregateInput
  }

  export type LocalizationKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_key?: LocalizationKeyProjectIdKeyCompoundUniqueInput
    AND?: LocalizationKeyWhereInput | LocalizationKeyWhereInput[]
    OR?: LocalizationKeyWhereInput[]
    NOT?: LocalizationKeyWhereInput | LocalizationKeyWhereInput[]
    projectId?: StringFilter<"LocalizationKey"> | string
    key?: StringFilter<"LocalizationKey"> | string
    description?: StringNullableFilter<"LocalizationKey"> | string | null
    category?: StringNullableFilter<"LocalizationKey"> | string | null
    platform?: StringNullableFilter<"LocalizationKey"> | string | null
    maxLength?: IntNullableFilter<"LocalizationKey"> | number | null
    screenshot?: StringNullableFilter<"LocalizationKey"> | string | null
    createdAt?: DateTimeFilter<"LocalizationKey"> | Date | string
    updatedAt?: DateTimeFilter<"LocalizationKey"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    translations?: TranslationListRelationFilter
  }, "id" | "projectId_key">

  export type LocalizationKeyOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    maxLength?: SortOrderInput | SortOrder
    screenshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocalizationKeyCountOrderByAggregateInput
    _avg?: LocalizationKeyAvgOrderByAggregateInput
    _max?: LocalizationKeyMaxOrderByAggregateInput
    _min?: LocalizationKeyMinOrderByAggregateInput
    _sum?: LocalizationKeySumOrderByAggregateInput
  }

  export type LocalizationKeyScalarWhereWithAggregatesInput = {
    AND?: LocalizationKeyScalarWhereWithAggregatesInput | LocalizationKeyScalarWhereWithAggregatesInput[]
    OR?: LocalizationKeyScalarWhereWithAggregatesInput[]
    NOT?: LocalizationKeyScalarWhereWithAggregatesInput | LocalizationKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocalizationKey"> | string
    projectId?: StringWithAggregatesFilter<"LocalizationKey"> | string
    key?: StringWithAggregatesFilter<"LocalizationKey"> | string
    description?: StringNullableWithAggregatesFilter<"LocalizationKey"> | string | null
    category?: StringNullableWithAggregatesFilter<"LocalizationKey"> | string | null
    platform?: StringNullableWithAggregatesFilter<"LocalizationKey"> | string | null
    maxLength?: IntNullableWithAggregatesFilter<"LocalizationKey"> | number | null
    screenshot?: StringNullableWithAggregatesFilter<"LocalizationKey"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocalizationKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocalizationKey"> | Date | string
  }

  export type TranslationWhereInput = {
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    id?: StringFilter<"Translation"> | string
    projectId?: StringFilter<"Translation"> | string
    keyId?: StringFilter<"Translation"> | string
    languageId?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    isReviewed?: BoolFilter<"Translation"> | boolean
    reviewedBy?: StringNullableFilter<"Translation"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    key?: XOR<LocalizationKeyRelationFilter, LocalizationKeyWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }

  export type TranslationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    keyId?: SortOrder
    languageId?: SortOrder
    value?: SortOrder
    isReviewed?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: LocalizationKeyOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type TranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyId_languageId?: TranslationKeyIdLanguageIdCompoundUniqueInput
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    projectId?: StringFilter<"Translation"> | string
    keyId?: StringFilter<"Translation"> | string
    languageId?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    isReviewed?: BoolFilter<"Translation"> | boolean
    reviewedBy?: StringNullableFilter<"Translation"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    key?: XOR<LocalizationKeyRelationFilter, LocalizationKeyWhereInput>
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }, "id" | "keyId_languageId">

  export type TranslationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    keyId?: SortOrder
    languageId?: SortOrder
    value?: SortOrder
    isReviewed?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TranslationCountOrderByAggregateInput
    _max?: TranslationMaxOrderByAggregateInput
    _min?: TranslationMinOrderByAggregateInput
  }

  export type TranslationScalarWhereWithAggregatesInput = {
    AND?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    OR?: TranslationScalarWhereWithAggregatesInput[]
    NOT?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Translation"> | string
    projectId?: StringWithAggregatesFilter<"Translation"> | string
    keyId?: StringWithAggregatesFilter<"Translation"> | string
    languageId?: StringWithAggregatesFilter<"Translation"> | string
    value?: StringWithAggregatesFilter<"Translation"> | string
    isReviewed?: BoolWithAggregatesFilter<"Translation"> | boolean
    reviewedBy?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Translation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
  }

  export type FeatureFlagsWhereInput = {
    AND?: FeatureFlagsWhereInput | FeatureFlagsWhereInput[]
    OR?: FeatureFlagsWhereInput[]
    NOT?: FeatureFlagsWhereInput | FeatureFlagsWhereInput[]
    id?: StringFilter<"FeatureFlags"> | string
    projectId?: StringFilter<"FeatureFlags"> | string
    sdkEnabled?: BoolFilter<"FeatureFlags"> | boolean
    apiTracking?: BoolFilter<"FeatureFlags"> | boolean
    screenTracking?: BoolFilter<"FeatureFlags"> | boolean
    crashReporting?: BoolFilter<"FeatureFlags"> | boolean
    logging?: BoolFilter<"FeatureFlags"> | boolean
    deviceTracking?: BoolFilter<"FeatureFlags"> | boolean
    sessionTracking?: BoolFilter<"FeatureFlags"> | boolean
    businessConfig?: BoolFilter<"FeatureFlags"> | boolean
    localization?: BoolFilter<"FeatureFlags"> | boolean
    offlineSupport?: BoolFilter<"FeatureFlags"> | boolean
    batchEvents?: BoolFilter<"FeatureFlags"> | boolean
    createdAt?: DateTimeFilter<"FeatureFlags"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlags"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type FeatureFlagsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sdkEnabled?: SortOrder
    apiTracking?: SortOrder
    screenTracking?: SortOrder
    crashReporting?: SortOrder
    logging?: SortOrder
    deviceTracking?: SortOrder
    sessionTracking?: SortOrder
    businessConfig?: SortOrder
    localization?: SortOrder
    offlineSupport?: SortOrder
    batchEvents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type FeatureFlagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: FeatureFlagsWhereInput | FeatureFlagsWhereInput[]
    OR?: FeatureFlagsWhereInput[]
    NOT?: FeatureFlagsWhereInput | FeatureFlagsWhereInput[]
    sdkEnabled?: BoolFilter<"FeatureFlags"> | boolean
    apiTracking?: BoolFilter<"FeatureFlags"> | boolean
    screenTracking?: BoolFilter<"FeatureFlags"> | boolean
    crashReporting?: BoolFilter<"FeatureFlags"> | boolean
    logging?: BoolFilter<"FeatureFlags"> | boolean
    deviceTracking?: BoolFilter<"FeatureFlags"> | boolean
    sessionTracking?: BoolFilter<"FeatureFlags"> | boolean
    businessConfig?: BoolFilter<"FeatureFlags"> | boolean
    localization?: BoolFilter<"FeatureFlags"> | boolean
    offlineSupport?: BoolFilter<"FeatureFlags"> | boolean
    batchEvents?: BoolFilter<"FeatureFlags"> | boolean
    createdAt?: DateTimeFilter<"FeatureFlags"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlags"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type FeatureFlagsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sdkEnabled?: SortOrder
    apiTracking?: SortOrder
    screenTracking?: SortOrder
    crashReporting?: SortOrder
    logging?: SortOrder
    deviceTracking?: SortOrder
    sessionTracking?: SortOrder
    businessConfig?: SortOrder
    localization?: SortOrder
    offlineSupport?: SortOrder
    batchEvents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureFlagsCountOrderByAggregateInput
    _max?: FeatureFlagsMaxOrderByAggregateInput
    _min?: FeatureFlagsMinOrderByAggregateInput
  }

  export type FeatureFlagsScalarWhereWithAggregatesInput = {
    AND?: FeatureFlagsScalarWhereWithAggregatesInput | FeatureFlagsScalarWhereWithAggregatesInput[]
    OR?: FeatureFlagsScalarWhereWithAggregatesInput[]
    NOT?: FeatureFlagsScalarWhereWithAggregatesInput | FeatureFlagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeatureFlags"> | string
    projectId?: StringWithAggregatesFilter<"FeatureFlags"> | string
    sdkEnabled?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    apiTracking?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    screenTracking?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    crashReporting?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    logging?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    deviceTracking?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    sessionTracking?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    businessConfig?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    localization?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    offlineSupport?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    batchEvents?: BoolWithAggregatesFilter<"FeatureFlags"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeatureFlags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureFlags"> | Date | string
  }

  export type SdkSettingsWhereInput = {
    AND?: SdkSettingsWhereInput | SdkSettingsWhereInput[]
    OR?: SdkSettingsWhereInput[]
    NOT?: SdkSettingsWhereInput | SdkSettingsWhereInput[]
    id?: StringFilter<"SdkSettings"> | string
    projectId?: StringFilter<"SdkSettings"> | string
    trackingMode?: StringFilter<"SdkSettings"> | string
    captureRequestBodies?: BoolFilter<"SdkSettings"> | boolean
    captureResponseBodies?: BoolFilter<"SdkSettings"> | boolean
    capturePrintStatements?: BoolFilter<"SdkSettings"> | boolean
    sanitizeSensitiveData?: BoolFilter<"SdkSettings"> | boolean
    sensitiveFieldPatterns?: StringNullableListFilter<"SdkSettings">
    maxLogQueueSize?: IntFilter<"SdkSettings"> | number
    maxTraceQueueSize?: IntFilter<"SdkSettings"> | number
    flushIntervalSeconds?: IntFilter<"SdkSettings"> | number
    enableBatching?: BoolFilter<"SdkSettings"> | boolean
    minLogLevel?: StringFilter<"SdkSettings"> | string
    verboseErrors?: BoolFilter<"SdkSettings"> | boolean
    createdAt?: DateTimeFilter<"SdkSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SdkSettings"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type SdkSettingsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    trackingMode?: SortOrder
    captureRequestBodies?: SortOrder
    captureResponseBodies?: SortOrder
    capturePrintStatements?: SortOrder
    sanitizeSensitiveData?: SortOrder
    sensitiveFieldPatterns?: SortOrder
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
    enableBatching?: SortOrder
    minLogLevel?: SortOrder
    verboseErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type SdkSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: SdkSettingsWhereInput | SdkSettingsWhereInput[]
    OR?: SdkSettingsWhereInput[]
    NOT?: SdkSettingsWhereInput | SdkSettingsWhereInput[]
    trackingMode?: StringFilter<"SdkSettings"> | string
    captureRequestBodies?: BoolFilter<"SdkSettings"> | boolean
    captureResponseBodies?: BoolFilter<"SdkSettings"> | boolean
    capturePrintStatements?: BoolFilter<"SdkSettings"> | boolean
    sanitizeSensitiveData?: BoolFilter<"SdkSettings"> | boolean
    sensitiveFieldPatterns?: StringNullableListFilter<"SdkSettings">
    maxLogQueueSize?: IntFilter<"SdkSettings"> | number
    maxTraceQueueSize?: IntFilter<"SdkSettings"> | number
    flushIntervalSeconds?: IntFilter<"SdkSettings"> | number
    enableBatching?: BoolFilter<"SdkSettings"> | boolean
    minLogLevel?: StringFilter<"SdkSettings"> | string
    verboseErrors?: BoolFilter<"SdkSettings"> | boolean
    createdAt?: DateTimeFilter<"SdkSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SdkSettings"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type SdkSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    trackingMode?: SortOrder
    captureRequestBodies?: SortOrder
    captureResponseBodies?: SortOrder
    capturePrintStatements?: SortOrder
    sanitizeSensitiveData?: SortOrder
    sensitiveFieldPatterns?: SortOrder
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
    enableBatching?: SortOrder
    minLogLevel?: SortOrder
    verboseErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SdkSettingsCountOrderByAggregateInput
    _avg?: SdkSettingsAvgOrderByAggregateInput
    _max?: SdkSettingsMaxOrderByAggregateInput
    _min?: SdkSettingsMinOrderByAggregateInput
    _sum?: SdkSettingsSumOrderByAggregateInput
  }

  export type SdkSettingsScalarWhereWithAggregatesInput = {
    AND?: SdkSettingsScalarWhereWithAggregatesInput | SdkSettingsScalarWhereWithAggregatesInput[]
    OR?: SdkSettingsScalarWhereWithAggregatesInput[]
    NOT?: SdkSettingsScalarWhereWithAggregatesInput | SdkSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SdkSettings"> | string
    projectId?: StringWithAggregatesFilter<"SdkSettings"> | string
    trackingMode?: StringWithAggregatesFilter<"SdkSettings"> | string
    captureRequestBodies?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    captureResponseBodies?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    capturePrintStatements?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    sanitizeSensitiveData?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    sensitiveFieldPatterns?: StringNullableListFilter<"SdkSettings">
    maxLogQueueSize?: IntWithAggregatesFilter<"SdkSettings"> | number
    maxTraceQueueSize?: IntWithAggregatesFilter<"SdkSettings"> | number
    flushIntervalSeconds?: IntWithAggregatesFilter<"SdkSettings"> | number
    enableBatching?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    minLogLevel?: StringWithAggregatesFilter<"SdkSettings"> | string
    verboseErrors?: BoolWithAggregatesFilter<"SdkSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SdkSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SdkSettings"> | Date | string
  }

  export type ConfigCategoryWhereInput = {
    AND?: ConfigCategoryWhereInput | ConfigCategoryWhereInput[]
    OR?: ConfigCategoryWhereInput[]
    NOT?: ConfigCategoryWhereInput | ConfigCategoryWhereInput[]
    id?: StringFilter<"ConfigCategory"> | string
    projectId?: StringFilter<"ConfigCategory"> | string
    name?: StringFilter<"ConfigCategory"> | string
    label?: StringNullableFilter<"ConfigCategory"> | string | null
    description?: StringNullableFilter<"ConfigCategory"> | string | null
    icon?: StringNullableFilter<"ConfigCategory"> | string | null
    order?: IntFilter<"ConfigCategory"> | number
    isEnabled?: BoolFilter<"ConfigCategory"> | boolean
    createdAt?: DateTimeFilter<"ConfigCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigCategory"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ConfigCategoryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ConfigCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: ConfigCategoryProjectIdNameCompoundUniqueInput
    AND?: ConfigCategoryWhereInput | ConfigCategoryWhereInput[]
    OR?: ConfigCategoryWhereInput[]
    NOT?: ConfigCategoryWhereInput | ConfigCategoryWhereInput[]
    projectId?: StringFilter<"ConfigCategory"> | string
    name?: StringFilter<"ConfigCategory"> | string
    label?: StringNullableFilter<"ConfigCategory"> | string | null
    description?: StringNullableFilter<"ConfigCategory"> | string | null
    icon?: StringNullableFilter<"ConfigCategory"> | string | null
    order?: IntFilter<"ConfigCategory"> | number
    isEnabled?: BoolFilter<"ConfigCategory"> | boolean
    createdAt?: DateTimeFilter<"ConfigCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigCategory"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_name">

  export type ConfigCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigCategoryCountOrderByAggregateInput
    _avg?: ConfigCategoryAvgOrderByAggregateInput
    _max?: ConfigCategoryMaxOrderByAggregateInput
    _min?: ConfigCategoryMinOrderByAggregateInput
    _sum?: ConfigCategorySumOrderByAggregateInput
  }

  export type ConfigCategoryScalarWhereWithAggregatesInput = {
    AND?: ConfigCategoryScalarWhereWithAggregatesInput | ConfigCategoryScalarWhereWithAggregatesInput[]
    OR?: ConfigCategoryScalarWhereWithAggregatesInput[]
    NOT?: ConfigCategoryScalarWhereWithAggregatesInput | ConfigCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigCategory"> | string
    projectId?: StringWithAggregatesFilter<"ConfigCategory"> | string
    name?: StringWithAggregatesFilter<"ConfigCategory"> | string
    label?: StringNullableWithAggregatesFilter<"ConfigCategory"> | string | null
    description?: StringNullableWithAggregatesFilter<"ConfigCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ConfigCategory"> | string | null
    order?: IntWithAggregatesFilter<"ConfigCategory"> | number
    isEnabled?: BoolWithAggregatesFilter<"ConfigCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ConfigCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfigCategory"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    displayName?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: FloatFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: StringFilter<"Plan"> | string
    isActive?: BoolFilter<"Plan"> | boolean
    isPublic?: BoolFilter<"Plan"> | boolean
    maxProjects?: IntNullableFilter<"Plan"> | number | null
    maxDevices?: IntNullableFilter<"Plan"> | number | null
    maxMockEndpoints?: IntNullableFilter<"Plan"> | number | null
    maxApiEndpoints?: IntNullableFilter<"Plan"> | number | null
    maxApiRequests?: IntNullableFilter<"Plan"> | number | null
    maxLogs?: IntNullableFilter<"Plan"> | number | null
    maxSessions?: IntNullableFilter<"Plan"> | number | null
    maxCrashes?: IntNullableFilter<"Plan"> | number | null
    maxBusinessConfigKeys?: IntNullableFilter<"Plan"> | number | null
    maxLocalizationLanguages?: IntNullableFilter<"Plan"> | number | null
    maxLocalizationKeys?: IntNullableFilter<"Plan"> | number | null
    retentionDays?: IntNullableFilter<"Plan"> | number | null
    allowApiTracking?: BoolFilter<"Plan"> | boolean
    allowScreenTracking?: BoolFilter<"Plan"> | boolean
    allowCrashReporting?: BoolFilter<"Plan"> | boolean
    allowLogging?: BoolFilter<"Plan"> | boolean
    allowBusinessConfig?: BoolFilter<"Plan"> | boolean
    allowLocalization?: BoolFilter<"Plan"> | boolean
    allowCustomDomains?: BoolFilter<"Plan"> | boolean
    allowWebhooks?: BoolFilter<"Plan"> | boolean
    allowTeamMembers?: BoolFilter<"Plan"> | boolean
    allowPrioritySupport?: BoolFilter<"Plan"> | boolean
    features?: JsonNullableFilter<"Plan">
    enforcementConfig?: JsonNullableFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    maxProjects?: SortOrderInput | SortOrder
    maxDevices?: SortOrderInput | SortOrder
    maxMockEndpoints?: SortOrderInput | SortOrder
    maxApiEndpoints?: SortOrderInput | SortOrder
    maxApiRequests?: SortOrderInput | SortOrder
    maxLogs?: SortOrderInput | SortOrder
    maxSessions?: SortOrderInput | SortOrder
    maxCrashes?: SortOrderInput | SortOrder
    maxBusinessConfigKeys?: SortOrderInput | SortOrder
    maxLocalizationLanguages?: SortOrderInput | SortOrder
    maxLocalizationKeys?: SortOrderInput | SortOrder
    retentionDays?: SortOrderInput | SortOrder
    allowApiTracking?: SortOrder
    allowScreenTracking?: SortOrder
    allowCrashReporting?: SortOrder
    allowLogging?: SortOrder
    allowBusinessConfig?: SortOrder
    allowLocalization?: SortOrder
    allowCustomDomains?: SortOrder
    allowWebhooks?: SortOrder
    allowTeamMembers?: SortOrder
    allowPrioritySupport?: SortOrder
    features?: SortOrderInput | SortOrder
    enforcementConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    displayName?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: FloatFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: StringFilter<"Plan"> | string
    isActive?: BoolFilter<"Plan"> | boolean
    isPublic?: BoolFilter<"Plan"> | boolean
    maxProjects?: IntNullableFilter<"Plan"> | number | null
    maxDevices?: IntNullableFilter<"Plan"> | number | null
    maxMockEndpoints?: IntNullableFilter<"Plan"> | number | null
    maxApiEndpoints?: IntNullableFilter<"Plan"> | number | null
    maxApiRequests?: IntNullableFilter<"Plan"> | number | null
    maxLogs?: IntNullableFilter<"Plan"> | number | null
    maxSessions?: IntNullableFilter<"Plan"> | number | null
    maxCrashes?: IntNullableFilter<"Plan"> | number | null
    maxBusinessConfigKeys?: IntNullableFilter<"Plan"> | number | null
    maxLocalizationLanguages?: IntNullableFilter<"Plan"> | number | null
    maxLocalizationKeys?: IntNullableFilter<"Plan"> | number | null
    retentionDays?: IntNullableFilter<"Plan"> | number | null
    allowApiTracking?: BoolFilter<"Plan"> | boolean
    allowScreenTracking?: BoolFilter<"Plan"> | boolean
    allowCrashReporting?: BoolFilter<"Plan"> | boolean
    allowLogging?: BoolFilter<"Plan"> | boolean
    allowBusinessConfig?: BoolFilter<"Plan"> | boolean
    allowLocalization?: BoolFilter<"Plan"> | boolean
    allowCustomDomains?: BoolFilter<"Plan"> | boolean
    allowWebhooks?: BoolFilter<"Plan"> | boolean
    allowTeamMembers?: BoolFilter<"Plan"> | boolean
    allowPrioritySupport?: BoolFilter<"Plan"> | boolean
    features?: JsonNullableFilter<"Plan">
    enforcementConfig?: JsonNullableFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "name">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    maxProjects?: SortOrderInput | SortOrder
    maxDevices?: SortOrderInput | SortOrder
    maxMockEndpoints?: SortOrderInput | SortOrder
    maxApiEndpoints?: SortOrderInput | SortOrder
    maxApiRequests?: SortOrderInput | SortOrder
    maxLogs?: SortOrderInput | SortOrder
    maxSessions?: SortOrderInput | SortOrder
    maxCrashes?: SortOrderInput | SortOrder
    maxBusinessConfigKeys?: SortOrderInput | SortOrder
    maxLocalizationLanguages?: SortOrderInput | SortOrder
    maxLocalizationKeys?: SortOrderInput | SortOrder
    retentionDays?: SortOrderInput | SortOrder
    allowApiTracking?: SortOrder
    allowScreenTracking?: SortOrder
    allowCrashReporting?: SortOrder
    allowLogging?: SortOrder
    allowBusinessConfig?: SortOrder
    allowLocalization?: SortOrder
    allowCustomDomains?: SortOrder
    allowWebhooks?: SortOrder
    allowTeamMembers?: SortOrder
    allowPrioritySupport?: SortOrder
    features?: SortOrderInput | SortOrder
    enforcementConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    displayName?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    price?: FloatWithAggregatesFilter<"Plan"> | number
    currency?: StringWithAggregatesFilter<"Plan"> | string
    interval?: StringWithAggregatesFilter<"Plan"> | string
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Plan"> | boolean
    maxProjects?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxDevices?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxMockEndpoints?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxApiEndpoints?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxApiRequests?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxLogs?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxSessions?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxCrashes?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxBusinessConfigKeys?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxLocalizationLanguages?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    maxLocalizationKeys?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    retentionDays?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    allowApiTracking?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowScreenTracking?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowCrashReporting?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowLogging?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowBusinessConfig?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowLocalization?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowCustomDomains?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowWebhooks?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowTeamMembers?: BoolWithAggregatesFilter<"Plan"> | boolean
    allowPrioritySupport?: BoolWithAggregatesFilter<"Plan"> | boolean
    features?: JsonNullableWithAggregatesFilter<"Plan">
    enforcementConfig?: JsonNullableWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    enabled?: BoolFilter<"Subscription"> | boolean
    trialStartDate?: DateTimeFilter<"Subscription"> | Date | string
    trialEndDate?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Subscription"> | string | null
    disabledBy?: StringNullableFilter<"Subscription"> | string | null
    disabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    enabledBy?: StringNullableFilter<"Subscription"> | string | null
    enabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    quotaMaxProjects?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxDevices?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxMockEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiRequests?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLogs?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxSessions?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxCrashes?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxBusinessConfigKeys?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationLanguages?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationKeys?: IntNullableFilter<"Subscription"> | number | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    invoices?: InvoiceListRelationFilter
    enforcementState?: XOR<EnforcementStateNullableRelationFilter, EnforcementStateWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    trialStartDate?: SortOrder
    trialEndDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledReason?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    disabledAt?: SortOrderInput | SortOrder
    enabledBy?: SortOrderInput | SortOrder
    enabledAt?: SortOrderInput | SortOrder
    quotaMaxProjects?: SortOrderInput | SortOrder
    quotaMaxDevices?: SortOrderInput | SortOrder
    quotaMaxMockEndpoints?: SortOrderInput | SortOrder
    quotaMaxApiEndpoints?: SortOrderInput | SortOrder
    quotaMaxApiRequests?: SortOrderInput | SortOrder
    quotaMaxLogs?: SortOrderInput | SortOrder
    quotaMaxSessions?: SortOrderInput | SortOrder
    quotaMaxCrashes?: SortOrderInput | SortOrder
    quotaMaxBusinessConfigKeys?: SortOrderInput | SortOrder
    quotaMaxLocalizationLanguages?: SortOrderInput | SortOrder
    quotaMaxLocalizationKeys?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    enforcementState?: EnforcementStateOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    enabled?: BoolFilter<"Subscription"> | boolean
    trialStartDate?: DateTimeFilter<"Subscription"> | Date | string
    trialEndDate?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Subscription"> | string | null
    disabledBy?: StringNullableFilter<"Subscription"> | string | null
    disabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    enabledBy?: StringNullableFilter<"Subscription"> | string | null
    enabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    quotaMaxProjects?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxDevices?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxMockEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiRequests?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLogs?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxSessions?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxCrashes?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxBusinessConfigKeys?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationLanguages?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationKeys?: IntNullableFilter<"Subscription"> | number | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    invoices?: InvoiceListRelationFilter
    enforcementState?: XOR<EnforcementStateNullableRelationFilter, EnforcementStateWhereInput> | null
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    trialStartDate?: SortOrder
    trialEndDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledReason?: SortOrderInput | SortOrder
    disabledBy?: SortOrderInput | SortOrder
    disabledAt?: SortOrderInput | SortOrder
    enabledBy?: SortOrderInput | SortOrder
    enabledAt?: SortOrderInput | SortOrder
    quotaMaxProjects?: SortOrderInput | SortOrder
    quotaMaxDevices?: SortOrderInput | SortOrder
    quotaMaxMockEndpoints?: SortOrderInput | SortOrder
    quotaMaxApiEndpoints?: SortOrderInput | SortOrder
    quotaMaxApiRequests?: SortOrderInput | SortOrder
    quotaMaxLogs?: SortOrderInput | SortOrder
    quotaMaxSessions?: SortOrderInput | SortOrder
    quotaMaxCrashes?: SortOrderInput | SortOrder
    quotaMaxBusinessConfigKeys?: SortOrderInput | SortOrder
    quotaMaxLocalizationLanguages?: SortOrderInput | SortOrder
    quotaMaxLocalizationKeys?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    enabled?: BoolWithAggregatesFilter<"Subscription"> | boolean
    trialStartDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    trialEndDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledReason?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    disabledBy?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    disabledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    enabledBy?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    enabledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    quotaMaxProjects?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxDevices?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxMockEndpoints?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxApiEndpoints?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxApiRequests?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxLogs?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxSessions?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxCrashes?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxBusinessConfigKeys?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxLocalizationLanguages?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    quotaMaxLocalizationKeys?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type EnforcementStateWhereInput = {
    AND?: EnforcementStateWhereInput | EnforcementStateWhereInput[]
    OR?: EnforcementStateWhereInput[]
    NOT?: EnforcementStateWhereInput | EnforcementStateWhereInput[]
    id?: StringFilter<"EnforcementState"> | string
    subscriptionId?: StringFilter<"EnforcementState"> | string
    state?: StringFilter<"EnforcementState"> | string
    warnEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    graceEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    graceEndsAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    degradedEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    effectivePolicy?: JsonNullableFilter<"EnforcementState">
    triggeredMetrics?: JsonNullableFilter<"EnforcementState">
    lastEvaluatedAt?: DateTimeFilter<"EnforcementState"> | Date | string
    nextEvaluationAt?: DateTimeFilter<"EnforcementState"> | Date | string
    createdAt?: DateTimeFilter<"EnforcementState"> | Date | string
    updatedAt?: DateTimeFilter<"EnforcementState"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type EnforcementStateOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    state?: SortOrder
    warnEnteredAt?: SortOrderInput | SortOrder
    graceEnteredAt?: SortOrderInput | SortOrder
    graceEndsAt?: SortOrderInput | SortOrder
    degradedEnteredAt?: SortOrderInput | SortOrder
    effectivePolicy?: SortOrderInput | SortOrder
    triggeredMetrics?: SortOrderInput | SortOrder
    lastEvaluatedAt?: SortOrder
    nextEvaluationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type EnforcementStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId?: string
    AND?: EnforcementStateWhereInput | EnforcementStateWhereInput[]
    OR?: EnforcementStateWhereInput[]
    NOT?: EnforcementStateWhereInput | EnforcementStateWhereInput[]
    state?: StringFilter<"EnforcementState"> | string
    warnEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    graceEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    graceEndsAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    degradedEnteredAt?: DateTimeNullableFilter<"EnforcementState"> | Date | string | null
    effectivePolicy?: JsonNullableFilter<"EnforcementState">
    triggeredMetrics?: JsonNullableFilter<"EnforcementState">
    lastEvaluatedAt?: DateTimeFilter<"EnforcementState"> | Date | string
    nextEvaluationAt?: DateTimeFilter<"EnforcementState"> | Date | string
    createdAt?: DateTimeFilter<"EnforcementState"> | Date | string
    updatedAt?: DateTimeFilter<"EnforcementState"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id" | "subscriptionId">

  export type EnforcementStateOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    state?: SortOrder
    warnEnteredAt?: SortOrderInput | SortOrder
    graceEnteredAt?: SortOrderInput | SortOrder
    graceEndsAt?: SortOrderInput | SortOrder
    degradedEnteredAt?: SortOrderInput | SortOrder
    effectivePolicy?: SortOrderInput | SortOrder
    triggeredMetrics?: SortOrderInput | SortOrder
    lastEvaluatedAt?: SortOrder
    nextEvaluationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnforcementStateCountOrderByAggregateInput
    _max?: EnforcementStateMaxOrderByAggregateInput
    _min?: EnforcementStateMinOrderByAggregateInput
  }

  export type EnforcementStateScalarWhereWithAggregatesInput = {
    AND?: EnforcementStateScalarWhereWithAggregatesInput | EnforcementStateScalarWhereWithAggregatesInput[]
    OR?: EnforcementStateScalarWhereWithAggregatesInput[]
    NOT?: EnforcementStateScalarWhereWithAggregatesInput | EnforcementStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EnforcementState"> | string
    subscriptionId?: StringWithAggregatesFilter<"EnforcementState"> | string
    state?: StringWithAggregatesFilter<"EnforcementState"> | string
    warnEnteredAt?: DateTimeNullableWithAggregatesFilter<"EnforcementState"> | Date | string | null
    graceEnteredAt?: DateTimeNullableWithAggregatesFilter<"EnforcementState"> | Date | string | null
    graceEndsAt?: DateTimeNullableWithAggregatesFilter<"EnforcementState"> | Date | string | null
    degradedEnteredAt?: DateTimeNullableWithAggregatesFilter<"EnforcementState"> | Date | string | null
    effectivePolicy?: JsonNullableWithAggregatesFilter<"EnforcementState">
    triggeredMetrics?: JsonNullableWithAggregatesFilter<"EnforcementState">
    lastEvaluatedAt?: DateTimeWithAggregatesFilter<"EnforcementState"> | Date | string
    nextEvaluationAt?: DateTimeWithAggregatesFilter<"EnforcementState"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EnforcementState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EnforcementState"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    subscriptionId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    lineItems?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    subscriptionId?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    subscription?: XOR<SubscriptionRelationFilter, SubscriptionWhereInput>
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    lineItems?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    subscriptionId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    lineItems?: JsonNullableWithAggregatesFilter<"Invoice">
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type BuildWhereInput = {
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    id?: StringFilter<"Build"> | string
    projectId?: StringFilter<"Build"> | string
    version?: IntFilter<"Build"> | number
    name?: StringNullableFilter<"Build"> | string | null
    description?: StringNullableFilter<"Build"> | string | null
    mode?: StringNullableFilter<"Build"> | string | null
    isActive?: BoolFilter<"Build"> | boolean
    createdBy?: StringNullableFilter<"Build"> | string | null
    createdAt?: DateTimeFilter<"Build"> | Date | string
    businessConfigSnapshot?: JsonNullableFilter<"Build">
    localizationSnapshot?: JsonNullableFilter<"Build">
    configCount?: IntFilter<"Build"> | number
    translationCount?: IntFilter<"Build"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    features?: BuildFeatureListRelationFilter
    changeLogs?: BuildChangeLogListRelationFilter
    previewMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
    productionMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    version?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    businessConfigSnapshot?: SortOrderInput | SortOrder
    localizationSnapshot?: SortOrderInput | SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
    project?: ProjectOrderByWithRelationInput
    features?: BuildFeatureOrderByRelationAggregateInput
    changeLogs?: BuildChangeLogOrderByRelationAggregateInput
    previewMode?: BuildModeOrderByWithRelationInput
    productionMode?: BuildModeOrderByWithRelationInput
  }

  export type BuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_version?: BuildProjectIdVersionCompoundUniqueInput
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    projectId?: StringFilter<"Build"> | string
    version?: IntFilter<"Build"> | number
    name?: StringNullableFilter<"Build"> | string | null
    description?: StringNullableFilter<"Build"> | string | null
    mode?: StringNullableFilter<"Build"> | string | null
    isActive?: BoolFilter<"Build"> | boolean
    createdBy?: StringNullableFilter<"Build"> | string | null
    createdAt?: DateTimeFilter<"Build"> | Date | string
    businessConfigSnapshot?: JsonNullableFilter<"Build">
    localizationSnapshot?: JsonNullableFilter<"Build">
    configCount?: IntFilter<"Build"> | number
    translationCount?: IntFilter<"Build"> | number
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    features?: BuildFeatureListRelationFilter
    changeLogs?: BuildChangeLogListRelationFilter
    previewMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
    productionMode?: XOR<BuildModeNullableRelationFilter, BuildModeWhereInput> | null
  }, "id" | "projectId_version">

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    version?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    businessConfigSnapshot?: SortOrderInput | SortOrder
    localizationSnapshot?: SortOrderInput | SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
    _count?: BuildCountOrderByAggregateInput
    _avg?: BuildAvgOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
    _sum?: BuildSumOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    OR?: BuildScalarWhereWithAggregatesInput[]
    NOT?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Build"> | string
    projectId?: StringWithAggregatesFilter<"Build"> | string
    version?: IntWithAggregatesFilter<"Build"> | number
    name?: StringNullableWithAggregatesFilter<"Build"> | string | null
    description?: StringNullableWithAggregatesFilter<"Build"> | string | null
    mode?: StringNullableWithAggregatesFilter<"Build"> | string | null
    isActive?: BoolWithAggregatesFilter<"Build"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"Build"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Build"> | Date | string
    businessConfigSnapshot?: JsonNullableWithAggregatesFilter<"Build">
    localizationSnapshot?: JsonNullableWithAggregatesFilter<"Build">
    configCount?: IntWithAggregatesFilter<"Build"> | number
    translationCount?: IntWithAggregatesFilter<"Build"> | number
  }

  export type BuildFeatureWhereInput = {
    AND?: BuildFeatureWhereInput | BuildFeatureWhereInput[]
    OR?: BuildFeatureWhereInput[]
    NOT?: BuildFeatureWhereInput | BuildFeatureWhereInput[]
    id?: StringFilter<"BuildFeature"> | string
    buildId?: StringFilter<"BuildFeature"> | string
    featureType?: StringFilter<"BuildFeature"> | string
    snapshotData?: JsonFilter<"BuildFeature">
    itemCount?: IntFilter<"BuildFeature"> | number
    createdAt?: DateTimeFilter<"BuildFeature"> | Date | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type BuildFeatureOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    snapshotData?: SortOrder
    itemCount?: SortOrder
    createdAt?: SortOrder
    build?: BuildOrderByWithRelationInput
  }

  export type BuildFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    buildId_featureType?: BuildFeatureBuildIdFeatureTypeCompoundUniqueInput
    AND?: BuildFeatureWhereInput | BuildFeatureWhereInput[]
    OR?: BuildFeatureWhereInput[]
    NOT?: BuildFeatureWhereInput | BuildFeatureWhereInput[]
    buildId?: StringFilter<"BuildFeature"> | string
    featureType?: StringFilter<"BuildFeature"> | string
    snapshotData?: JsonFilter<"BuildFeature">
    itemCount?: IntFilter<"BuildFeature"> | number
    createdAt?: DateTimeFilter<"BuildFeature"> | Date | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }, "id" | "buildId_featureType">

  export type BuildFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    snapshotData?: SortOrder
    itemCount?: SortOrder
    createdAt?: SortOrder
    _count?: BuildFeatureCountOrderByAggregateInput
    _avg?: BuildFeatureAvgOrderByAggregateInput
    _max?: BuildFeatureMaxOrderByAggregateInput
    _min?: BuildFeatureMinOrderByAggregateInput
    _sum?: BuildFeatureSumOrderByAggregateInput
  }

  export type BuildFeatureScalarWhereWithAggregatesInput = {
    AND?: BuildFeatureScalarWhereWithAggregatesInput | BuildFeatureScalarWhereWithAggregatesInput[]
    OR?: BuildFeatureScalarWhereWithAggregatesInput[]
    NOT?: BuildFeatureScalarWhereWithAggregatesInput | BuildFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuildFeature"> | string
    buildId?: StringWithAggregatesFilter<"BuildFeature"> | string
    featureType?: StringWithAggregatesFilter<"BuildFeature"> | string
    snapshotData?: JsonWithAggregatesFilter<"BuildFeature">
    itemCount?: IntWithAggregatesFilter<"BuildFeature"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuildFeature"> | Date | string
  }

  export type BuildModeWhereInput = {
    AND?: BuildModeWhereInput | BuildModeWhereInput[]
    OR?: BuildModeWhereInput[]
    NOT?: BuildModeWhereInput | BuildModeWhereInput[]
    id?: StringFilter<"BuildMode"> | string
    projectId?: StringFilter<"BuildMode"> | string
    previewBuildId?: StringNullableFilter<"BuildMode"> | string | null
    productionBuildId?: StringNullableFilter<"BuildMode"> | string | null
    updatedAt?: DateTimeFilter<"BuildMode"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    previewBuild?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
    productionBuild?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }

  export type BuildModeOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    previewBuildId?: SortOrderInput | SortOrder
    productionBuildId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    previewBuild?: BuildOrderByWithRelationInput
    productionBuild?: BuildOrderByWithRelationInput
  }

  export type BuildModeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    previewBuildId?: string
    productionBuildId?: string
    AND?: BuildModeWhereInput | BuildModeWhereInput[]
    OR?: BuildModeWhereInput[]
    NOT?: BuildModeWhereInput | BuildModeWhereInput[]
    updatedAt?: DateTimeFilter<"BuildMode"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    previewBuild?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
    productionBuild?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }, "id" | "projectId" | "previewBuildId" | "productionBuildId">

  export type BuildModeOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    previewBuildId?: SortOrderInput | SortOrder
    productionBuildId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: BuildModeCountOrderByAggregateInput
    _max?: BuildModeMaxOrderByAggregateInput
    _min?: BuildModeMinOrderByAggregateInput
  }

  export type BuildModeScalarWhereWithAggregatesInput = {
    AND?: BuildModeScalarWhereWithAggregatesInput | BuildModeScalarWhereWithAggregatesInput[]
    OR?: BuildModeScalarWhereWithAggregatesInput[]
    NOT?: BuildModeScalarWhereWithAggregatesInput | BuildModeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuildMode"> | string
    projectId?: StringWithAggregatesFilter<"BuildMode"> | string
    previewBuildId?: StringNullableWithAggregatesFilter<"BuildMode"> | string | null
    productionBuildId?: StringNullableWithAggregatesFilter<"BuildMode"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"BuildMode"> | Date | string
  }

  export type BuildChangeLogWhereInput = {
    AND?: BuildChangeLogWhereInput | BuildChangeLogWhereInput[]
    OR?: BuildChangeLogWhereInput[]
    NOT?: BuildChangeLogWhereInput | BuildChangeLogWhereInput[]
    id?: StringFilter<"BuildChangeLog"> | string
    buildId?: StringFilter<"BuildChangeLog"> | string
    featureType?: StringFilter<"BuildChangeLog"> | string
    changeType?: StringFilter<"BuildChangeLog"> | string
    itemKey?: StringFilter<"BuildChangeLog"> | string
    itemLabel?: StringNullableFilter<"BuildChangeLog"> | string | null
    oldValue?: JsonNullableFilter<"BuildChangeLog">
    newValue?: JsonNullableFilter<"BuildChangeLog">
    changedBy?: StringNullableFilter<"BuildChangeLog"> | string | null
    changedAt?: DateTimeFilter<"BuildChangeLog"> | Date | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type BuildChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    changeType?: SortOrder
    itemKey?: SortOrder
    itemLabel?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    build?: BuildOrderByWithRelationInput
  }

  export type BuildChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildChangeLogWhereInput | BuildChangeLogWhereInput[]
    OR?: BuildChangeLogWhereInput[]
    NOT?: BuildChangeLogWhereInput | BuildChangeLogWhereInput[]
    buildId?: StringFilter<"BuildChangeLog"> | string
    featureType?: StringFilter<"BuildChangeLog"> | string
    changeType?: StringFilter<"BuildChangeLog"> | string
    itemKey?: StringFilter<"BuildChangeLog"> | string
    itemLabel?: StringNullableFilter<"BuildChangeLog"> | string | null
    oldValue?: JsonNullableFilter<"BuildChangeLog">
    newValue?: JsonNullableFilter<"BuildChangeLog">
    changedBy?: StringNullableFilter<"BuildChangeLog"> | string | null
    changedAt?: DateTimeFilter<"BuildChangeLog"> | Date | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }, "id">

  export type BuildChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    changeType?: SortOrder
    itemKey?: SortOrder
    itemLabel?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: BuildChangeLogCountOrderByAggregateInput
    _max?: BuildChangeLogMaxOrderByAggregateInput
    _min?: BuildChangeLogMinOrderByAggregateInput
  }

  export type BuildChangeLogScalarWhereWithAggregatesInput = {
    AND?: BuildChangeLogScalarWhereWithAggregatesInput | BuildChangeLogScalarWhereWithAggregatesInput[]
    OR?: BuildChangeLogScalarWhereWithAggregatesInput[]
    NOT?: BuildChangeLogScalarWhereWithAggregatesInput | BuildChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuildChangeLog"> | string
    buildId?: StringWithAggregatesFilter<"BuildChangeLog"> | string
    featureType?: StringWithAggregatesFilter<"BuildChangeLog"> | string
    changeType?: StringWithAggregatesFilter<"BuildChangeLog"> | string
    itemKey?: StringWithAggregatesFilter<"BuildChangeLog"> | string
    itemLabel?: StringNullableWithAggregatesFilter<"BuildChangeLog"> | string | null
    oldValue?: JsonNullableWithAggregatesFilter<"BuildChangeLog">
    newValue?: JsonNullableWithAggregatesFilter<"BuildChangeLog">
    changedBy?: StringNullableWithAggregatesFilter<"BuildChangeLog"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"BuildChangeLog"> | Date | string
  }

  export type MockEnvironmentWhereInput = {
    AND?: MockEnvironmentWhereInput | MockEnvironmentWhereInput[]
    OR?: MockEnvironmentWhereInput[]
    NOT?: MockEnvironmentWhereInput | MockEnvironmentWhereInput[]
    id?: StringFilter<"MockEnvironment"> | string
    projectId?: StringFilter<"MockEnvironment"> | string
    name?: StringFilter<"MockEnvironment"> | string
    description?: StringNullableFilter<"MockEnvironment"> | string | null
    basePath?: StringNullableFilter<"MockEnvironment"> | string | null
    mode?: StringFilter<"MockEnvironment"> | string
    whitelist?: StringNullableListFilter<"MockEnvironment">
    blacklist?: StringNullableListFilter<"MockEnvironment">
    isEnabled?: BoolFilter<"MockEnvironment"> | boolean
    isDefault?: BoolFilter<"MockEnvironment"> | boolean
    createdBy?: StringNullableFilter<"MockEnvironment"> | string | null
    createdAt?: DateTimeFilter<"MockEnvironment"> | Date | string
    updatedAt?: DateTimeFilter<"MockEnvironment"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    endpoints?: MockEndpointListRelationFilter
  }

  export type MockEnvironmentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePath?: SortOrderInput | SortOrder
    mode?: SortOrder
    whitelist?: SortOrder
    blacklist?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    endpoints?: MockEndpointOrderByRelationAggregateInput
  }

  export type MockEnvironmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: MockEnvironmentProjectIdNameCompoundUniqueInput
    AND?: MockEnvironmentWhereInput | MockEnvironmentWhereInput[]
    OR?: MockEnvironmentWhereInput[]
    NOT?: MockEnvironmentWhereInput | MockEnvironmentWhereInput[]
    projectId?: StringFilter<"MockEnvironment"> | string
    name?: StringFilter<"MockEnvironment"> | string
    description?: StringNullableFilter<"MockEnvironment"> | string | null
    basePath?: StringNullableFilter<"MockEnvironment"> | string | null
    mode?: StringFilter<"MockEnvironment"> | string
    whitelist?: StringNullableListFilter<"MockEnvironment">
    blacklist?: StringNullableListFilter<"MockEnvironment">
    isEnabled?: BoolFilter<"MockEnvironment"> | boolean
    isDefault?: BoolFilter<"MockEnvironment"> | boolean
    createdBy?: StringNullableFilter<"MockEnvironment"> | string | null
    createdAt?: DateTimeFilter<"MockEnvironment"> | Date | string
    updatedAt?: DateTimeFilter<"MockEnvironment"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    endpoints?: MockEndpointListRelationFilter
  }, "id" | "projectId_name">

  export type MockEnvironmentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePath?: SortOrderInput | SortOrder
    mode?: SortOrder
    whitelist?: SortOrder
    blacklist?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MockEnvironmentCountOrderByAggregateInput
    _max?: MockEnvironmentMaxOrderByAggregateInput
    _min?: MockEnvironmentMinOrderByAggregateInput
  }

  export type MockEnvironmentScalarWhereWithAggregatesInput = {
    AND?: MockEnvironmentScalarWhereWithAggregatesInput | MockEnvironmentScalarWhereWithAggregatesInput[]
    OR?: MockEnvironmentScalarWhereWithAggregatesInput[]
    NOT?: MockEnvironmentScalarWhereWithAggregatesInput | MockEnvironmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockEnvironment"> | string
    projectId?: StringWithAggregatesFilter<"MockEnvironment"> | string
    name?: StringWithAggregatesFilter<"MockEnvironment"> | string
    description?: StringNullableWithAggregatesFilter<"MockEnvironment"> | string | null
    basePath?: StringNullableWithAggregatesFilter<"MockEnvironment"> | string | null
    mode?: StringWithAggregatesFilter<"MockEnvironment"> | string
    whitelist?: StringNullableListFilter<"MockEnvironment">
    blacklist?: StringNullableListFilter<"MockEnvironment">
    isEnabled?: BoolWithAggregatesFilter<"MockEnvironment"> | boolean
    isDefault?: BoolWithAggregatesFilter<"MockEnvironment"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"MockEnvironment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MockEnvironment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MockEnvironment"> | Date | string
  }

  export type MockEndpointWhereInput = {
    AND?: MockEndpointWhereInput | MockEndpointWhereInput[]
    OR?: MockEndpointWhereInput[]
    NOT?: MockEndpointWhereInput | MockEndpointWhereInput[]
    id?: StringFilter<"MockEndpoint"> | string
    environmentId?: StringFilter<"MockEndpoint"> | string
    path?: StringFilter<"MockEndpoint"> | string
    method?: StringFilter<"MockEndpoint"> | string
    description?: StringNullableFilter<"MockEndpoint"> | string | null
    isEnabled?: BoolFilter<"MockEndpoint"> | boolean
    order?: IntFilter<"MockEndpoint"> | number
    createdAt?: DateTimeFilter<"MockEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"MockEndpoint"> | Date | string
    environment?: XOR<MockEnvironmentRelationFilter, MockEnvironmentWhereInput>
    responses?: MockResponseListRelationFilter
    conditions?: MockConditionListRelationFilter
  }

  export type MockEndpointOrderByWithRelationInput = {
    id?: SortOrder
    environmentId?: SortOrder
    path?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    environment?: MockEnvironmentOrderByWithRelationInput
    responses?: MockResponseOrderByRelationAggregateInput
    conditions?: MockConditionOrderByRelationAggregateInput
  }

  export type MockEndpointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    environmentId_path_method?: MockEndpointEnvironmentIdPathMethodCompoundUniqueInput
    AND?: MockEndpointWhereInput | MockEndpointWhereInput[]
    OR?: MockEndpointWhereInput[]
    NOT?: MockEndpointWhereInput | MockEndpointWhereInput[]
    environmentId?: StringFilter<"MockEndpoint"> | string
    path?: StringFilter<"MockEndpoint"> | string
    method?: StringFilter<"MockEndpoint"> | string
    description?: StringNullableFilter<"MockEndpoint"> | string | null
    isEnabled?: BoolFilter<"MockEndpoint"> | boolean
    order?: IntFilter<"MockEndpoint"> | number
    createdAt?: DateTimeFilter<"MockEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"MockEndpoint"> | Date | string
    environment?: XOR<MockEnvironmentRelationFilter, MockEnvironmentWhereInput>
    responses?: MockResponseListRelationFilter
    conditions?: MockConditionListRelationFilter
  }, "id" | "environmentId_path_method">

  export type MockEndpointOrderByWithAggregationInput = {
    id?: SortOrder
    environmentId?: SortOrder
    path?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MockEndpointCountOrderByAggregateInput
    _avg?: MockEndpointAvgOrderByAggregateInput
    _max?: MockEndpointMaxOrderByAggregateInput
    _min?: MockEndpointMinOrderByAggregateInput
    _sum?: MockEndpointSumOrderByAggregateInput
  }

  export type MockEndpointScalarWhereWithAggregatesInput = {
    AND?: MockEndpointScalarWhereWithAggregatesInput | MockEndpointScalarWhereWithAggregatesInput[]
    OR?: MockEndpointScalarWhereWithAggregatesInput[]
    NOT?: MockEndpointScalarWhereWithAggregatesInput | MockEndpointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockEndpoint"> | string
    environmentId?: StringWithAggregatesFilter<"MockEndpoint"> | string
    path?: StringWithAggregatesFilter<"MockEndpoint"> | string
    method?: StringWithAggregatesFilter<"MockEndpoint"> | string
    description?: StringNullableWithAggregatesFilter<"MockEndpoint"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"MockEndpoint"> | boolean
    order?: IntWithAggregatesFilter<"MockEndpoint"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MockEndpoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MockEndpoint"> | Date | string
  }

  export type MockResponseWhereInput = {
    AND?: MockResponseWhereInput | MockResponseWhereInput[]
    OR?: MockResponseWhereInput[]
    NOT?: MockResponseWhereInput | MockResponseWhereInput[]
    id?: StringFilter<"MockResponse"> | string
    endpointId?: StringFilter<"MockResponse"> | string
    statusCode?: IntFilter<"MockResponse"> | number
    name?: StringNullableFilter<"MockResponse"> | string | null
    description?: StringNullableFilter<"MockResponse"> | string | null
    responseBody?: JsonNullableFilter<"MockResponse">
    responseHeaders?: JsonNullableFilter<"MockResponse">
    delay?: IntFilter<"MockResponse"> | number
    isDefault?: BoolFilter<"MockResponse"> | boolean
    isEnabled?: BoolFilter<"MockResponse"> | boolean
    order?: IntFilter<"MockResponse"> | number
    createdAt?: DateTimeFilter<"MockResponse"> | Date | string
    updatedAt?: DateTimeFilter<"MockResponse"> | Date | string
    endpoint?: XOR<MockEndpointRelationFilter, MockEndpointWhereInput>
    conditions?: MockConditionListRelationFilter
  }

  export type MockResponseOrderByWithRelationInput = {
    id?: SortOrder
    endpointId?: SortOrder
    statusCode?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    delay?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endpoint?: MockEndpointOrderByWithRelationInput
    conditions?: MockConditionOrderByRelationAggregateInput
  }

  export type MockResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MockResponseWhereInput | MockResponseWhereInput[]
    OR?: MockResponseWhereInput[]
    NOT?: MockResponseWhereInput | MockResponseWhereInput[]
    endpointId?: StringFilter<"MockResponse"> | string
    statusCode?: IntFilter<"MockResponse"> | number
    name?: StringNullableFilter<"MockResponse"> | string | null
    description?: StringNullableFilter<"MockResponse"> | string | null
    responseBody?: JsonNullableFilter<"MockResponse">
    responseHeaders?: JsonNullableFilter<"MockResponse">
    delay?: IntFilter<"MockResponse"> | number
    isDefault?: BoolFilter<"MockResponse"> | boolean
    isEnabled?: BoolFilter<"MockResponse"> | boolean
    order?: IntFilter<"MockResponse"> | number
    createdAt?: DateTimeFilter<"MockResponse"> | Date | string
    updatedAt?: DateTimeFilter<"MockResponse"> | Date | string
    endpoint?: XOR<MockEndpointRelationFilter, MockEndpointWhereInput>
    conditions?: MockConditionListRelationFilter
  }, "id">

  export type MockResponseOrderByWithAggregationInput = {
    id?: SortOrder
    endpointId?: SortOrder
    statusCode?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    delay?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MockResponseCountOrderByAggregateInput
    _avg?: MockResponseAvgOrderByAggregateInput
    _max?: MockResponseMaxOrderByAggregateInput
    _min?: MockResponseMinOrderByAggregateInput
    _sum?: MockResponseSumOrderByAggregateInput
  }

  export type MockResponseScalarWhereWithAggregatesInput = {
    AND?: MockResponseScalarWhereWithAggregatesInput | MockResponseScalarWhereWithAggregatesInput[]
    OR?: MockResponseScalarWhereWithAggregatesInput[]
    NOT?: MockResponseScalarWhereWithAggregatesInput | MockResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockResponse"> | string
    endpointId?: StringWithAggregatesFilter<"MockResponse"> | string
    statusCode?: IntWithAggregatesFilter<"MockResponse"> | number
    name?: StringNullableWithAggregatesFilter<"MockResponse"> | string | null
    description?: StringNullableWithAggregatesFilter<"MockResponse"> | string | null
    responseBody?: JsonNullableWithAggregatesFilter<"MockResponse">
    responseHeaders?: JsonNullableWithAggregatesFilter<"MockResponse">
    delay?: IntWithAggregatesFilter<"MockResponse"> | number
    isDefault?: BoolWithAggregatesFilter<"MockResponse"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"MockResponse"> | boolean
    order?: IntWithAggregatesFilter<"MockResponse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MockResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MockResponse"> | Date | string
  }

  export type MockConditionWhereInput = {
    AND?: MockConditionWhereInput | MockConditionWhereInput[]
    OR?: MockConditionWhereInput[]
    NOT?: MockConditionWhereInput | MockConditionWhereInput[]
    id?: StringFilter<"MockCondition"> | string
    responseId?: StringNullableFilter<"MockCondition"> | string | null
    endpointId?: StringNullableFilter<"MockCondition"> | string | null
    type?: StringFilter<"MockCondition"> | string
    key?: StringFilter<"MockCondition"> | string
    operator?: StringFilter<"MockCondition"> | string
    value?: StringNullableFilter<"MockCondition"> | string | null
    isCaseSensitive?: BoolFilter<"MockCondition"> | boolean
    order?: IntFilter<"MockCondition"> | number
    createdAt?: DateTimeFilter<"MockCondition"> | Date | string
    response?: XOR<MockResponseNullableRelationFilter, MockResponseWhereInput> | null
    endpoint?: XOR<MockEndpointNullableRelationFilter, MockEndpointWhereInput> | null
  }

  export type MockConditionOrderByWithRelationInput = {
    id?: SortOrder
    responseId?: SortOrderInput | SortOrder
    endpointId?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    isCaseSensitive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    response?: MockResponseOrderByWithRelationInput
    endpoint?: MockEndpointOrderByWithRelationInput
  }

  export type MockConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MockConditionWhereInput | MockConditionWhereInput[]
    OR?: MockConditionWhereInput[]
    NOT?: MockConditionWhereInput | MockConditionWhereInput[]
    responseId?: StringNullableFilter<"MockCondition"> | string | null
    endpointId?: StringNullableFilter<"MockCondition"> | string | null
    type?: StringFilter<"MockCondition"> | string
    key?: StringFilter<"MockCondition"> | string
    operator?: StringFilter<"MockCondition"> | string
    value?: StringNullableFilter<"MockCondition"> | string | null
    isCaseSensitive?: BoolFilter<"MockCondition"> | boolean
    order?: IntFilter<"MockCondition"> | number
    createdAt?: DateTimeFilter<"MockCondition"> | Date | string
    response?: XOR<MockResponseNullableRelationFilter, MockResponseWhereInput> | null
    endpoint?: XOR<MockEndpointNullableRelationFilter, MockEndpointWhereInput> | null
  }, "id">

  export type MockConditionOrderByWithAggregationInput = {
    id?: SortOrder
    responseId?: SortOrderInput | SortOrder
    endpointId?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    isCaseSensitive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: MockConditionCountOrderByAggregateInput
    _avg?: MockConditionAvgOrderByAggregateInput
    _max?: MockConditionMaxOrderByAggregateInput
    _min?: MockConditionMinOrderByAggregateInput
    _sum?: MockConditionSumOrderByAggregateInput
  }

  export type MockConditionScalarWhereWithAggregatesInput = {
    AND?: MockConditionScalarWhereWithAggregatesInput | MockConditionScalarWhereWithAggregatesInput[]
    OR?: MockConditionScalarWhereWithAggregatesInput[]
    NOT?: MockConditionScalarWhereWithAggregatesInput | MockConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockCondition"> | string
    responseId?: StringNullableWithAggregatesFilter<"MockCondition"> | string | null
    endpointId?: StringNullableWithAggregatesFilter<"MockCondition"> | string | null
    type?: StringWithAggregatesFilter<"MockCondition"> | string
    key?: StringWithAggregatesFilter<"MockCondition"> | string
    operator?: StringWithAggregatesFilter<"MockCondition"> | string
    value?: StringNullableWithAggregatesFilter<"MockCondition"> | string | null
    isCaseSensitive?: BoolWithAggregatesFilter<"MockCondition"> | boolean
    order?: IntWithAggregatesFilter<"MockCondition"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MockCondition"> | Date | string
  }

  export type ConfigAlertWhereInput = {
    AND?: ConfigAlertWhereInput | ConfigAlertWhereInput[]
    OR?: ConfigAlertWhereInput[]
    NOT?: ConfigAlertWhereInput | ConfigAlertWhereInput[]
    id?: StringFilter<"ConfigAlert"> | string
    projectId?: StringFilter<"ConfigAlert"> | string
    configId?: StringNullableFilter<"ConfigAlert"> | string | null
    name?: StringFilter<"ConfigAlert"> | string
    description?: StringNullableFilter<"ConfigAlert"> | string | null
    condition?: StringFilter<"ConfigAlert"> | string
    threshold?: FloatFilter<"ConfigAlert"> | number
    operator?: StringFilter<"ConfigAlert"> | string
    timeWindow?: IntFilter<"ConfigAlert"> | number
    minOccurrences?: IntFilter<"ConfigAlert"> | number
    enabled?: BoolFilter<"ConfigAlert"> | boolean
    webhookUrl?: StringNullableFilter<"ConfigAlert"> | string | null
    emailRecipients?: JsonNullableFilter<"ConfigAlert">
    lastTriggered?: DateTimeNullableFilter<"ConfigAlert"> | Date | string | null
    triggerCount?: IntFilter<"ConfigAlert"> | number
    createdAt?: DateTimeFilter<"ConfigAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigAlert"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    config?: XOR<BusinessConfigNullableRelationFilter, BusinessConfigWhereInput> | null
    events?: ConfigAlertEventListRelationFilter
  }

  export type ConfigAlertOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    operator?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    enabled?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    emailRecipients?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    config?: BusinessConfigOrderByWithRelationInput
    events?: ConfigAlertEventOrderByRelationAggregateInput
  }

  export type ConfigAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigAlertWhereInput | ConfigAlertWhereInput[]
    OR?: ConfigAlertWhereInput[]
    NOT?: ConfigAlertWhereInput | ConfigAlertWhereInput[]
    projectId?: StringFilter<"ConfigAlert"> | string
    configId?: StringNullableFilter<"ConfigAlert"> | string | null
    name?: StringFilter<"ConfigAlert"> | string
    description?: StringNullableFilter<"ConfigAlert"> | string | null
    condition?: StringFilter<"ConfigAlert"> | string
    threshold?: FloatFilter<"ConfigAlert"> | number
    operator?: StringFilter<"ConfigAlert"> | string
    timeWindow?: IntFilter<"ConfigAlert"> | number
    minOccurrences?: IntFilter<"ConfigAlert"> | number
    enabled?: BoolFilter<"ConfigAlert"> | boolean
    webhookUrl?: StringNullableFilter<"ConfigAlert"> | string | null
    emailRecipients?: JsonNullableFilter<"ConfigAlert">
    lastTriggered?: DateTimeNullableFilter<"ConfigAlert"> | Date | string | null
    triggerCount?: IntFilter<"ConfigAlert"> | number
    createdAt?: DateTimeFilter<"ConfigAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigAlert"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    config?: XOR<BusinessConfigNullableRelationFilter, BusinessConfigWhereInput> | null
    events?: ConfigAlertEventListRelationFilter
  }, "id">

  export type ConfigAlertOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    operator?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    enabled?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    emailRecipients?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigAlertCountOrderByAggregateInput
    _avg?: ConfigAlertAvgOrderByAggregateInput
    _max?: ConfigAlertMaxOrderByAggregateInput
    _min?: ConfigAlertMinOrderByAggregateInput
    _sum?: ConfigAlertSumOrderByAggregateInput
  }

  export type ConfigAlertScalarWhereWithAggregatesInput = {
    AND?: ConfigAlertScalarWhereWithAggregatesInput | ConfigAlertScalarWhereWithAggregatesInput[]
    OR?: ConfigAlertScalarWhereWithAggregatesInput[]
    NOT?: ConfigAlertScalarWhereWithAggregatesInput | ConfigAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigAlert"> | string
    projectId?: StringWithAggregatesFilter<"ConfigAlert"> | string
    configId?: StringNullableWithAggregatesFilter<"ConfigAlert"> | string | null
    name?: StringWithAggregatesFilter<"ConfigAlert"> | string
    description?: StringNullableWithAggregatesFilter<"ConfigAlert"> | string | null
    condition?: StringWithAggregatesFilter<"ConfigAlert"> | string
    threshold?: FloatWithAggregatesFilter<"ConfigAlert"> | number
    operator?: StringWithAggregatesFilter<"ConfigAlert"> | string
    timeWindow?: IntWithAggregatesFilter<"ConfigAlert"> | number
    minOccurrences?: IntWithAggregatesFilter<"ConfigAlert"> | number
    enabled?: BoolWithAggregatesFilter<"ConfigAlert"> | boolean
    webhookUrl?: StringNullableWithAggregatesFilter<"ConfigAlert"> | string | null
    emailRecipients?: JsonNullableWithAggregatesFilter<"ConfigAlert">
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"ConfigAlert"> | Date | string | null
    triggerCount?: IntWithAggregatesFilter<"ConfigAlert"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ConfigAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfigAlert"> | Date | string
  }

  export type ConfigAlertEventWhereInput = {
    AND?: ConfigAlertEventWhereInput | ConfigAlertEventWhereInput[]
    OR?: ConfigAlertEventWhereInput[]
    NOT?: ConfigAlertEventWhereInput | ConfigAlertEventWhereInput[]
    id?: StringFilter<"ConfigAlertEvent"> | string
    alertId?: StringFilter<"ConfigAlertEvent"> | string
    projectId?: StringFilter<"ConfigAlertEvent"> | string
    configId?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    severity?: StringFilter<"ConfigAlertEvent"> | string
    message?: StringFilter<"ConfigAlertEvent"> | string
    metadata?: JsonNullableFilter<"ConfigAlertEvent">
    acknowledged?: BoolFilter<"ConfigAlertEvent"> | boolean
    acknowledgedBy?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConfigAlertEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"ConfigAlertEvent"> | Date | string
    alert?: XOR<ConfigAlertRelationFilter, ConfigAlertWhereInput>
  }

  export type ConfigAlertEventOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    configId?: SortOrderInput | SortOrder
    severity?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    alert?: ConfigAlertOrderByWithRelationInput
  }

  export type ConfigAlertEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigAlertEventWhereInput | ConfigAlertEventWhereInput[]
    OR?: ConfigAlertEventWhereInput[]
    NOT?: ConfigAlertEventWhereInput | ConfigAlertEventWhereInput[]
    alertId?: StringFilter<"ConfigAlertEvent"> | string
    projectId?: StringFilter<"ConfigAlertEvent"> | string
    configId?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    severity?: StringFilter<"ConfigAlertEvent"> | string
    message?: StringFilter<"ConfigAlertEvent"> | string
    metadata?: JsonNullableFilter<"ConfigAlertEvent">
    acknowledged?: BoolFilter<"ConfigAlertEvent"> | boolean
    acknowledgedBy?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConfigAlertEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"ConfigAlertEvent"> | Date | string
    alert?: XOR<ConfigAlertRelationFilter, ConfigAlertWhereInput>
  }, "id">

  export type ConfigAlertEventOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    configId?: SortOrderInput | SortOrder
    severity?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConfigAlertEventCountOrderByAggregateInput
    _max?: ConfigAlertEventMaxOrderByAggregateInput
    _min?: ConfigAlertEventMinOrderByAggregateInput
  }

  export type ConfigAlertEventScalarWhereWithAggregatesInput = {
    AND?: ConfigAlertEventScalarWhereWithAggregatesInput | ConfigAlertEventScalarWhereWithAggregatesInput[]
    OR?: ConfigAlertEventScalarWhereWithAggregatesInput[]
    NOT?: ConfigAlertEventScalarWhereWithAggregatesInput | ConfigAlertEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigAlertEvent"> | string
    alertId?: StringWithAggregatesFilter<"ConfigAlertEvent"> | string
    projectId?: StringWithAggregatesFilter<"ConfigAlertEvent"> | string
    configId?: StringNullableWithAggregatesFilter<"ConfigAlertEvent"> | string | null
    severity?: StringWithAggregatesFilter<"ConfigAlertEvent"> | string
    message?: StringWithAggregatesFilter<"ConfigAlertEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ConfigAlertEvent">
    acknowledged?: BoolWithAggregatesFilter<"ConfigAlertEvent"> | boolean
    acknowledgedBy?: StringNullableWithAggregatesFilter<"ConfigAlertEvent"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"ConfigAlertEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConfigAlertEvent"> | Date | string
  }

  export type ConfigApprovalWhereInput = {
    AND?: ConfigApprovalWhereInput | ConfigApprovalWhereInput[]
    OR?: ConfigApprovalWhereInput[]
    NOT?: ConfigApprovalWhereInput | ConfigApprovalWhereInput[]
    id?: StringFilter<"ConfigApproval"> | string
    projectId?: StringFilter<"ConfigApproval"> | string
    configId?: StringFilter<"ConfigApproval"> | string
    changeType?: StringFilter<"ConfigApproval"> | string
    changeData?: JsonFilter<"ConfigApproval">
    status?: StringFilter<"ConfigApproval"> | string
    requiredApprovals?: IntFilter<"ConfigApproval"> | number
    currentApprovals?: IntFilter<"ConfigApproval"> | number
    approvers?: JsonFilter<"ConfigApproval">
    approvals?: JsonFilter<"ConfigApproval">
    requestedBy?: StringFilter<"ConfigApproval"> | string
    requestedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    decidedBy?: StringNullableFilter<"ConfigApproval"> | string | null
    decidedAt?: DateTimeNullableFilter<"ConfigApproval"> | Date | string | null
    decisionComment?: StringNullableFilter<"ConfigApproval"> | string | null
    createdAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    config?: XOR<BusinessConfigRelationFilter, BusinessConfigWhereInput>
  }

  export type ConfigApprovalOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    changeType?: SortOrder
    changeData?: SortOrder
    status?: SortOrder
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
    approvers?: SortOrder
    approvals?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    decidedBy?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    decisionComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    config?: BusinessConfigOrderByWithRelationInput
  }

  export type ConfigApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigApprovalWhereInput | ConfigApprovalWhereInput[]
    OR?: ConfigApprovalWhereInput[]
    NOT?: ConfigApprovalWhereInput | ConfigApprovalWhereInput[]
    projectId?: StringFilter<"ConfigApproval"> | string
    configId?: StringFilter<"ConfigApproval"> | string
    changeType?: StringFilter<"ConfigApproval"> | string
    changeData?: JsonFilter<"ConfigApproval">
    status?: StringFilter<"ConfigApproval"> | string
    requiredApprovals?: IntFilter<"ConfigApproval"> | number
    currentApprovals?: IntFilter<"ConfigApproval"> | number
    approvers?: JsonFilter<"ConfigApproval">
    approvals?: JsonFilter<"ConfigApproval">
    requestedBy?: StringFilter<"ConfigApproval"> | string
    requestedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    decidedBy?: StringNullableFilter<"ConfigApproval"> | string | null
    decidedAt?: DateTimeNullableFilter<"ConfigApproval"> | Date | string | null
    decisionComment?: StringNullableFilter<"ConfigApproval"> | string | null
    createdAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    config?: XOR<BusinessConfigRelationFilter, BusinessConfigWhereInput>
  }, "id">

  export type ConfigApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    changeType?: SortOrder
    changeData?: SortOrder
    status?: SortOrder
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
    approvers?: SortOrder
    approvals?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    decidedBy?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    decisionComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigApprovalCountOrderByAggregateInput
    _avg?: ConfigApprovalAvgOrderByAggregateInput
    _max?: ConfigApprovalMaxOrderByAggregateInput
    _min?: ConfigApprovalMinOrderByAggregateInput
    _sum?: ConfigApprovalSumOrderByAggregateInput
  }

  export type ConfigApprovalScalarWhereWithAggregatesInput = {
    AND?: ConfigApprovalScalarWhereWithAggregatesInput | ConfigApprovalScalarWhereWithAggregatesInput[]
    OR?: ConfigApprovalScalarWhereWithAggregatesInput[]
    NOT?: ConfigApprovalScalarWhereWithAggregatesInput | ConfigApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigApproval"> | string
    projectId?: StringWithAggregatesFilter<"ConfigApproval"> | string
    configId?: StringWithAggregatesFilter<"ConfigApproval"> | string
    changeType?: StringWithAggregatesFilter<"ConfigApproval"> | string
    changeData?: JsonWithAggregatesFilter<"ConfigApproval">
    status?: StringWithAggregatesFilter<"ConfigApproval"> | string
    requiredApprovals?: IntWithAggregatesFilter<"ConfigApproval"> | number
    currentApprovals?: IntWithAggregatesFilter<"ConfigApproval"> | number
    approvers?: JsonWithAggregatesFilter<"ConfigApproval">
    approvals?: JsonWithAggregatesFilter<"ConfigApproval">
    requestedBy?: StringWithAggregatesFilter<"ConfigApproval"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"ConfigApproval"> | Date | string
    decidedBy?: StringNullableWithAggregatesFilter<"ConfigApproval"> | string | null
    decidedAt?: DateTimeNullableWithAggregatesFilter<"ConfigApproval"> | Date | string | null
    decisionComment?: StringNullableWithAggregatesFilter<"ConfigApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConfigApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfigApproval"> | Date | string
  }

  export type SystemConfigurationWhereInput = {
    AND?: SystemConfigurationWhereInput | SystemConfigurationWhereInput[]
    OR?: SystemConfigurationWhereInput[]
    NOT?: SystemConfigurationWhereInput | SystemConfigurationWhereInput[]
    id?: StringFilter<"SystemConfiguration"> | string
    category?: StringFilter<"SystemConfiguration"> | string
    key?: StringFilter<"SystemConfiguration"> | string
    value?: StringNullableFilter<"SystemConfiguration"> | string | null
    encrypted?: BoolFilter<"SystemConfiguration"> | boolean
    description?: StringNullableFilter<"SystemConfiguration"> | string | null
    isActive?: BoolFilter<"SystemConfiguration"> | boolean
    metadata?: JsonNullableFilter<"SystemConfiguration">
    updatedBy?: StringNullableFilter<"SystemConfiguration"> | string | null
    createdAt?: DateTimeFilter<"SystemConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfiguration"> | Date | string
  }

  export type SystemConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    encrypted?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category_key?: SystemConfigurationCategoryKeyCompoundUniqueInput
    AND?: SystemConfigurationWhereInput | SystemConfigurationWhereInput[]
    OR?: SystemConfigurationWhereInput[]
    NOT?: SystemConfigurationWhereInput | SystemConfigurationWhereInput[]
    category?: StringFilter<"SystemConfiguration"> | string
    key?: StringFilter<"SystemConfiguration"> | string
    value?: StringNullableFilter<"SystemConfiguration"> | string | null
    encrypted?: BoolFilter<"SystemConfiguration"> | boolean
    description?: StringNullableFilter<"SystemConfiguration"> | string | null
    isActive?: BoolFilter<"SystemConfiguration"> | boolean
    metadata?: JsonNullableFilter<"SystemConfiguration">
    updatedBy?: StringNullableFilter<"SystemConfiguration"> | string | null
    createdAt?: DateTimeFilter<"SystemConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfiguration"> | Date | string
  }, "id" | "category_key">

  export type SystemConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    encrypted?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigurationCountOrderByAggregateInput
    _max?: SystemConfigurationMaxOrderByAggregateInput
    _min?: SystemConfigurationMinOrderByAggregateInput
  }

  export type SystemConfigurationScalarWhereWithAggregatesInput = {
    AND?: SystemConfigurationScalarWhereWithAggregatesInput | SystemConfigurationScalarWhereWithAggregatesInput[]
    OR?: SystemConfigurationScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigurationScalarWhereWithAggregatesInput | SystemConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfiguration"> | string
    category?: StringWithAggregatesFilter<"SystemConfiguration"> | string
    key?: StringWithAggregatesFilter<"SystemConfiguration"> | string
    value?: StringNullableWithAggregatesFilter<"SystemConfiguration"> | string | null
    encrypted?: BoolWithAggregatesFilter<"SystemConfiguration"> | boolean
    description?: StringNullableWithAggregatesFilter<"SystemConfiguration"> | string | null
    isActive?: BoolWithAggregatesFilter<"SystemConfiguration"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"SystemConfiguration">
    updatedBy?: StringNullableWithAggregatesFilter<"SystemConfiguration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfiguration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutDevicesInput
    logs?: LogCreateNestedManyWithoutDeviceInput
    crashes?: CrashCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceCreateNestedManyWithoutDeviceInput
    sessions?: SessionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
    crashes?: CrashUncheckedCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutDeviceInput
    sessions?: SessionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutDevicesNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateInput = {
    id?: string
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutLogsInput
    device?: DeviceCreateNestedOneWithoutLogsInput
    session?: SessionCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
    device?: DeviceUpdateOneWithoutLogsNestedInput
    session?: SessionUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashCreateInput = {
    id?: string
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCrashesInput
    device?: DeviceCreateNestedOneWithoutCrashesInput
  }

  export type CrashUncheckedCreateInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCrashesNestedInput
    device?: DeviceUpdateOneWithoutCrashesNestedInput
  }

  export type CrashUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashCreateManyInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceCreateInput = {
    id?: string
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiTracesInput
    device?: DeviceCreateNestedOneWithoutApiTracesInput
    session?: SessionCreateNestedOneWithoutApiTracesInput
  }

  export type ApiTraceUncheckedCreateInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiTracesNestedInput
    device?: DeviceUpdateOneWithoutApiTracesNestedInput
    session?: SessionUpdateOneWithoutApiTracesNestedInput
  }

  export type ApiTraceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceCreateManyInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigCreateInput = {
    id?: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiConfigsInput
  }

  export type ApiConfigUncheckedCreateInput = {
    id?: string
    projectId: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiConfigsNestedInput
  }

  export type ApiConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigCreateManyInput = {
    id?: string
    projectId: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSessionsInput
    device?: DeviceCreateNestedOneWithoutSessionsInput
    apiTraces?: ApiTraceCreateNestedManyWithoutSessionInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutSessionInput
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
    device?: DeviceUpdateOneWithoutSessionsNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutSessionNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutSessionNestedInput
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    emailEnabled?: boolean
    emailAddresses?: NotificationSettingsCreateemailAddressesInput | string[]
    pushEnabled?: boolean
    pushToken?: string | null
    smsEnabled?: boolean
    smsNumbers?: NotificationSettingsCreatesmsNumbersInput | string[]
    webhookEnabled?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    projectId: string
    emailEnabled?: boolean
    emailAddresses?: NotificationSettingsCreateemailAddressesInput | string[]
    pushEnabled?: boolean
    pushToken?: string | null
    smsEnabled?: boolean
    smsNumbers?: NotificationSettingsCreatesmsNumbersInput | string[]
    webhookEnabled?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    projectId: string
    emailEnabled?: boolean
    emailAddresses?: NotificationSettingsCreateemailAddressesInput | string[]
    pushEnabled?: boolean
    pushToken?: string | null
    smsEnabled?: boolean
    smsNumbers?: NotificationSettingsCreatesmsNumbersInput | string[]
    webhookEnabled?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiAlertCreateInput = {
    id?: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiAlertsInput
    monitoredErrors?: MonitoredErrorCreateNestedManyWithoutAlertInput
  }

  export type ApiAlertUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    monitoredErrors?: MonitoredErrorUncheckedCreateNestedManyWithoutAlertInput
  }

  export type ApiAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiAlertsNestedInput
    monitoredErrors?: MonitoredErrorUpdateManyWithoutAlertNestedInput
  }

  export type ApiAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitoredErrors?: MonitoredErrorUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type ApiAlertCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorCreateInput = {
    id?: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alert: ApiAlertCreateNestedOneWithoutMonitoredErrorsInput
  }

  export type MonitoredErrorUncheckedCreateInput = {
    id?: string
    alertId: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredErrorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: ApiAlertUpdateOneRequiredWithoutMonitoredErrorsNestedInput
  }

  export type MonitoredErrorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorCreateManyInput = {
    id?: string
    alertId: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredErrorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessConfigCreateInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBusinessConfigsInput
    alerts?: ConfigAlertCreateNestedManyWithoutConfigInput
    approvals?: ConfigApprovalCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigUncheckedCreateInput = {
    id?: string
    projectId: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: ConfigAlertUncheckedCreateNestedManyWithoutConfigInput
    approvals?: ConfigApprovalUncheckedCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBusinessConfigsNestedInput
    alerts?: ConfigAlertUpdateManyWithoutConfigNestedInput
    approvals?: ConfigApprovalUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: ConfigAlertUncheckedUpdateManyWithoutConfigNestedInput
    approvals?: ConfigApprovalUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigCreateManyInput = {
    id?: string
    projectId: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileCreateInput = {
    id?: string
    projectId: string
    filename: string
    storedName: string
    mimeType: string
    size: number
    url: string
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type UploadedFileUncheckedCreateInput = {
    id?: string
    projectId: string
    filename: string
    storedName: string
    mimeType: string
    size: number
    url: string
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type UploadedFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileCreateManyInput = {
    id?: string
    projectId: string
    filename: string
    storedName: string
    mimeType: string
    size: number
    url: string
    uploadedBy?: string | null
    createdAt?: Date | string
  }

  export type UploadedFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadedFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLanguagesInput
    translations?: TranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    projectId: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLanguagesNestedInput
    translations?: TranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    projectId: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizationKeyCreateInput = {
    id?: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLocalizationKeysInput
    translations?: TranslationCreateNestedManyWithoutKeyInput
  }

  export type LocalizationKeyUncheckedCreateInput = {
    id?: string
    projectId: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutKeyInput
  }

  export type LocalizationKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLocalizationKeysNestedInput
    translations?: TranslationUpdateManyWithoutKeyNestedInput
  }

  export type LocalizationKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutKeyNestedInput
  }

  export type LocalizationKeyCreateManyInput = {
    id?: string
    projectId: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalizationKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizationKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateInput = {
    id?: string
    projectId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    key: LocalizationKeyCreateNestedOneWithoutTranslationsInput
    language: LanguageCreateNestedOneWithoutTranslationsInput
  }

  export type TranslationUncheckedCreateInput = {
    id?: string
    projectId: string
    keyId: string
    languageId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: LocalizationKeyUpdateOneRequiredWithoutTranslationsNestedInput
    language?: LanguageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyInput = {
    id?: string
    projectId: string
    keyId: string
    languageId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagsCreateInput = {
    id?: string
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutFeatureFlagsInput
  }

  export type FeatureFlagsUncheckedCreateInput = {
    id?: string
    projectId: string
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutFeatureFlagsNestedInput
  }

  export type FeatureFlagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagsCreateManyInput = {
    id?: string
    projectId: string
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdkSettingsCreateInput = {
    id?: string
    trackingMode?: string
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: SdkSettingsCreatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: number
    maxTraceQueueSize?: number
    flushIntervalSeconds?: number
    enableBatching?: boolean
    minLogLevel?: string
    verboseErrors?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSdkSettingsInput
  }

  export type SdkSettingsUncheckedCreateInput = {
    id?: string
    projectId: string
    trackingMode?: string
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: SdkSettingsCreatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: number
    maxTraceQueueSize?: number
    flushIntervalSeconds?: number
    enableBatching?: boolean
    minLogLevel?: string
    verboseErrors?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdkSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSdkSettingsNestedInput
  }

  export type SdkSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdkSettingsCreateManyInput = {
    id?: string
    projectId: string
    trackingMode?: string
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: SdkSettingsCreatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: number
    maxTraceQueueSize?: number
    flushIntervalSeconds?: number
    enableBatching?: boolean
    minLogLevel?: string
    verboseErrors?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdkSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdkSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryCreateInput = {
    id?: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigCategoriesInput
  }

  export type ConfigCategoryUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigCategoriesNestedInput
  }

  export type ConfigCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryCreateManyInput = {
    id?: string
    projectId: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    price?: number
    currency?: string
    interval?: string
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: number | null
    maxDevices?: number | null
    maxMockEndpoints?: number | null
    maxApiEndpoints?: number | null
    maxApiRequests?: number | null
    maxLogs?: number | null
    maxSessions?: number | null
    maxCrashes?: number | null
    maxBusinessConfigKeys?: number | null
    maxLocalizationLanguages?: number | null
    maxLocalizationKeys?: number | null
    retentionDays?: number | null
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    price?: number
    currency?: string
    interval?: string
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: number | null
    maxDevices?: number | null
    maxMockEndpoints?: number | null
    maxApiEndpoints?: number | null
    maxApiRequests?: number | null
    maxLogs?: number | null
    maxSessions?: number | null
    maxCrashes?: number | null
    maxBusinessConfigKeys?: number | null
    maxLocalizationLanguages?: number | null
    maxLocalizationKeys?: number | null
    retentionDays?: number | null
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    price?: number
    currency?: string
    interval?: string
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: number | null
    maxDevices?: number | null
    maxMockEndpoints?: number | null
    maxApiEndpoints?: number | null
    maxApiRequests?: number | null
    maxLogs?: number | null
    maxSessions?: number | null
    maxCrashes?: number | null
    maxBusinessConfigKeys?: number | null
    maxLocalizationLanguages?: number | null
    maxLocalizationKeys?: number | null
    retentionDays?: number | null
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnforcementStateCreateInput = {
    id?: string
    state?: string
    warnEnteredAt?: Date | string | null
    graceEnteredAt?: Date | string | null
    graceEndsAt?: Date | string | null
    degradedEnteredAt?: Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: Date | string
    nextEvaluationAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutEnforcementStateInput
  }

  export type EnforcementStateUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    state?: string
    warnEnteredAt?: Date | string | null
    graceEnteredAt?: Date | string | null
    graceEndsAt?: Date | string | null
    degradedEnteredAt?: Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: Date | string
    nextEvaluationAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnforcementStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutEnforcementStateNestedInput
  }

  export type EnforcementStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnforcementStateCreateManyInput = {
    id?: string
    subscriptionId: string
    state?: string
    warnEnteredAt?: Date | string | null
    graceEnteredAt?: Date | string | null
    graceEndsAt?: Date | string | null
    degradedEnteredAt?: Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: Date | string
    nextEvaluationAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnforcementStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnforcementStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    subscriptionId: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildCreateInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    project: ProjectCreateNestedOneWithoutBuildsInput
    features?: BuildFeatureCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureUncheckedCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBuildsNestedInput
    features?: BuildFeatureUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
  }

  export type BuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
  }

  export type BuildFeatureCreateInput = {
    id?: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
    build: BuildCreateNestedOneWithoutFeaturesInput
  }

  export type BuildFeatureUncheckedCreateInput = {
    id?: string
    buildId: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
  }

  export type BuildFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    build?: BuildUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type BuildFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildFeatureCreateManyInput = {
    id?: string
    buildId: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
  }

  export type BuildFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildModeCreateInput = {
    id?: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBuildModeInput
    previewBuild?: BuildCreateNestedOneWithoutPreviewModeInput
    productionBuild?: BuildCreateNestedOneWithoutProductionModeInput
  }

  export type BuildModeUncheckedCreateInput = {
    id?: string
    projectId: string
    previewBuildId?: string | null
    productionBuildId?: string | null
    updatedAt?: Date | string
  }

  export type BuildModeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBuildModeNestedInput
    previewBuild?: BuildUpdateOneWithoutPreviewModeNestedInput
    productionBuild?: BuildUpdateOneWithoutProductionModeNestedInput
  }

  export type BuildModeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    previewBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    productionBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildModeCreateManyInput = {
    id?: string
    projectId: string
    previewBuildId?: string | null
    productionBuildId?: string | null
    updatedAt?: Date | string
  }

  export type BuildModeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildModeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    previewBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    productionBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogCreateInput = {
    id?: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
    build: BuildCreateNestedOneWithoutChangeLogsInput
  }

  export type BuildChangeLogUncheckedCreateInput = {
    id?: string
    buildId: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type BuildChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    build?: BuildUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type BuildChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogCreateManyInput = {
    id?: string
    buildId: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type BuildChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEnvironmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMockEnvironmentsInput
    endpoints?: MockEndpointCreateNestedManyWithoutEnvironmentInput
  }

  export type MockEnvironmentUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoints?: MockEndpointUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type MockEnvironmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMockEnvironmentsNestedInput
    endpoints?: MockEndpointUpdateManyWithoutEnvironmentNestedInput
  }

  export type MockEnvironmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoints?: MockEndpointUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type MockEnvironmentCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockEnvironmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEnvironmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEndpointCreateInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: MockEnvironmentCreateNestedOneWithoutEndpointsInput
    responses?: MockResponseCreateNestedManyWithoutEndpointInput
    conditions?: MockConditionCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointUncheckedCreateInput = {
    id?: string
    environmentId: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: MockResponseUncheckedCreateNestedManyWithoutEndpointInput
    conditions?: MockConditionUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: MockEnvironmentUpdateOneRequiredWithoutEndpointsNestedInput
    responses?: MockResponseUpdateManyWithoutEndpointNestedInput
    conditions?: MockConditionUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: MockResponseUncheckedUpdateManyWithoutEndpointNestedInput
    conditions?: MockConditionUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointCreateManyInput = {
    id?: string
    environmentId: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockEndpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEndpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockResponseCreateInput = {
    id?: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoint: MockEndpointCreateNestedOneWithoutResponsesInput
    conditions?: MockConditionCreateNestedManyWithoutResponseInput
  }

  export type MockResponseUncheckedCreateInput = {
    id?: string
    endpointId: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: MockConditionUncheckedCreateNestedManyWithoutResponseInput
  }

  export type MockResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoint?: MockEndpointUpdateOneRequiredWithoutResponsesNestedInput
    conditions?: MockConditionUpdateManyWithoutResponseNestedInput
  }

  export type MockResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: MockConditionUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type MockResponseCreateManyInput = {
    id?: string
    endpointId: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionCreateInput = {
    id?: string
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
    response?: MockResponseCreateNestedOneWithoutConditionsInput
    endpoint?: MockEndpointCreateNestedOneWithoutConditionsInput
  }

  export type MockConditionUncheckedCreateInput = {
    id?: string
    responseId?: string | null
    endpointId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: MockResponseUpdateOneWithoutConditionsNestedInput
    endpoint?: MockEndpointUpdateOneWithoutConditionsNestedInput
  }

  export type MockConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionCreateManyInput = {
    id?: string
    responseId?: string | null
    endpointId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertCreateInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigAlertsInput
    config?: BusinessConfigCreateNestedOneWithoutAlertsInput
    events?: ConfigAlertEventCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertUncheckedCreateInput = {
    id?: string
    projectId: string
    configId?: string | null
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ConfigAlertEventUncheckedCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigAlertsNestedInput
    config?: BusinessConfigUpdateOneWithoutAlertsNestedInput
    events?: ConfigAlertEventUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ConfigAlertEventUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertCreateManyInput = {
    id?: string
    projectId: string
    configId?: string | null
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventCreateInput = {
    id?: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    alert: ConfigAlertCreateNestedOneWithoutEventsInput
  }

  export type ConfigAlertEventUncheckedCreateInput = {
    id?: string
    alertId: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConfigAlertEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: ConfigAlertUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ConfigAlertEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventCreateManyInput = {
    id?: string
    alertId: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConfigAlertEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalCreateInput = {
    id?: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigApprovalsInput
    config: BusinessConfigCreateNestedOneWithoutApprovalsInput
  }

  export type ConfigApprovalUncheckedCreateInput = {
    id?: string
    projectId: string
    configId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigApprovalsNestedInput
    config?: BusinessConfigUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ConfigApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalCreateManyInput = {
    id?: string
    projectId: string
    configId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigurationCreateInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    encrypted?: boolean
    description?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigurationUncheckedCreateInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    encrypted?: boolean
    description?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigurationCreateManyInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    encrypted?: boolean
    description?: string | null
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    encrypted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type CrashListRelationFilter = {
    every?: CrashWhereInput
    some?: CrashWhereInput
    none?: CrashWhereInput
  }

  export type ApiTraceListRelationFilter = {
    every?: ApiTraceWhereInput
    some?: ApiTraceWhereInput
    none?: ApiTraceWhereInput
  }

  export type ApiConfigListRelationFilter = {
    every?: ApiConfigWhereInput
    some?: ApiConfigWhereInput
    none?: ApiConfigWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationSettingsNullableRelationFilter = {
    is?: NotificationSettingsWhereInput | null
    isNot?: NotificationSettingsWhereInput | null
  }

  export type ApiAlertListRelationFilter = {
    every?: ApiAlertWhereInput
    some?: ApiAlertWhereInput
    none?: ApiAlertWhereInput
  }

  export type BuildListRelationFilter = {
    every?: BuildWhereInput
    some?: BuildWhereInput
    none?: BuildWhereInput
  }

  export type BuildModeNullableRelationFilter = {
    is?: BuildModeWhereInput | null
    isNot?: BuildModeWhereInput | null
  }

  export type MockEnvironmentListRelationFilter = {
    every?: MockEnvironmentWhereInput
    some?: MockEnvironmentWhereInput
    none?: MockEnvironmentWhereInput
  }

  export type BusinessConfigListRelationFilter = {
    every?: BusinessConfigWhereInput
    some?: BusinessConfigWhereInput
    none?: BusinessConfigWhereInput
  }

  export type ConfigAlertListRelationFilter = {
    every?: ConfigAlertWhereInput
    some?: ConfigAlertWhereInput
    none?: ConfigAlertWhereInput
  }

  export type ConfigApprovalListRelationFilter = {
    every?: ConfigApprovalWhereInput
    some?: ConfigApprovalWhereInput
    none?: ConfigApprovalWhereInput
  }

  export type LanguageListRelationFilter = {
    every?: LanguageWhereInput
    some?: LanguageWhereInput
    none?: LanguageWhereInput
  }

  export type LocalizationKeyListRelationFilter = {
    every?: LocalizationKeyWhereInput
    some?: LocalizationKeyWhereInput
    none?: LocalizationKeyWhereInput
  }

  export type FeatureFlagsNullableRelationFilter = {
    is?: FeatureFlagsWhereInput | null
    isNot?: FeatureFlagsWhereInput | null
  }

  export type SdkSettingsNullableRelationFilter = {
    is?: SdkSettingsWhereInput | null
    isNot?: SdkSettingsWhereInput | null
  }

  export type ConfigCategoryListRelationFilter = {
    every?: ConfigCategoryWhereInput
    some?: ConfigCategoryWhereInput
    none?: ConfigCategoryWhereInput
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrashOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiTraceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockEnvironmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalizationKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    platform?: SortOrder
    osVersion?: SortOrder
    appVersion?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    metadata?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceCode?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    debugModeEnabled?: SortOrder
    debugModeEnabledAt?: SortOrder
    debugModeExpiresAt?: SortOrder
    debugModeEnabledBy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    platform?: SortOrder
    osVersion?: SortOrder
    appVersion?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceCode?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    debugModeEnabled?: SortOrder
    debugModeEnabledAt?: SortOrder
    debugModeExpiresAt?: SortOrder
    debugModeEnabledBy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    platform?: SortOrder
    osVersion?: SortOrder
    appVersion?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceCode?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    debugModeEnabled?: SortOrder
    debugModeEnabledAt?: SortOrder
    debugModeExpiresAt?: SortOrder
    debugModeEnabledBy?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type DeviceNullableRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type SessionNullableRelationFilter = {
    is?: SessionWhereInput | null
    isNot?: SessionWhereInput | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    tag?: SortOrder
    data?: SortOrder
    fileName?: SortOrder
    lineNumber?: SortOrder
    functionName?: SortOrder
    className?: SortOrder
    screenName?: SortOrder
    threadName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    lineNumber?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    tag?: SortOrder
    fileName?: SortOrder
    lineNumber?: SortOrder
    functionName?: SortOrder
    className?: SortOrder
    screenName?: SortOrder
    threadName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    level?: SortOrder
    message?: SortOrder
    tag?: SortOrder
    fileName?: SortOrder
    lineNumber?: SortOrder
    functionName?: SortOrder
    className?: SortOrder
    screenName?: SortOrder
    threadName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    lineNumber?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CrashCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    message?: SortOrder
    stackTrace?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    message?: SortOrder
    stackTrace?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    message?: SortOrder
    stackTrace?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ApiTraceCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestHeaders?: SortOrder
    requestBody?: SortOrder
    responseHeaders?: SortOrder
    responseBody?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    screenName?: SortOrder
    networkType?: SortOrder
    country?: SortOrder
    carrier?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    cost?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiTraceAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
  }

  export type ApiTraceMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    screenName?: SortOrder
    networkType?: SortOrder
    country?: SortOrder
    carrier?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    cost?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiTraceMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionId?: SortOrder
    url?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    screenName?: SortOrder
    networkType?: SortOrder
    country?: SortOrder
    carrier?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    cost?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiTraceSumOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ApiConfigProjectIdEndpointMethodCompoundUniqueInput = {
    projectId: string
    endpoint: string
    method: string
  }

  export type ApiConfigCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPerRequest?: SortOrder
    isEnabled?: SortOrder
    enableLogs?: SortOrder
    captureRequestBody?: SortOrder
    captureResponseBody?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigAvgOrderByAggregateInput = {
    costPerRequest?: SortOrder
  }

  export type ApiConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPerRequest?: SortOrder
    isEnabled?: SortOrder
    enableLogs?: SortOrder
    captureRequestBody?: SortOrder
    captureResponseBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPerRequest?: SortOrder
    isEnabled?: SortOrder
    enableLogs?: SortOrder
    captureRequestBody?: SortOrder
    captureResponseBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiConfigSumOrderByAggregateInput = {
    costPerRequest?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isActive?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    networkType?: SortOrder
    screenFlow?: SortOrder
    entryScreen?: SortOrder
    exitScreen?: SortOrder
    duration?: SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
    metadata?: SortOrder
    userProperties?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isActive?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    networkType?: SortOrder
    entryScreen?: SortOrder
    exitScreen?: SortOrder
    duration?: SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    deviceId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isActive?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    networkType?: SortOrder
    entryScreen?: SortOrder
    exitScreen?: SortOrder
    duration?: SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    duration?: SortOrder
    screenCount?: SortOrder
    eventCount?: SortOrder
    errorCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    emailEnabled?: SortOrder
    emailAddresses?: SortOrder
    pushEnabled?: SortOrder
    pushToken?: SortOrder
    smsEnabled?: SortOrder
    smsNumbers?: SortOrder
    webhookEnabled?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    webhookHeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    pushToken?: SortOrder
    smsEnabled?: SortOrder
    webhookEnabled?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    pushToken?: SortOrder
    smsEnabled?: SortOrder
    webhookEnabled?: SortOrder
    webhookUrl?: SortOrder
    webhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MonitoredErrorListRelationFilter = {
    every?: MonitoredErrorWhereInput
    some?: MonitoredErrorWhereInput
    none?: MonitoredErrorWhereInput
  }

  export type MonitoredErrorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiAlertCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    isEnabled?: SortOrder
    monitorStandardErrors?: SortOrder
    standardErrorCodes?: SortOrder
    customStatusCodes?: SortOrder
    bodyErrorField?: SortOrder
    bodyErrorValues?: SortOrder
    headerErrorField?: SortOrder
    headerErrorValues?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifySms?: SortOrder
    notifyWebhook?: SortOrder
    cooldownMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiAlertAvgOrderByAggregateInput = {
    standardErrorCodes?: SortOrder
    customStatusCodes?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type ApiAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    isEnabled?: SortOrder
    monitorStandardErrors?: SortOrder
    bodyErrorField?: SortOrder
    headerErrorField?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifySms?: SortOrder
    notifyWebhook?: SortOrder
    cooldownMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiAlertMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    isEnabled?: SortOrder
    monitorStandardErrors?: SortOrder
    bodyErrorField?: SortOrder
    headerErrorField?: SortOrder
    notifyEmail?: SortOrder
    notifyPush?: SortOrder
    notifySms?: SortOrder
    notifyWebhook?: SortOrder
    cooldownMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiAlertSumOrderByAggregateInput = {
    standardErrorCodes?: SortOrder
    customStatusCodes?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type ApiAlertRelationFilter = {
    is?: ApiAlertWhereInput
    isNot?: ApiAlertWhereInput
  }

  export type MonitoredErrorCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    errorType?: SortOrder
    errorCode?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    firstOccurrence?: SortOrder
    lastOccurrence?: SortOrder
    occurrenceCount?: SortOrder
    affectedDevices?: SortOrder
    affectedSessions?: SortOrder
    lastTraceId?: SortOrder
    lastNotifiedAt?: SortOrder
    notificationCount?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredErrorAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    occurrenceCount?: SortOrder
    notificationCount?: SortOrder
  }

  export type MonitoredErrorMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    errorType?: SortOrder
    errorCode?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    firstOccurrence?: SortOrder
    lastOccurrence?: SortOrder
    occurrenceCount?: SortOrder
    lastTraceId?: SortOrder
    lastNotifiedAt?: SortOrder
    notificationCount?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredErrorMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    errorType?: SortOrder
    errorCode?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    firstOccurrence?: SortOrder
    lastOccurrence?: SortOrder
    occurrenceCount?: SortOrder
    lastTraceId?: SortOrder
    lastNotifiedAt?: SortOrder
    notificationCount?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonitoredErrorSumOrderByAggregateInput = {
    statusCode?: SortOrder
    occurrenceCount?: SortOrder
    notificationCount?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BusinessConfigProjectIdKeyCompoundUniqueInput = {
    projectId: string
    key: string
  }

  export type BusinessConfigCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    valueType?: SortOrder
    stringValue?: SortOrder
    integerValue?: SortOrder
    booleanValue?: SortOrder
    decimalValue?: SortOrder
    jsonValue?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    isEnabled?: SortOrder
    version?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessConfigAvgOrderByAggregateInput = {
    integerValue?: SortOrder
    decimalValue?: SortOrder
    version?: SortOrder
  }

  export type BusinessConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    valueType?: SortOrder
    stringValue?: SortOrder
    integerValue?: SortOrder
    booleanValue?: SortOrder
    decimalValue?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    isEnabled?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessConfigMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    valueType?: SortOrder
    stringValue?: SortOrder
    integerValue?: SortOrder
    booleanValue?: SortOrder
    decimalValue?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    isEnabled?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessConfigSumOrderByAggregateInput = {
    integerValue?: SortOrder
    decimalValue?: SortOrder
    version?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UploadedFileCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    storedName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadedFileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type UploadedFileMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    storedName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadedFileMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    storedName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadedFileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type TranslationListRelationFilter = {
    every?: TranslationWhereInput
    some?: TranslationWhereInput
    none?: TranslationWhereInput
  }

  export type TranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageProjectIdCodeCompoundUniqueInput = {
    projectId: string
    code: string
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    isRTL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    isRTL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    isRTL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalizationKeyProjectIdKeyCompoundUniqueInput = {
    projectId: string
    key: string
  }

  export type LocalizationKeyCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    maxLength?: SortOrder
    screenshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalizationKeyAvgOrderByAggregateInput = {
    maxLength?: SortOrder
  }

  export type LocalizationKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    maxLength?: SortOrder
    screenshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalizationKeyMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    maxLength?: SortOrder
    screenshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalizationKeySumOrderByAggregateInput = {
    maxLength?: SortOrder
  }

  export type LocalizationKeyRelationFilter = {
    is?: LocalizationKeyWhereInput
    isNot?: LocalizationKeyWhereInput
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type TranslationKeyIdLanguageIdCompoundUniqueInput = {
    keyId: string
    languageId: string
  }

  export type TranslationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    keyId?: SortOrder
    languageId?: SortOrder
    value?: SortOrder
    isReviewed?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    keyId?: SortOrder
    languageId?: SortOrder
    value?: SortOrder
    isReviewed?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    keyId?: SortOrder
    languageId?: SortOrder
    value?: SortOrder
    isReviewed?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sdkEnabled?: SortOrder
    apiTracking?: SortOrder
    screenTracking?: SortOrder
    crashReporting?: SortOrder
    logging?: SortOrder
    deviceTracking?: SortOrder
    sessionTracking?: SortOrder
    businessConfig?: SortOrder
    localization?: SortOrder
    offlineSupport?: SortOrder
    batchEvents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sdkEnabled?: SortOrder
    apiTracking?: SortOrder
    screenTracking?: SortOrder
    crashReporting?: SortOrder
    logging?: SortOrder
    deviceTracking?: SortOrder
    sessionTracking?: SortOrder
    businessConfig?: SortOrder
    localization?: SortOrder
    offlineSupport?: SortOrder
    batchEvents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sdkEnabled?: SortOrder
    apiTracking?: SortOrder
    screenTracking?: SortOrder
    crashReporting?: SortOrder
    logging?: SortOrder
    deviceTracking?: SortOrder
    sessionTracking?: SortOrder
    businessConfig?: SortOrder
    localization?: SortOrder
    offlineSupport?: SortOrder
    batchEvents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdkSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    trackingMode?: SortOrder
    captureRequestBodies?: SortOrder
    captureResponseBodies?: SortOrder
    capturePrintStatements?: SortOrder
    sanitizeSensitiveData?: SortOrder
    sensitiveFieldPatterns?: SortOrder
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
    enableBatching?: SortOrder
    minLogLevel?: SortOrder
    verboseErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdkSettingsAvgOrderByAggregateInput = {
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
  }

  export type SdkSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    trackingMode?: SortOrder
    captureRequestBodies?: SortOrder
    captureResponseBodies?: SortOrder
    capturePrintStatements?: SortOrder
    sanitizeSensitiveData?: SortOrder
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
    enableBatching?: SortOrder
    minLogLevel?: SortOrder
    verboseErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdkSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    trackingMode?: SortOrder
    captureRequestBodies?: SortOrder
    captureResponseBodies?: SortOrder
    capturePrintStatements?: SortOrder
    sanitizeSensitiveData?: SortOrder
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
    enableBatching?: SortOrder
    minLogLevel?: SortOrder
    verboseErrors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SdkSettingsSumOrderByAggregateInput = {
    maxLogQueueSize?: SortOrder
    maxTraceQueueSize?: SortOrder
    flushIntervalSeconds?: SortOrder
  }

  export type ConfigCategoryProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type ConfigCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ConfigCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    maxProjects?: SortOrder
    maxDevices?: SortOrder
    maxMockEndpoints?: SortOrder
    maxApiEndpoints?: SortOrder
    maxApiRequests?: SortOrder
    maxLogs?: SortOrder
    maxSessions?: SortOrder
    maxCrashes?: SortOrder
    maxBusinessConfigKeys?: SortOrder
    maxLocalizationLanguages?: SortOrder
    maxLocalizationKeys?: SortOrder
    retentionDays?: SortOrder
    allowApiTracking?: SortOrder
    allowScreenTracking?: SortOrder
    allowCrashReporting?: SortOrder
    allowLogging?: SortOrder
    allowBusinessConfig?: SortOrder
    allowLocalization?: SortOrder
    allowCustomDomains?: SortOrder
    allowWebhooks?: SortOrder
    allowTeamMembers?: SortOrder
    allowPrioritySupport?: SortOrder
    features?: SortOrder
    enforcementConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
    maxProjects?: SortOrder
    maxDevices?: SortOrder
    maxMockEndpoints?: SortOrder
    maxApiEndpoints?: SortOrder
    maxApiRequests?: SortOrder
    maxLogs?: SortOrder
    maxSessions?: SortOrder
    maxCrashes?: SortOrder
    maxBusinessConfigKeys?: SortOrder
    maxLocalizationLanguages?: SortOrder
    maxLocalizationKeys?: SortOrder
    retentionDays?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    maxProjects?: SortOrder
    maxDevices?: SortOrder
    maxMockEndpoints?: SortOrder
    maxApiEndpoints?: SortOrder
    maxApiRequests?: SortOrder
    maxLogs?: SortOrder
    maxSessions?: SortOrder
    maxCrashes?: SortOrder
    maxBusinessConfigKeys?: SortOrder
    maxLocalizationLanguages?: SortOrder
    maxLocalizationKeys?: SortOrder
    retentionDays?: SortOrder
    allowApiTracking?: SortOrder
    allowScreenTracking?: SortOrder
    allowCrashReporting?: SortOrder
    allowLogging?: SortOrder
    allowBusinessConfig?: SortOrder
    allowLocalization?: SortOrder
    allowCustomDomains?: SortOrder
    allowWebhooks?: SortOrder
    allowTeamMembers?: SortOrder
    allowPrioritySupport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    maxProjects?: SortOrder
    maxDevices?: SortOrder
    maxMockEndpoints?: SortOrder
    maxApiEndpoints?: SortOrder
    maxApiRequests?: SortOrder
    maxLogs?: SortOrder
    maxSessions?: SortOrder
    maxCrashes?: SortOrder
    maxBusinessConfigKeys?: SortOrder
    maxLocalizationLanguages?: SortOrder
    maxLocalizationKeys?: SortOrder
    retentionDays?: SortOrder
    allowApiTracking?: SortOrder
    allowScreenTracking?: SortOrder
    allowCrashReporting?: SortOrder
    allowLogging?: SortOrder
    allowBusinessConfig?: SortOrder
    allowLocalization?: SortOrder
    allowCustomDomains?: SortOrder
    allowWebhooks?: SortOrder
    allowTeamMembers?: SortOrder
    allowPrioritySupport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
    maxProjects?: SortOrder
    maxDevices?: SortOrder
    maxMockEndpoints?: SortOrder
    maxApiEndpoints?: SortOrder
    maxApiRequests?: SortOrder
    maxLogs?: SortOrder
    maxSessions?: SortOrder
    maxCrashes?: SortOrder
    maxBusinessConfigKeys?: SortOrder
    maxLocalizationLanguages?: SortOrder
    maxLocalizationKeys?: SortOrder
    retentionDays?: SortOrder
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type EnforcementStateNullableRelationFilter = {
    is?: EnforcementStateWhereInput | null
    isNot?: EnforcementStateWhereInput | null
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    trialStartDate?: SortOrder
    trialEndDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    disabledBy?: SortOrder
    disabledAt?: SortOrder
    enabledBy?: SortOrder
    enabledAt?: SortOrder
    quotaMaxProjects?: SortOrder
    quotaMaxDevices?: SortOrder
    quotaMaxMockEndpoints?: SortOrder
    quotaMaxApiEndpoints?: SortOrder
    quotaMaxApiRequests?: SortOrder
    quotaMaxLogs?: SortOrder
    quotaMaxSessions?: SortOrder
    quotaMaxCrashes?: SortOrder
    quotaMaxBusinessConfigKeys?: SortOrder
    quotaMaxLocalizationLanguages?: SortOrder
    quotaMaxLocalizationKeys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    quotaMaxProjects?: SortOrder
    quotaMaxDevices?: SortOrder
    quotaMaxMockEndpoints?: SortOrder
    quotaMaxApiEndpoints?: SortOrder
    quotaMaxApiRequests?: SortOrder
    quotaMaxLogs?: SortOrder
    quotaMaxSessions?: SortOrder
    quotaMaxCrashes?: SortOrder
    quotaMaxBusinessConfigKeys?: SortOrder
    quotaMaxLocalizationLanguages?: SortOrder
    quotaMaxLocalizationKeys?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    trialStartDate?: SortOrder
    trialEndDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    disabledBy?: SortOrder
    disabledAt?: SortOrder
    enabledBy?: SortOrder
    enabledAt?: SortOrder
    quotaMaxProjects?: SortOrder
    quotaMaxDevices?: SortOrder
    quotaMaxMockEndpoints?: SortOrder
    quotaMaxApiEndpoints?: SortOrder
    quotaMaxApiRequests?: SortOrder
    quotaMaxLogs?: SortOrder
    quotaMaxSessions?: SortOrder
    quotaMaxCrashes?: SortOrder
    quotaMaxBusinessConfigKeys?: SortOrder
    quotaMaxLocalizationLanguages?: SortOrder
    quotaMaxLocalizationKeys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    trialStartDate?: SortOrder
    trialEndDate?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    disabledBy?: SortOrder
    disabledAt?: SortOrder
    enabledBy?: SortOrder
    enabledAt?: SortOrder
    quotaMaxProjects?: SortOrder
    quotaMaxDevices?: SortOrder
    quotaMaxMockEndpoints?: SortOrder
    quotaMaxApiEndpoints?: SortOrder
    quotaMaxApiRequests?: SortOrder
    quotaMaxLogs?: SortOrder
    quotaMaxSessions?: SortOrder
    quotaMaxCrashes?: SortOrder
    quotaMaxBusinessConfigKeys?: SortOrder
    quotaMaxLocalizationLanguages?: SortOrder
    quotaMaxLocalizationKeys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    quotaMaxProjects?: SortOrder
    quotaMaxDevices?: SortOrder
    quotaMaxMockEndpoints?: SortOrder
    quotaMaxApiEndpoints?: SortOrder
    quotaMaxApiRequests?: SortOrder
    quotaMaxLogs?: SortOrder
    quotaMaxSessions?: SortOrder
    quotaMaxCrashes?: SortOrder
    quotaMaxBusinessConfigKeys?: SortOrder
    quotaMaxLocalizationLanguages?: SortOrder
    quotaMaxLocalizationKeys?: SortOrder
  }

  export type SubscriptionRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type EnforcementStateCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    state?: SortOrder
    warnEnteredAt?: SortOrder
    graceEnteredAt?: SortOrder
    graceEndsAt?: SortOrder
    degradedEnteredAt?: SortOrder
    effectivePolicy?: SortOrder
    triggeredMetrics?: SortOrder
    lastEvaluatedAt?: SortOrder
    nextEvaluationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnforcementStateMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    state?: SortOrder
    warnEnteredAt?: SortOrder
    graceEnteredAt?: SortOrder
    graceEndsAt?: SortOrder
    degradedEnteredAt?: SortOrder
    lastEvaluatedAt?: SortOrder
    nextEvaluationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnforcementStateMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    state?: SortOrder
    warnEnteredAt?: SortOrder
    graceEnteredAt?: SortOrder
    graceEndsAt?: SortOrder
    degradedEnteredAt?: SortOrder
    lastEvaluatedAt?: SortOrder
    nextEvaluationAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    pdfUrl?: SortOrder
    lineItems?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    pdfUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    pdfUrl?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BuildFeatureListRelationFilter = {
    every?: BuildFeatureWhereInput
    some?: BuildFeatureWhereInput
    none?: BuildFeatureWhereInput
  }

  export type BuildChangeLogListRelationFilter = {
    every?: BuildChangeLogWhereInput
    some?: BuildChangeLogWhereInput
    none?: BuildChangeLogWhereInput
  }

  export type BuildFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildProjectIdVersionCompoundUniqueInput = {
    projectId: string
    version: number
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mode?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    businessConfigSnapshot?: SortOrder
    localizationSnapshot?: SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
  }

  export type BuildAvgOrderByAggregateInput = {
    version?: SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mode?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mode?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
  }

  export type BuildSumOrderByAggregateInput = {
    version?: SortOrder
    configCount?: SortOrder
    translationCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BuildRelationFilter = {
    is?: BuildWhereInput
    isNot?: BuildWhereInput
  }

  export type BuildFeatureBuildIdFeatureTypeCompoundUniqueInput = {
    buildId: string
    featureType: string
  }

  export type BuildFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    snapshotData?: SortOrder
    itemCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BuildFeatureAvgOrderByAggregateInput = {
    itemCount?: SortOrder
  }

  export type BuildFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    itemCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BuildFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    itemCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BuildFeatureSumOrderByAggregateInput = {
    itemCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BuildNullableRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type BuildModeCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    previewBuildId?: SortOrder
    productionBuildId?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildModeMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    previewBuildId?: SortOrder
    productionBuildId?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildModeMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    previewBuildId?: SortOrder
    productionBuildId?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    changeType?: SortOrder
    itemKey?: SortOrder
    itemLabel?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type BuildChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    changeType?: SortOrder
    itemKey?: SortOrder
    itemLabel?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type BuildChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    featureType?: SortOrder
    changeType?: SortOrder
    itemKey?: SortOrder
    itemLabel?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type MockEndpointListRelationFilter = {
    every?: MockEndpointWhereInput
    some?: MockEndpointWhereInput
    none?: MockEndpointWhereInput
  }

  export type MockEndpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockEnvironmentProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type MockEnvironmentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePath?: SortOrder
    mode?: SortOrder
    whitelist?: SortOrder
    blacklist?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEnvironmentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePath?: SortOrder
    mode?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEnvironmentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePath?: SortOrder
    mode?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEnvironmentRelationFilter = {
    is?: MockEnvironmentWhereInput
    isNot?: MockEnvironmentWhereInput
  }

  export type MockResponseListRelationFilter = {
    every?: MockResponseWhereInput
    some?: MockResponseWhereInput
    none?: MockResponseWhereInput
  }

  export type MockConditionListRelationFilter = {
    every?: MockConditionWhereInput
    some?: MockConditionWhereInput
    none?: MockConditionWhereInput
  }

  export type MockResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockEndpointEnvironmentIdPathMethodCompoundUniqueInput = {
    environmentId: string
    path: string
    method: string
  }

  export type MockEndpointCountOrderByAggregateInput = {
    id?: SortOrder
    environmentId?: SortOrder
    path?: SortOrder
    method?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEndpointAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MockEndpointMaxOrderByAggregateInput = {
    id?: SortOrder
    environmentId?: SortOrder
    path?: SortOrder
    method?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEndpointMinOrderByAggregateInput = {
    id?: SortOrder
    environmentId?: SortOrder
    path?: SortOrder
    method?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockEndpointSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MockEndpointRelationFilter = {
    is?: MockEndpointWhereInput
    isNot?: MockEndpointWhereInput
  }

  export type MockResponseCountOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    statusCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    responseBody?: SortOrder
    responseHeaders?: SortOrder
    delay?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockResponseAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    delay?: SortOrder
    order?: SortOrder
  }

  export type MockResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    statusCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    delay?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockResponseMinOrderByAggregateInput = {
    id?: SortOrder
    endpointId?: SortOrder
    statusCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    delay?: SortOrder
    isDefault?: SortOrder
    isEnabled?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MockResponseSumOrderByAggregateInput = {
    statusCode?: SortOrder
    delay?: SortOrder
    order?: SortOrder
  }

  export type MockResponseNullableRelationFilter = {
    is?: MockResponseWhereInput | null
    isNot?: MockResponseWhereInput | null
  }

  export type MockEndpointNullableRelationFilter = {
    is?: MockEndpointWhereInput | null
    isNot?: MockEndpointWhereInput | null
  }

  export type MockConditionCountOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    endpointId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    isCaseSensitive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type MockConditionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MockConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    endpointId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    isCaseSensitive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type MockConditionMinOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    endpointId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    isCaseSensitive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type MockConditionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BusinessConfigNullableRelationFilter = {
    is?: BusinessConfigWhereInput | null
    isNot?: BusinessConfigWhereInput | null
  }

  export type ConfigAlertEventListRelationFilter = {
    every?: ConfigAlertEventWhereInput
    some?: ConfigAlertEventWhereInput
    none?: ConfigAlertEventWhereInput
  }

  export type ConfigAlertEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigAlertCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    operator?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    enabled?: SortOrder
    webhookUrl?: SortOrder
    emailRecipients?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    triggerCount?: SortOrder
  }

  export type ConfigAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    operator?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    enabled?: SortOrder
    webhookUrl?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigAlertMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    operator?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    enabled?: SortOrder
    webhookUrl?: SortOrder
    lastTriggered?: SortOrder
    triggerCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
    timeWindow?: SortOrder
    minOccurrences?: SortOrder
    triggerCount?: SortOrder
  }

  export type ConfigAlertRelationFilter = {
    is?: ConfigAlertWhereInput
    isNot?: ConfigAlertWhereInput
  }

  export type ConfigAlertEventCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigAlertEventMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigAlertEventMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    severity?: SortOrder
    message?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessConfigRelationFilter = {
    is?: BusinessConfigWhereInput
    isNot?: BusinessConfigWhereInput
  }

  export type ConfigApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    changeType?: SortOrder
    changeData?: SortOrder
    status?: SortOrder
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
    approvers?: SortOrder
    approvals?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    decidedBy?: SortOrder
    decidedAt?: SortOrder
    decisionComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigApprovalAvgOrderByAggregateInput = {
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
  }

  export type ConfigApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    changeType?: SortOrder
    status?: SortOrder
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    decidedBy?: SortOrder
    decidedAt?: SortOrder
    decisionComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    configId?: SortOrder
    changeType?: SortOrder
    status?: SortOrder
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
    requestedBy?: SortOrder
    requestedAt?: SortOrder
    decidedBy?: SortOrder
    decidedAt?: SortOrder
    decisionComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigApprovalSumOrderByAggregateInput = {
    requiredApprovals?: SortOrder
    currentApprovals?: SortOrder
  }

  export type SystemConfigurationCategoryKeyCompoundUniqueInput = {
    category: string
    key: string
  }

  export type SystemConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    encrypted?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    encrypted?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    encrypted?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput> | DeviceCreateWithoutProjectInput[] | DeviceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutProjectInput | DeviceCreateOrConnectWithoutProjectInput[]
    createMany?: DeviceCreateManyProjectInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type CrashCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput> | CrashCreateWithoutProjectInput[] | CrashUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutProjectInput | CrashCreateOrConnectWithoutProjectInput[]
    createMany?: CrashCreateManyProjectInputEnvelope
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
  }

  export type ApiTraceCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput> | ApiTraceCreateWithoutProjectInput[] | ApiTraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutProjectInput | ApiTraceCreateOrConnectWithoutProjectInput[]
    createMany?: ApiTraceCreateManyProjectInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type ApiConfigCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput> | ApiConfigCreateWithoutProjectInput[] | ApiConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiConfigCreateOrConnectWithoutProjectInput | ApiConfigCreateOrConnectWithoutProjectInput[]
    createMany?: ApiConfigCreateManyProjectInputEnvelope
    connect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutProjectInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedOneWithoutProjectInput = {
    create?: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutProjectInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type ApiAlertCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput> | ApiAlertCreateWithoutProjectInput[] | ApiAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiAlertCreateOrConnectWithoutProjectInput | ApiAlertCreateOrConnectWithoutProjectInput[]
    createMany?: ApiAlertCreateManyProjectInputEnvelope
    connect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
  }

  export type BuildCreateNestedManyWithoutProjectInput = {
    create?: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput> | BuildCreateWithoutProjectInput[] | BuildUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutProjectInput | BuildCreateOrConnectWithoutProjectInput[]
    createMany?: BuildCreateManyProjectInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildModeCreateNestedOneWithoutProjectInput = {
    create?: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProjectInput
    connect?: BuildModeWhereUniqueInput
  }

  export type MockEnvironmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput> | MockEnvironmentCreateWithoutProjectInput[] | MockEnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutProjectInput | MockEnvironmentCreateOrConnectWithoutProjectInput[]
    createMany?: MockEnvironmentCreateManyProjectInputEnvelope
    connect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
  }

  export type BusinessConfigCreateNestedManyWithoutProjectInput = {
    create?: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput> | BusinessConfigCreateWithoutProjectInput[] | BusinessConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutProjectInput | BusinessConfigCreateOrConnectWithoutProjectInput[]
    createMany?: BusinessConfigCreateManyProjectInputEnvelope
    connect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
  }

  export type ConfigAlertCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput> | ConfigAlertCreateWithoutProjectInput[] | ConfigAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutProjectInput | ConfigAlertCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigAlertCreateManyProjectInputEnvelope
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
  }

  export type ConfigApprovalCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput> | ConfigApprovalCreateWithoutProjectInput[] | ConfigApprovalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutProjectInput | ConfigApprovalCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigApprovalCreateManyProjectInputEnvelope
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
  }

  export type LanguageCreateNestedManyWithoutProjectInput = {
    create?: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput> | LanguageCreateWithoutProjectInput[] | LanguageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProjectInput | LanguageCreateOrConnectWithoutProjectInput[]
    createMany?: LanguageCreateManyProjectInputEnvelope
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type LocalizationKeyCreateNestedManyWithoutProjectInput = {
    create?: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput> | LocalizationKeyCreateWithoutProjectInput[] | LocalizationKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutProjectInput | LocalizationKeyCreateOrConnectWithoutProjectInput[]
    createMany?: LocalizationKeyCreateManyProjectInputEnvelope
    connect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
  }

  export type FeatureFlagsCreateNestedOneWithoutProjectInput = {
    create?: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: FeatureFlagsCreateOrConnectWithoutProjectInput
    connect?: FeatureFlagsWhereUniqueInput
  }

  export type SdkSettingsCreateNestedOneWithoutProjectInput = {
    create?: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SdkSettingsCreateOrConnectWithoutProjectInput
    connect?: SdkSettingsWhereUniqueInput
  }

  export type ConfigCategoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput> | ConfigCategoryCreateWithoutProjectInput[] | ConfigCategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigCategoryCreateOrConnectWithoutProjectInput | ConfigCategoryCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigCategoryCreateManyProjectInputEnvelope
    connect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput> | DeviceCreateWithoutProjectInput[] | DeviceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutProjectInput | DeviceCreateOrConnectWithoutProjectInput[]
    createMany?: DeviceCreateManyProjectInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type CrashUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput> | CrashCreateWithoutProjectInput[] | CrashUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutProjectInput | CrashCreateOrConnectWithoutProjectInput[]
    createMany?: CrashCreateManyProjectInputEnvelope
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
  }

  export type ApiTraceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput> | ApiTraceCreateWithoutProjectInput[] | ApiTraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutProjectInput | ApiTraceCreateOrConnectWithoutProjectInput[]
    createMany?: ApiTraceCreateManyProjectInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type ApiConfigUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput> | ApiConfigCreateWithoutProjectInput[] | ApiConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiConfigCreateOrConnectWithoutProjectInput | ApiConfigCreateOrConnectWithoutProjectInput[]
    createMany?: ApiConfigCreateManyProjectInputEnvelope
    connect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutProjectInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type ApiAlertUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput> | ApiAlertCreateWithoutProjectInput[] | ApiAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiAlertCreateOrConnectWithoutProjectInput | ApiAlertCreateOrConnectWithoutProjectInput[]
    createMany?: ApiAlertCreateManyProjectInputEnvelope
    connect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput> | BuildCreateWithoutProjectInput[] | BuildUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutProjectInput | BuildCreateOrConnectWithoutProjectInput[]
    createMany?: BuildCreateManyProjectInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildModeUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProjectInput
    connect?: BuildModeWhereUniqueInput
  }

  export type MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput> | MockEnvironmentCreateWithoutProjectInput[] | MockEnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutProjectInput | MockEnvironmentCreateOrConnectWithoutProjectInput[]
    createMany?: MockEnvironmentCreateManyProjectInputEnvelope
    connect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
  }

  export type BusinessConfigUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput> | BusinessConfigCreateWithoutProjectInput[] | BusinessConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutProjectInput | BusinessConfigCreateOrConnectWithoutProjectInput[]
    createMany?: BusinessConfigCreateManyProjectInputEnvelope
    connect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
  }

  export type ConfigAlertUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput> | ConfigAlertCreateWithoutProjectInput[] | ConfigAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutProjectInput | ConfigAlertCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigAlertCreateManyProjectInputEnvelope
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
  }

  export type ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput> | ConfigApprovalCreateWithoutProjectInput[] | ConfigApprovalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutProjectInput | ConfigApprovalCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigApprovalCreateManyProjectInputEnvelope
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
  }

  export type LanguageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput> | LanguageCreateWithoutProjectInput[] | LanguageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProjectInput | LanguageCreateOrConnectWithoutProjectInput[]
    createMany?: LanguageCreateManyProjectInputEnvelope
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput> | LocalizationKeyCreateWithoutProjectInput[] | LocalizationKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutProjectInput | LocalizationKeyCreateOrConnectWithoutProjectInput[]
    createMany?: LocalizationKeyCreateManyProjectInputEnvelope
    connect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
  }

  export type FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: FeatureFlagsCreateOrConnectWithoutProjectInput
    connect?: FeatureFlagsWhereUniqueInput
  }

  export type SdkSettingsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SdkSettingsCreateOrConnectWithoutProjectInput
    connect?: SdkSettingsWhereUniqueInput
  }

  export type ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput> | ConfigCategoryCreateWithoutProjectInput[] | ConfigCategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigCategoryCreateOrConnectWithoutProjectInput | ConfigCategoryCreateOrConnectWithoutProjectInput[]
    createMany?: ConfigCategoryCreateManyProjectInputEnvelope
    connect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type DeviceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput> | DeviceCreateWithoutProjectInput[] | DeviceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutProjectInput | DeviceCreateOrConnectWithoutProjectInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutProjectInput | DeviceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeviceCreateManyProjectInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutProjectInput | DeviceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutProjectInput | DeviceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type LogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutProjectInput | LogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutProjectInput | LogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogUpdateManyWithWhereWithoutProjectInput | LogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type CrashUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput> | CrashCreateWithoutProjectInput[] | CrashUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutProjectInput | CrashCreateOrConnectWithoutProjectInput[]
    upsert?: CrashUpsertWithWhereUniqueWithoutProjectInput | CrashUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrashCreateManyProjectInputEnvelope
    set?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    disconnect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    delete?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    update?: CrashUpdateWithWhereUniqueWithoutProjectInput | CrashUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrashUpdateManyWithWhereWithoutProjectInput | CrashUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrashScalarWhereInput | CrashScalarWhereInput[]
  }

  export type ApiTraceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput> | ApiTraceCreateWithoutProjectInput[] | ApiTraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutProjectInput | ApiTraceCreateOrConnectWithoutProjectInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutProjectInput | ApiTraceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiTraceCreateManyProjectInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutProjectInput | ApiTraceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutProjectInput | ApiTraceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type ApiConfigUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput> | ApiConfigCreateWithoutProjectInput[] | ApiConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiConfigCreateOrConnectWithoutProjectInput | ApiConfigCreateOrConnectWithoutProjectInput[]
    upsert?: ApiConfigUpsertWithWhereUniqueWithoutProjectInput | ApiConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiConfigCreateManyProjectInputEnvelope
    set?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    disconnect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    delete?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    connect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    update?: ApiConfigUpdateWithWhereUniqueWithoutProjectInput | ApiConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiConfigUpdateManyWithWhereWithoutProjectInput | ApiConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiConfigScalarWhereInput | ApiConfigScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProjectInput | SessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProjectInput | SessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProjectInput | SessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationSettingsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutProjectInput
    upsert?: NotificationSettingsUpsertWithoutProjectInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutProjectInput, NotificationSettingsUpdateWithoutProjectInput>, NotificationSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type ApiAlertUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput> | ApiAlertCreateWithoutProjectInput[] | ApiAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiAlertCreateOrConnectWithoutProjectInput | ApiAlertCreateOrConnectWithoutProjectInput[]
    upsert?: ApiAlertUpsertWithWhereUniqueWithoutProjectInput | ApiAlertUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiAlertCreateManyProjectInputEnvelope
    set?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    disconnect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    delete?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    connect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    update?: ApiAlertUpdateWithWhereUniqueWithoutProjectInput | ApiAlertUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiAlertUpdateManyWithWhereWithoutProjectInput | ApiAlertUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiAlertScalarWhereInput | ApiAlertScalarWhereInput[]
  }

  export type BuildUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput> | BuildCreateWithoutProjectInput[] | BuildUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutProjectInput | BuildCreateOrConnectWithoutProjectInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutProjectInput | BuildUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BuildCreateManyProjectInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutProjectInput | BuildUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutProjectInput | BuildUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildModeUpdateOneWithoutProjectNestedInput = {
    create?: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProjectInput
    upsert?: BuildModeUpsertWithoutProjectInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutProjectInput, BuildModeUpdateWithoutProjectInput>, BuildModeUncheckedUpdateWithoutProjectInput>
  }

  export type MockEnvironmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput> | MockEnvironmentCreateWithoutProjectInput[] | MockEnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutProjectInput | MockEnvironmentCreateOrConnectWithoutProjectInput[]
    upsert?: MockEnvironmentUpsertWithWhereUniqueWithoutProjectInput | MockEnvironmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MockEnvironmentCreateManyProjectInputEnvelope
    set?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    disconnect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    delete?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    connect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    update?: MockEnvironmentUpdateWithWhereUniqueWithoutProjectInput | MockEnvironmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MockEnvironmentUpdateManyWithWhereWithoutProjectInput | MockEnvironmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MockEnvironmentScalarWhereInput | MockEnvironmentScalarWhereInput[]
  }

  export type BusinessConfigUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput> | BusinessConfigCreateWithoutProjectInput[] | BusinessConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutProjectInput | BusinessConfigCreateOrConnectWithoutProjectInput[]
    upsert?: BusinessConfigUpsertWithWhereUniqueWithoutProjectInput | BusinessConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BusinessConfigCreateManyProjectInputEnvelope
    set?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    disconnect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    delete?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    connect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    update?: BusinessConfigUpdateWithWhereUniqueWithoutProjectInput | BusinessConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BusinessConfigUpdateManyWithWhereWithoutProjectInput | BusinessConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BusinessConfigScalarWhereInput | BusinessConfigScalarWhereInput[]
  }

  export type ConfigAlertUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput> | ConfigAlertCreateWithoutProjectInput[] | ConfigAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutProjectInput | ConfigAlertCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigAlertUpsertWithWhereUniqueWithoutProjectInput | ConfigAlertUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigAlertCreateManyProjectInputEnvelope
    set?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    disconnect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    delete?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    update?: ConfigAlertUpdateWithWhereUniqueWithoutProjectInput | ConfigAlertUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigAlertUpdateManyWithWhereWithoutProjectInput | ConfigAlertUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
  }

  export type ConfigApprovalUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput> | ConfigApprovalCreateWithoutProjectInput[] | ConfigApprovalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutProjectInput | ConfigApprovalCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigApprovalUpsertWithWhereUniqueWithoutProjectInput | ConfigApprovalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigApprovalCreateManyProjectInputEnvelope
    set?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    disconnect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    delete?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    update?: ConfigApprovalUpdateWithWhereUniqueWithoutProjectInput | ConfigApprovalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigApprovalUpdateManyWithWhereWithoutProjectInput | ConfigApprovalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
  }

  export type LanguageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput> | LanguageCreateWithoutProjectInput[] | LanguageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProjectInput | LanguageCreateOrConnectWithoutProjectInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutProjectInput | LanguageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LanguageCreateManyProjectInputEnvelope
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutProjectInput | LanguageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutProjectInput | LanguageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type LocalizationKeyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput> | LocalizationKeyCreateWithoutProjectInput[] | LocalizationKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutProjectInput | LocalizationKeyCreateOrConnectWithoutProjectInput[]
    upsert?: LocalizationKeyUpsertWithWhereUniqueWithoutProjectInput | LocalizationKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LocalizationKeyCreateManyProjectInputEnvelope
    set?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    disconnect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    delete?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    connect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    update?: LocalizationKeyUpdateWithWhereUniqueWithoutProjectInput | LocalizationKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LocalizationKeyUpdateManyWithWhereWithoutProjectInput | LocalizationKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LocalizationKeyScalarWhereInput | LocalizationKeyScalarWhereInput[]
  }

  export type FeatureFlagsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: FeatureFlagsCreateOrConnectWithoutProjectInput
    upsert?: FeatureFlagsUpsertWithoutProjectInput
    disconnect?: FeatureFlagsWhereInput | boolean
    delete?: FeatureFlagsWhereInput | boolean
    connect?: FeatureFlagsWhereUniqueInput
    update?: XOR<XOR<FeatureFlagsUpdateToOneWithWhereWithoutProjectInput, FeatureFlagsUpdateWithoutProjectInput>, FeatureFlagsUncheckedUpdateWithoutProjectInput>
  }

  export type SdkSettingsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SdkSettingsCreateOrConnectWithoutProjectInput
    upsert?: SdkSettingsUpsertWithoutProjectInput
    disconnect?: SdkSettingsWhereInput | boolean
    delete?: SdkSettingsWhereInput | boolean
    connect?: SdkSettingsWhereUniqueInput
    update?: XOR<XOR<SdkSettingsUpdateToOneWithWhereWithoutProjectInput, SdkSettingsUpdateWithoutProjectInput>, SdkSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type ConfigCategoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput> | ConfigCategoryCreateWithoutProjectInput[] | ConfigCategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigCategoryCreateOrConnectWithoutProjectInput | ConfigCategoryCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigCategoryUpsertWithWhereUniqueWithoutProjectInput | ConfigCategoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigCategoryCreateManyProjectInputEnvelope
    set?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    disconnect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    delete?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    connect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    update?: ConfigCategoryUpdateWithWhereUniqueWithoutProjectInput | ConfigCategoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigCategoryUpdateManyWithWhereWithoutProjectInput | ConfigCategoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigCategoryScalarWhereInput | ConfigCategoryScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput> | DeviceCreateWithoutProjectInput[] | DeviceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutProjectInput | DeviceCreateOrConnectWithoutProjectInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutProjectInput | DeviceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeviceCreateManyProjectInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutProjectInput | DeviceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutProjectInput | DeviceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput> | LogCreateWithoutProjectInput[] | LogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogCreateOrConnectWithoutProjectInput | LogCreateOrConnectWithoutProjectInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutProjectInput | LogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogCreateManyProjectInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutProjectInput | LogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogUpdateManyWithWhereWithoutProjectInput | LogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type CrashUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput> | CrashCreateWithoutProjectInput[] | CrashUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutProjectInput | CrashCreateOrConnectWithoutProjectInput[]
    upsert?: CrashUpsertWithWhereUniqueWithoutProjectInput | CrashUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CrashCreateManyProjectInputEnvelope
    set?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    disconnect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    delete?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    update?: CrashUpdateWithWhereUniqueWithoutProjectInput | CrashUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CrashUpdateManyWithWhereWithoutProjectInput | CrashUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CrashScalarWhereInput | CrashScalarWhereInput[]
  }

  export type ApiTraceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput> | ApiTraceCreateWithoutProjectInput[] | ApiTraceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutProjectInput | ApiTraceCreateOrConnectWithoutProjectInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutProjectInput | ApiTraceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiTraceCreateManyProjectInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutProjectInput | ApiTraceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutProjectInput | ApiTraceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type ApiConfigUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput> | ApiConfigCreateWithoutProjectInput[] | ApiConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiConfigCreateOrConnectWithoutProjectInput | ApiConfigCreateOrConnectWithoutProjectInput[]
    upsert?: ApiConfigUpsertWithWhereUniqueWithoutProjectInput | ApiConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiConfigCreateManyProjectInputEnvelope
    set?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    disconnect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    delete?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    connect?: ApiConfigWhereUniqueInput | ApiConfigWhereUniqueInput[]
    update?: ApiConfigUpdateWithWhereUniqueWithoutProjectInput | ApiConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiConfigUpdateManyWithWhereWithoutProjectInput | ApiConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiConfigScalarWhereInput | ApiConfigScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProjectInput | SessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProjectInput | SessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProjectInput | SessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutProjectInput
    upsert?: NotificationSettingsUpsertWithoutProjectInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutProjectInput, NotificationSettingsUpdateWithoutProjectInput>, NotificationSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type ApiAlertUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput> | ApiAlertCreateWithoutProjectInput[] | ApiAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiAlertCreateOrConnectWithoutProjectInput | ApiAlertCreateOrConnectWithoutProjectInput[]
    upsert?: ApiAlertUpsertWithWhereUniqueWithoutProjectInput | ApiAlertUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiAlertCreateManyProjectInputEnvelope
    set?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    disconnect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    delete?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    connect?: ApiAlertWhereUniqueInput | ApiAlertWhereUniqueInput[]
    update?: ApiAlertUpdateWithWhereUniqueWithoutProjectInput | ApiAlertUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiAlertUpdateManyWithWhereWithoutProjectInput | ApiAlertUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiAlertScalarWhereInput | ApiAlertScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput> | BuildCreateWithoutProjectInput[] | BuildUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutProjectInput | BuildCreateOrConnectWithoutProjectInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutProjectInput | BuildUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BuildCreateManyProjectInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutProjectInput | BuildUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutProjectInput | BuildUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildModeUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProjectInput
    upsert?: BuildModeUpsertWithoutProjectInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutProjectInput, BuildModeUpdateWithoutProjectInput>, BuildModeUncheckedUpdateWithoutProjectInput>
  }

  export type MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput> | MockEnvironmentCreateWithoutProjectInput[] | MockEnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutProjectInput | MockEnvironmentCreateOrConnectWithoutProjectInput[]
    upsert?: MockEnvironmentUpsertWithWhereUniqueWithoutProjectInput | MockEnvironmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MockEnvironmentCreateManyProjectInputEnvelope
    set?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    disconnect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    delete?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    connect?: MockEnvironmentWhereUniqueInput | MockEnvironmentWhereUniqueInput[]
    update?: MockEnvironmentUpdateWithWhereUniqueWithoutProjectInput | MockEnvironmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MockEnvironmentUpdateManyWithWhereWithoutProjectInput | MockEnvironmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MockEnvironmentScalarWhereInput | MockEnvironmentScalarWhereInput[]
  }

  export type BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput> | BusinessConfigCreateWithoutProjectInput[] | BusinessConfigUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutProjectInput | BusinessConfigCreateOrConnectWithoutProjectInput[]
    upsert?: BusinessConfigUpsertWithWhereUniqueWithoutProjectInput | BusinessConfigUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BusinessConfigCreateManyProjectInputEnvelope
    set?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    disconnect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    delete?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    connect?: BusinessConfigWhereUniqueInput | BusinessConfigWhereUniqueInput[]
    update?: BusinessConfigUpdateWithWhereUniqueWithoutProjectInput | BusinessConfigUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BusinessConfigUpdateManyWithWhereWithoutProjectInput | BusinessConfigUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BusinessConfigScalarWhereInput | BusinessConfigScalarWhereInput[]
  }

  export type ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput> | ConfigAlertCreateWithoutProjectInput[] | ConfigAlertUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutProjectInput | ConfigAlertCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigAlertUpsertWithWhereUniqueWithoutProjectInput | ConfigAlertUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigAlertCreateManyProjectInputEnvelope
    set?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    disconnect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    delete?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    update?: ConfigAlertUpdateWithWhereUniqueWithoutProjectInput | ConfigAlertUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigAlertUpdateManyWithWhereWithoutProjectInput | ConfigAlertUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
  }

  export type ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput> | ConfigApprovalCreateWithoutProjectInput[] | ConfigApprovalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutProjectInput | ConfigApprovalCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigApprovalUpsertWithWhereUniqueWithoutProjectInput | ConfigApprovalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigApprovalCreateManyProjectInputEnvelope
    set?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    disconnect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    delete?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    update?: ConfigApprovalUpdateWithWhereUniqueWithoutProjectInput | ConfigApprovalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigApprovalUpdateManyWithWhereWithoutProjectInput | ConfigApprovalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
  }

  export type LanguageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput> | LanguageCreateWithoutProjectInput[] | LanguageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProjectInput | LanguageCreateOrConnectWithoutProjectInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutProjectInput | LanguageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LanguageCreateManyProjectInputEnvelope
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutProjectInput | LanguageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutProjectInput | LanguageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput> | LocalizationKeyCreateWithoutProjectInput[] | LocalizationKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutProjectInput | LocalizationKeyCreateOrConnectWithoutProjectInput[]
    upsert?: LocalizationKeyUpsertWithWhereUniqueWithoutProjectInput | LocalizationKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LocalizationKeyCreateManyProjectInputEnvelope
    set?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    disconnect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    delete?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    connect?: LocalizationKeyWhereUniqueInput | LocalizationKeyWhereUniqueInput[]
    update?: LocalizationKeyUpdateWithWhereUniqueWithoutProjectInput | LocalizationKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LocalizationKeyUpdateManyWithWhereWithoutProjectInput | LocalizationKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LocalizationKeyScalarWhereInput | LocalizationKeyScalarWhereInput[]
  }

  export type FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: FeatureFlagsCreateOrConnectWithoutProjectInput
    upsert?: FeatureFlagsUpsertWithoutProjectInput
    disconnect?: FeatureFlagsWhereInput | boolean
    delete?: FeatureFlagsWhereInput | boolean
    connect?: FeatureFlagsWhereUniqueInput
    update?: XOR<XOR<FeatureFlagsUpdateToOneWithWhereWithoutProjectInput, FeatureFlagsUpdateWithoutProjectInput>, FeatureFlagsUncheckedUpdateWithoutProjectInput>
  }

  export type SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SdkSettingsCreateOrConnectWithoutProjectInput
    upsert?: SdkSettingsUpsertWithoutProjectInput
    disconnect?: SdkSettingsWhereInput | boolean
    delete?: SdkSettingsWhereInput | boolean
    connect?: SdkSettingsWhereUniqueInput
    update?: XOR<XOR<SdkSettingsUpdateToOneWithWhereWithoutProjectInput, SdkSettingsUpdateWithoutProjectInput>, SdkSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput> | ConfigCategoryCreateWithoutProjectInput[] | ConfigCategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConfigCategoryCreateOrConnectWithoutProjectInput | ConfigCategoryCreateOrConnectWithoutProjectInput[]
    upsert?: ConfigCategoryUpsertWithWhereUniqueWithoutProjectInput | ConfigCategoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConfigCategoryCreateManyProjectInputEnvelope
    set?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    disconnect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    delete?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    connect?: ConfigCategoryWhereUniqueInput | ConfigCategoryWhereUniqueInput[]
    update?: ConfigCategoryUpdateWithWhereUniqueWithoutProjectInput | ConfigCategoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConfigCategoryUpdateManyWithWhereWithoutProjectInput | ConfigCategoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConfigCategoryScalarWhereInput | ConfigCategoryScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutDevicesInput = {
    create?: XOR<ProjectCreateWithoutDevicesInput, ProjectUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDevicesInput
    connect?: ProjectWhereUniqueInput
  }

  export type LogCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type CrashCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput> | CrashCreateWithoutDeviceInput[] | CrashUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutDeviceInput | CrashCreateOrConnectWithoutDeviceInput[]
    createMany?: CrashCreateManyDeviceInputEnvelope
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
  }

  export type ApiTraceCreateNestedManyWithoutDeviceInput = {
    create?: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput> | ApiTraceCreateWithoutDeviceInput[] | ApiTraceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutDeviceInput | ApiTraceCreateOrConnectWithoutDeviceInput[]
    createMany?: ApiTraceCreateManyDeviceInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput> | SessionCreateWithoutDeviceInput[] | SessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDeviceInput | SessionCreateOrConnectWithoutDeviceInput[]
    createMany?: SessionCreateManyDeviceInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type CrashUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput> | CrashCreateWithoutDeviceInput[] | CrashUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutDeviceInput | CrashCreateOrConnectWithoutDeviceInput[]
    createMany?: CrashCreateManyDeviceInputEnvelope
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
  }

  export type ApiTraceUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput> | ApiTraceCreateWithoutDeviceInput[] | ApiTraceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutDeviceInput | ApiTraceCreateOrConnectWithoutDeviceInput[]
    createMany?: ApiTraceCreateManyDeviceInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput> | SessionCreateWithoutDeviceInput[] | SessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDeviceInput | SessionCreateOrConnectWithoutDeviceInput[]
    createMany?: SessionCreateManyDeviceInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdateOneWithoutDevicesNestedInput = {
    create?: XOR<ProjectCreateWithoutDevicesInput, ProjectUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDevicesInput
    upsert?: ProjectUpsertWithoutDevicesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDevicesInput, ProjectUpdateWithoutDevicesInput>, ProjectUncheckedUpdateWithoutDevicesInput>
  }

  export type LogUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutDeviceInput | LogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutDeviceInput | LogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LogUpdateManyWithWhereWithoutDeviceInput | LogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type CrashUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput> | CrashCreateWithoutDeviceInput[] | CrashUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutDeviceInput | CrashCreateOrConnectWithoutDeviceInput[]
    upsert?: CrashUpsertWithWhereUniqueWithoutDeviceInput | CrashUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CrashCreateManyDeviceInputEnvelope
    set?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    disconnect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    delete?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    update?: CrashUpdateWithWhereUniqueWithoutDeviceInput | CrashUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CrashUpdateManyWithWhereWithoutDeviceInput | CrashUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CrashScalarWhereInput | CrashScalarWhereInput[]
  }

  export type ApiTraceUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput> | ApiTraceCreateWithoutDeviceInput[] | ApiTraceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutDeviceInput | ApiTraceCreateOrConnectWithoutDeviceInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutDeviceInput | ApiTraceUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: ApiTraceCreateManyDeviceInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutDeviceInput | ApiTraceUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutDeviceInput | ApiTraceUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput> | SessionCreateWithoutDeviceInput[] | SessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDeviceInput | SessionCreateOrConnectWithoutDeviceInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutDeviceInput | SessionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SessionCreateManyDeviceInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutDeviceInput | SessionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutDeviceInput | SessionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput> | LogCreateWithoutDeviceInput[] | LogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: LogCreateOrConnectWithoutDeviceInput | LogCreateOrConnectWithoutDeviceInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutDeviceInput | LogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: LogCreateManyDeviceInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutDeviceInput | LogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: LogUpdateManyWithWhereWithoutDeviceInput | LogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type CrashUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput> | CrashCreateWithoutDeviceInput[] | CrashUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CrashCreateOrConnectWithoutDeviceInput | CrashCreateOrConnectWithoutDeviceInput[]
    upsert?: CrashUpsertWithWhereUniqueWithoutDeviceInput | CrashUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CrashCreateManyDeviceInputEnvelope
    set?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    disconnect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    delete?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    connect?: CrashWhereUniqueInput | CrashWhereUniqueInput[]
    update?: CrashUpdateWithWhereUniqueWithoutDeviceInput | CrashUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CrashUpdateManyWithWhereWithoutDeviceInput | CrashUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CrashScalarWhereInput | CrashScalarWhereInput[]
  }

  export type ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput> | ApiTraceCreateWithoutDeviceInput[] | ApiTraceUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutDeviceInput | ApiTraceCreateOrConnectWithoutDeviceInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutDeviceInput | ApiTraceUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: ApiTraceCreateManyDeviceInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutDeviceInput | ApiTraceUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutDeviceInput | ApiTraceUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput> | SessionCreateWithoutDeviceInput[] | SessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutDeviceInput | SessionCreateOrConnectWithoutDeviceInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutDeviceInput | SessionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SessionCreateManyDeviceInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutDeviceInput | SessionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutDeviceInput | SessionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutLogsInput = {
    create?: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutLogsInput = {
    create?: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLogsInput
    connect?: DeviceWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutLogsInput = {
    create?: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutLogsInput
    connect?: SessionWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogsInput
    upsert?: ProjectUpsertWithoutLogsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLogsInput, ProjectUpdateWithoutLogsInput>, ProjectUncheckedUpdateWithoutLogsInput>
  }

  export type DeviceUpdateOneWithoutLogsNestedInput = {
    create?: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutLogsInput
    upsert?: DeviceUpsertWithoutLogsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutLogsInput, DeviceUpdateWithoutLogsInput>, DeviceUncheckedUpdateWithoutLogsInput>
  }

  export type SessionUpdateOneWithoutLogsNestedInput = {
    create?: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutLogsInput
    upsert?: SessionUpsertWithoutLogsInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutLogsInput, SessionUpdateWithoutLogsInput>, SessionUncheckedUpdateWithoutLogsInput>
  }

  export type ProjectCreateNestedOneWithoutCrashesInput = {
    create?: XOR<ProjectCreateWithoutCrashesInput, ProjectUncheckedCreateWithoutCrashesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrashesInput
    connect?: ProjectWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutCrashesInput = {
    create?: XOR<DeviceCreateWithoutCrashesInput, DeviceUncheckedCreateWithoutCrashesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCrashesInput
    connect?: DeviceWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCrashesNestedInput = {
    create?: XOR<ProjectCreateWithoutCrashesInput, ProjectUncheckedCreateWithoutCrashesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCrashesInput
    upsert?: ProjectUpsertWithoutCrashesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCrashesInput, ProjectUpdateWithoutCrashesInput>, ProjectUncheckedUpdateWithoutCrashesInput>
  }

  export type DeviceUpdateOneWithoutCrashesNestedInput = {
    create?: XOR<DeviceCreateWithoutCrashesInput, DeviceUncheckedCreateWithoutCrashesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCrashesInput
    upsert?: DeviceUpsertWithoutCrashesInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutCrashesInput, DeviceUpdateWithoutCrashesInput>, DeviceUncheckedUpdateWithoutCrashesInput>
  }

  export type ProjectCreateNestedOneWithoutApiTracesInput = {
    create?: XOR<ProjectCreateWithoutApiTracesInput, ProjectUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiTracesInput
    connect?: ProjectWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutApiTracesInput = {
    create?: XOR<DeviceCreateWithoutApiTracesInput, DeviceUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutApiTracesInput
    connect?: DeviceWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutApiTracesInput = {
    create?: XOR<SessionCreateWithoutApiTracesInput, SessionUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutApiTracesInput
    connect?: SessionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutApiTracesNestedInput = {
    create?: XOR<ProjectCreateWithoutApiTracesInput, ProjectUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiTracesInput
    upsert?: ProjectUpsertWithoutApiTracesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiTracesInput, ProjectUpdateWithoutApiTracesInput>, ProjectUncheckedUpdateWithoutApiTracesInput>
  }

  export type DeviceUpdateOneWithoutApiTracesNestedInput = {
    create?: XOR<DeviceCreateWithoutApiTracesInput, DeviceUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutApiTracesInput
    upsert?: DeviceUpsertWithoutApiTracesInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutApiTracesInput, DeviceUpdateWithoutApiTracesInput>, DeviceUncheckedUpdateWithoutApiTracesInput>
  }

  export type SessionUpdateOneWithoutApiTracesNestedInput = {
    create?: XOR<SessionCreateWithoutApiTracesInput, SessionUncheckedCreateWithoutApiTracesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutApiTracesInput
    upsert?: SessionUpsertWithoutApiTracesInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutApiTracesInput, SessionUpdateWithoutApiTracesInput>, SessionUncheckedUpdateWithoutApiTracesInput>
  }

  export type ProjectCreateNestedOneWithoutApiConfigsInput = {
    create?: XOR<ProjectCreateWithoutApiConfigsInput, ProjectUncheckedCreateWithoutApiConfigsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiConfigsInput
    connect?: ProjectWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutApiConfigsNestedInput = {
    create?: XOR<ProjectCreateWithoutApiConfigsInput, ProjectUncheckedCreateWithoutApiConfigsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiConfigsInput
    upsert?: ProjectUpsertWithoutApiConfigsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiConfigsInput, ProjectUpdateWithoutApiConfigsInput>, ProjectUncheckedUpdateWithoutApiConfigsInput>
  }

  export type SessionCreatescreenFlowInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutSessionsInput = {
    create?: XOR<DeviceCreateWithoutSessionsInput, DeviceUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSessionsInput
    connect?: DeviceWhereUniqueInput
  }

  export type ApiTraceCreateNestedManyWithoutSessionInput = {
    create?: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput> | ApiTraceCreateWithoutSessionInput[] | ApiTraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutSessionInput | ApiTraceCreateOrConnectWithoutSessionInput[]
    createMany?: ApiTraceCreateManySessionInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutSessionInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type ApiTraceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput> | ApiTraceCreateWithoutSessionInput[] | ApiTraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutSessionInput | ApiTraceCreateOrConnectWithoutSessionInput[]
    createMany?: ApiTraceCreateManySessionInputEnvelope
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type SessionUpdatescreenFlowInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    upsert?: ProjectUpsertWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSessionsInput, ProjectUpdateWithoutSessionsInput>, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type DeviceUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<DeviceCreateWithoutSessionsInput, DeviceUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSessionsInput
    upsert?: DeviceUpsertWithoutSessionsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutSessionsInput, DeviceUpdateWithoutSessionsInput>, DeviceUncheckedUpdateWithoutSessionsInput>
  }

  export type ApiTraceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput> | ApiTraceCreateWithoutSessionInput[] | ApiTraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutSessionInput | ApiTraceCreateOrConnectWithoutSessionInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutSessionInput | ApiTraceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ApiTraceCreateManySessionInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutSessionInput | ApiTraceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutSessionInput | ApiTraceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type LogUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutSessionInput | LogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutSessionInput | LogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LogUpdateManyWithWhereWithoutSessionInput | LogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type ApiTraceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput> | ApiTraceCreateWithoutSessionInput[] | ApiTraceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ApiTraceCreateOrConnectWithoutSessionInput | ApiTraceCreateOrConnectWithoutSessionInput[]
    upsert?: ApiTraceUpsertWithWhereUniqueWithoutSessionInput | ApiTraceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ApiTraceCreateManySessionInputEnvelope
    set?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    disconnect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    delete?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    connect?: ApiTraceWhereUniqueInput | ApiTraceWhereUniqueInput[]
    update?: ApiTraceUpdateWithWhereUniqueWithoutSessionInput | ApiTraceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ApiTraceUpdateManyWithWhereWithoutSessionInput | ApiTraceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput> | LogCreateWithoutSessionInput[] | LogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: LogCreateOrConnectWithoutSessionInput | LogCreateOrConnectWithoutSessionInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutSessionInput | LogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: LogCreateManySessionInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutSessionInput | LogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: LogUpdateManyWithWhereWithoutSessionInput | LogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type NotificationSettingsCreateemailAddressesInput = {
    set: string[]
  }

  export type NotificationSettingsCreatesmsNumbersInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<ProjectCreateWithoutNotificationSettingsInput, ProjectUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationSettingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type NotificationSettingsUpdateemailAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationSettingsUpdatesmsNumbersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<ProjectCreateWithoutNotificationSettingsInput, ProjectUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationSettingsInput
    upsert?: ProjectUpsertWithoutNotificationSettingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutNotificationSettingsInput, ProjectUpdateWithoutNotificationSettingsInput>, ProjectUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type ApiAlertCreatestandardErrorCodesInput = {
    set: number[]
  }

  export type ApiAlertCreatecustomStatusCodesInput = {
    set: number[]
  }

  export type ApiAlertCreatebodyErrorValuesInput = {
    set: string[]
  }

  export type ApiAlertCreateheaderErrorValuesInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutApiAlertsInput = {
    create?: XOR<ProjectCreateWithoutApiAlertsInput, ProjectUncheckedCreateWithoutApiAlertsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiAlertsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MonitoredErrorCreateNestedManyWithoutAlertInput = {
    create?: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput> | MonitoredErrorCreateWithoutAlertInput[] | MonitoredErrorUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: MonitoredErrorCreateOrConnectWithoutAlertInput | MonitoredErrorCreateOrConnectWithoutAlertInput[]
    createMany?: MonitoredErrorCreateManyAlertInputEnvelope
    connect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
  }

  export type MonitoredErrorUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput> | MonitoredErrorCreateWithoutAlertInput[] | MonitoredErrorUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: MonitoredErrorCreateOrConnectWithoutAlertInput | MonitoredErrorCreateOrConnectWithoutAlertInput[]
    createMany?: MonitoredErrorCreateManyAlertInputEnvelope
    connect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
  }

  export type ApiAlertUpdatestandardErrorCodesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ApiAlertUpdatecustomStatusCodesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ApiAlertUpdatebodyErrorValuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ApiAlertUpdateheaderErrorValuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutApiAlertsNestedInput = {
    create?: XOR<ProjectCreateWithoutApiAlertsInput, ProjectUncheckedCreateWithoutApiAlertsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiAlertsInput
    upsert?: ProjectUpsertWithoutApiAlertsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiAlertsInput, ProjectUpdateWithoutApiAlertsInput>, ProjectUncheckedUpdateWithoutApiAlertsInput>
  }

  export type MonitoredErrorUpdateManyWithoutAlertNestedInput = {
    create?: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput> | MonitoredErrorCreateWithoutAlertInput[] | MonitoredErrorUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: MonitoredErrorCreateOrConnectWithoutAlertInput | MonitoredErrorCreateOrConnectWithoutAlertInput[]
    upsert?: MonitoredErrorUpsertWithWhereUniqueWithoutAlertInput | MonitoredErrorUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: MonitoredErrorCreateManyAlertInputEnvelope
    set?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    disconnect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    delete?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    connect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    update?: MonitoredErrorUpdateWithWhereUniqueWithoutAlertInput | MonitoredErrorUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: MonitoredErrorUpdateManyWithWhereWithoutAlertInput | MonitoredErrorUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: MonitoredErrorScalarWhereInput | MonitoredErrorScalarWhereInput[]
  }

  export type MonitoredErrorUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput> | MonitoredErrorCreateWithoutAlertInput[] | MonitoredErrorUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: MonitoredErrorCreateOrConnectWithoutAlertInput | MonitoredErrorCreateOrConnectWithoutAlertInput[]
    upsert?: MonitoredErrorUpsertWithWhereUniqueWithoutAlertInput | MonitoredErrorUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: MonitoredErrorCreateManyAlertInputEnvelope
    set?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    disconnect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    delete?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    connect?: MonitoredErrorWhereUniqueInput | MonitoredErrorWhereUniqueInput[]
    update?: MonitoredErrorUpdateWithWhereUniqueWithoutAlertInput | MonitoredErrorUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: MonitoredErrorUpdateManyWithWhereWithoutAlertInput | MonitoredErrorUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: MonitoredErrorScalarWhereInput | MonitoredErrorScalarWhereInput[]
  }

  export type MonitoredErrorCreateaffectedDevicesInput = {
    set: string[]
  }

  export type MonitoredErrorCreateaffectedSessionsInput = {
    set: string[]
  }

  export type ApiAlertCreateNestedOneWithoutMonitoredErrorsInput = {
    create?: XOR<ApiAlertCreateWithoutMonitoredErrorsInput, ApiAlertUncheckedCreateWithoutMonitoredErrorsInput>
    connectOrCreate?: ApiAlertCreateOrConnectWithoutMonitoredErrorsInput
    connect?: ApiAlertWhereUniqueInput
  }

  export type MonitoredErrorUpdateaffectedDevicesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MonitoredErrorUpdateaffectedSessionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ApiAlertUpdateOneRequiredWithoutMonitoredErrorsNestedInput = {
    create?: XOR<ApiAlertCreateWithoutMonitoredErrorsInput, ApiAlertUncheckedCreateWithoutMonitoredErrorsInput>
    connectOrCreate?: ApiAlertCreateOrConnectWithoutMonitoredErrorsInput
    upsert?: ApiAlertUpsertWithoutMonitoredErrorsInput
    connect?: ApiAlertWhereUniqueInput
    update?: XOR<XOR<ApiAlertUpdateToOneWithWhereWithoutMonitoredErrorsInput, ApiAlertUpdateWithoutMonitoredErrorsInput>, ApiAlertUncheckedUpdateWithoutMonitoredErrorsInput>
  }

  export type ProjectCreateNestedOneWithoutBusinessConfigsInput = {
    create?: XOR<ProjectCreateWithoutBusinessConfigsInput, ProjectUncheckedCreateWithoutBusinessConfigsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBusinessConfigsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ConfigAlertCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput> | ConfigAlertCreateWithoutConfigInput[] | ConfigAlertUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutConfigInput | ConfigAlertCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigAlertCreateManyConfigInputEnvelope
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
  }

  export type ConfigApprovalCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput> | ConfigApprovalCreateWithoutConfigInput[] | ConfigApprovalUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutConfigInput | ConfigApprovalCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigApprovalCreateManyConfigInputEnvelope
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
  }

  export type ConfigAlertUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput> | ConfigAlertCreateWithoutConfigInput[] | ConfigAlertUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutConfigInput | ConfigAlertCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigAlertCreateManyConfigInputEnvelope
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
  }

  export type ConfigApprovalUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput> | ConfigApprovalCreateWithoutConfigInput[] | ConfigApprovalUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutConfigInput | ConfigApprovalCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigApprovalCreateManyConfigInputEnvelope
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ProjectUpdateOneRequiredWithoutBusinessConfigsNestedInput = {
    create?: XOR<ProjectCreateWithoutBusinessConfigsInput, ProjectUncheckedCreateWithoutBusinessConfigsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBusinessConfigsInput
    upsert?: ProjectUpsertWithoutBusinessConfigsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBusinessConfigsInput, ProjectUpdateWithoutBusinessConfigsInput>, ProjectUncheckedUpdateWithoutBusinessConfigsInput>
  }

  export type ConfigAlertUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput> | ConfigAlertCreateWithoutConfigInput[] | ConfigAlertUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutConfigInput | ConfigAlertCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigAlertUpsertWithWhereUniqueWithoutConfigInput | ConfigAlertUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigAlertCreateManyConfigInputEnvelope
    set?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    disconnect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    delete?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    update?: ConfigAlertUpdateWithWhereUniqueWithoutConfigInput | ConfigAlertUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigAlertUpdateManyWithWhereWithoutConfigInput | ConfigAlertUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
  }

  export type ConfigApprovalUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput> | ConfigApprovalCreateWithoutConfigInput[] | ConfigApprovalUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutConfigInput | ConfigApprovalCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigApprovalUpsertWithWhereUniqueWithoutConfigInput | ConfigApprovalUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigApprovalCreateManyConfigInputEnvelope
    set?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    disconnect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    delete?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    update?: ConfigApprovalUpdateWithWhereUniqueWithoutConfigInput | ConfigApprovalUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigApprovalUpdateManyWithWhereWithoutConfigInput | ConfigApprovalUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
  }

  export type ConfigAlertUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput> | ConfigAlertCreateWithoutConfigInput[] | ConfigAlertUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutConfigInput | ConfigAlertCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigAlertUpsertWithWhereUniqueWithoutConfigInput | ConfigAlertUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigAlertCreateManyConfigInputEnvelope
    set?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    disconnect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    delete?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    connect?: ConfigAlertWhereUniqueInput | ConfigAlertWhereUniqueInput[]
    update?: ConfigAlertUpdateWithWhereUniqueWithoutConfigInput | ConfigAlertUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigAlertUpdateManyWithWhereWithoutConfigInput | ConfigAlertUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
  }

  export type ConfigApprovalUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput> | ConfigApprovalCreateWithoutConfigInput[] | ConfigApprovalUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigApprovalCreateOrConnectWithoutConfigInput | ConfigApprovalCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigApprovalUpsertWithWhereUniqueWithoutConfigInput | ConfigApprovalUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigApprovalCreateManyConfigInputEnvelope
    set?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    disconnect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    delete?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    connect?: ConfigApprovalWhereUniqueInput | ConfigApprovalWhereUniqueInput[]
    update?: ConfigApprovalUpdateWithWhereUniqueWithoutConfigInput | ConfigApprovalUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigApprovalUpdateManyWithWhereWithoutConfigInput | ConfigApprovalUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<ProjectCreateWithoutLanguagesInput, ProjectUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLanguagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type TranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<ProjectCreateWithoutLanguagesInput, ProjectUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLanguagesInput
    upsert?: ProjectUpsertWithoutLanguagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLanguagesInput, ProjectUpdateWithoutLanguagesInput>, ProjectUncheckedUpdateWithoutLanguagesInput>
  }

  export type TranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutLanguageInput | TranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutLanguageInput | TranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutLanguageInput | TranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type TranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutLanguageInput | TranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutLanguageInput | TranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutLanguageInput | TranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutLocalizationKeysInput = {
    create?: XOR<ProjectCreateWithoutLocalizationKeysInput, ProjectUncheckedCreateWithoutLocalizationKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLocalizationKeysInput
    connect?: ProjectWhereUniqueInput
  }

  export type TranslationCreateNestedManyWithoutKeyInput = {
    create?: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput> | TranslationCreateWithoutKeyInput[] | TranslationUncheckedCreateWithoutKeyInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutKeyInput | TranslationCreateOrConnectWithoutKeyInput[]
    createMany?: TranslationCreateManyKeyInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type TranslationUncheckedCreateNestedManyWithoutKeyInput = {
    create?: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput> | TranslationCreateWithoutKeyInput[] | TranslationUncheckedCreateWithoutKeyInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutKeyInput | TranslationCreateOrConnectWithoutKeyInput[]
    createMany?: TranslationCreateManyKeyInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutLocalizationKeysNestedInput = {
    create?: XOR<ProjectCreateWithoutLocalizationKeysInput, ProjectUncheckedCreateWithoutLocalizationKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLocalizationKeysInput
    upsert?: ProjectUpsertWithoutLocalizationKeysInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLocalizationKeysInput, ProjectUpdateWithoutLocalizationKeysInput>, ProjectUncheckedUpdateWithoutLocalizationKeysInput>
  }

  export type TranslationUpdateManyWithoutKeyNestedInput = {
    create?: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput> | TranslationCreateWithoutKeyInput[] | TranslationUncheckedCreateWithoutKeyInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutKeyInput | TranslationCreateOrConnectWithoutKeyInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutKeyInput | TranslationUpsertWithWhereUniqueWithoutKeyInput[]
    createMany?: TranslationCreateManyKeyInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutKeyInput | TranslationUpdateWithWhereUniqueWithoutKeyInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutKeyInput | TranslationUpdateManyWithWhereWithoutKeyInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type TranslationUncheckedUpdateManyWithoutKeyNestedInput = {
    create?: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput> | TranslationCreateWithoutKeyInput[] | TranslationUncheckedCreateWithoutKeyInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutKeyInput | TranslationCreateOrConnectWithoutKeyInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutKeyInput | TranslationUpsertWithWhereUniqueWithoutKeyInput[]
    createMany?: TranslationCreateManyKeyInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutKeyInput | TranslationUpdateWithWhereUniqueWithoutKeyInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutKeyInput | TranslationUpdateManyWithWhereWithoutKeyInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type LocalizationKeyCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<LocalizationKeyCreateWithoutTranslationsInput, LocalizationKeyUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutTranslationsInput
    connect?: LocalizationKeyWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
  }

  export type LocalizationKeyUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<LocalizationKeyCreateWithoutTranslationsInput, LocalizationKeyUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LocalizationKeyCreateOrConnectWithoutTranslationsInput
    upsert?: LocalizationKeyUpsertWithoutTranslationsInput
    connect?: LocalizationKeyWhereUniqueInput
    update?: XOR<XOR<LocalizationKeyUpdateToOneWithWhereWithoutTranslationsInput, LocalizationKeyUpdateWithoutTranslationsInput>, LocalizationKeyUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    upsert?: LanguageUpsertWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutTranslationsInput, LanguageUpdateWithoutTranslationsInput>, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProjectCreateNestedOneWithoutFeatureFlagsInput = {
    create?: XOR<ProjectCreateWithoutFeatureFlagsInput, ProjectUncheckedCreateWithoutFeatureFlagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFeatureFlagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutFeatureFlagsNestedInput = {
    create?: XOR<ProjectCreateWithoutFeatureFlagsInput, ProjectUncheckedCreateWithoutFeatureFlagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFeatureFlagsInput
    upsert?: ProjectUpsertWithoutFeatureFlagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFeatureFlagsInput, ProjectUpdateWithoutFeatureFlagsInput>, ProjectUncheckedUpdateWithoutFeatureFlagsInput>
  }

  export type SdkSettingsCreatesensitiveFieldPatternsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutSdkSettingsInput = {
    create?: XOR<ProjectCreateWithoutSdkSettingsInput, ProjectUncheckedCreateWithoutSdkSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSdkSettingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type SdkSettingsUpdatesensitiveFieldPatternsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutSdkSettingsNestedInput = {
    create?: XOR<ProjectCreateWithoutSdkSettingsInput, ProjectUncheckedCreateWithoutSdkSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSdkSettingsInput
    upsert?: ProjectUpsertWithoutSdkSettingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSdkSettingsInput, ProjectUpdateWithoutSdkSettingsInput>, ProjectUncheckedUpdateWithoutSdkSettingsInput>
  }

  export type ProjectCreateNestedOneWithoutConfigCategoriesInput = {
    create?: XOR<ProjectCreateWithoutConfigCategoriesInput, ProjectUncheckedCreateWithoutConfigCategoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigCategoriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutConfigCategoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutConfigCategoriesInput, ProjectUncheckedCreateWithoutConfigCategoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigCategoriesInput
    upsert?: ProjectUpsertWithoutConfigCategoriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutConfigCategoriesInput, ProjectUpdateWithoutConfigCategoriesInput>, ProjectUncheckedUpdateWithoutConfigCategoriesInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnforcementStateCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: EnforcementStateCreateOrConnectWithoutSubscriptionInput
    connect?: EnforcementStateWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnforcementStateUncheckedCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: EnforcementStateCreateOrConnectWithoutSubscriptionInput
    connect?: EnforcementStateWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type EnforcementStateUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: EnforcementStateCreateOrConnectWithoutSubscriptionInput
    upsert?: EnforcementStateUpsertWithoutSubscriptionInput
    disconnect?: EnforcementStateWhereInput | boolean
    delete?: EnforcementStateWhereInput | boolean
    connect?: EnforcementStateWhereUniqueInput
    update?: XOR<XOR<EnforcementStateUpdateToOneWithWhereWithoutSubscriptionInput, EnforcementStateUpdateWithoutSubscriptionInput>, EnforcementStateUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type EnforcementStateUncheckedUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: EnforcementStateCreateOrConnectWithoutSubscriptionInput
    upsert?: EnforcementStateUpsertWithoutSubscriptionInput
    disconnect?: EnforcementStateWhereInput | boolean
    delete?: EnforcementStateWhereInput | boolean
    connect?: EnforcementStateWhereUniqueInput
    update?: XOR<XOR<EnforcementStateUpdateToOneWithWhereWithoutSubscriptionInput, EnforcementStateUpdateWithoutSubscriptionInput>, EnforcementStateUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionCreateNestedOneWithoutEnforcementStateInput = {
    create?: XOR<SubscriptionCreateWithoutEnforcementStateInput, SubscriptionUncheckedCreateWithoutEnforcementStateInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutEnforcementStateInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutEnforcementStateNestedInput = {
    create?: XOR<SubscriptionCreateWithoutEnforcementStateInput, SubscriptionUncheckedCreateWithoutEnforcementStateInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutEnforcementStateInput
    upsert?: SubscriptionUpsertWithoutEnforcementStateInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutEnforcementStateInput, SubscriptionUpdateWithoutEnforcementStateInput>, SubscriptionUncheckedUpdateWithoutEnforcementStateInput>
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type ProjectCreateNestedOneWithoutBuildsInput = {
    create?: XOR<ProjectCreateWithoutBuildsInput, ProjectUncheckedCreateWithoutBuildsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBuildsInput
    connect?: ProjectWhereUniqueInput
  }

  export type BuildFeatureCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput> | BuildFeatureCreateWithoutBuildInput[] | BuildFeatureUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildFeatureCreateOrConnectWithoutBuildInput | BuildFeatureCreateOrConnectWithoutBuildInput[]
    createMany?: BuildFeatureCreateManyBuildInputEnvelope
    connect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
  }

  export type BuildChangeLogCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput> | BuildChangeLogCreateWithoutBuildInput[] | BuildChangeLogUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildChangeLogCreateOrConnectWithoutBuildInput | BuildChangeLogCreateOrConnectWithoutBuildInput[]
    createMany?: BuildChangeLogCreateManyBuildInputEnvelope
    connect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
  }

  export type BuildModeCreateNestedOneWithoutPreviewBuildInput = {
    create?: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutPreviewBuildInput
    connect?: BuildModeWhereUniqueInput
  }

  export type BuildModeCreateNestedOneWithoutProductionBuildInput = {
    create?: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProductionBuildInput
    connect?: BuildModeWhereUniqueInput
  }

  export type BuildFeatureUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput> | BuildFeatureCreateWithoutBuildInput[] | BuildFeatureUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildFeatureCreateOrConnectWithoutBuildInput | BuildFeatureCreateOrConnectWithoutBuildInput[]
    createMany?: BuildFeatureCreateManyBuildInputEnvelope
    connect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
  }

  export type BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput> | BuildChangeLogCreateWithoutBuildInput[] | BuildChangeLogUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildChangeLogCreateOrConnectWithoutBuildInput | BuildChangeLogCreateOrConnectWithoutBuildInput[]
    createMany?: BuildChangeLogCreateManyBuildInputEnvelope
    connect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
  }

  export type BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput = {
    create?: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutPreviewBuildInput
    connect?: BuildModeWhereUniqueInput
  }

  export type BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput = {
    create?: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProductionBuildInput
    connect?: BuildModeWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutBuildsNestedInput = {
    create?: XOR<ProjectCreateWithoutBuildsInput, ProjectUncheckedCreateWithoutBuildsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBuildsInput
    upsert?: ProjectUpsertWithoutBuildsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBuildsInput, ProjectUpdateWithoutBuildsInput>, ProjectUncheckedUpdateWithoutBuildsInput>
  }

  export type BuildFeatureUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput> | BuildFeatureCreateWithoutBuildInput[] | BuildFeatureUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildFeatureCreateOrConnectWithoutBuildInput | BuildFeatureCreateOrConnectWithoutBuildInput[]
    upsert?: BuildFeatureUpsertWithWhereUniqueWithoutBuildInput | BuildFeatureUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildFeatureCreateManyBuildInputEnvelope
    set?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    disconnect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    delete?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    connect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    update?: BuildFeatureUpdateWithWhereUniqueWithoutBuildInput | BuildFeatureUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildFeatureUpdateManyWithWhereWithoutBuildInput | BuildFeatureUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildFeatureScalarWhereInput | BuildFeatureScalarWhereInput[]
  }

  export type BuildChangeLogUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput> | BuildChangeLogCreateWithoutBuildInput[] | BuildChangeLogUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildChangeLogCreateOrConnectWithoutBuildInput | BuildChangeLogCreateOrConnectWithoutBuildInput[]
    upsert?: BuildChangeLogUpsertWithWhereUniqueWithoutBuildInput | BuildChangeLogUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildChangeLogCreateManyBuildInputEnvelope
    set?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    disconnect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    delete?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    connect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    update?: BuildChangeLogUpdateWithWhereUniqueWithoutBuildInput | BuildChangeLogUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildChangeLogUpdateManyWithWhereWithoutBuildInput | BuildChangeLogUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildChangeLogScalarWhereInput | BuildChangeLogScalarWhereInput[]
  }

  export type BuildModeUpdateOneWithoutPreviewBuildNestedInput = {
    create?: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutPreviewBuildInput
    upsert?: BuildModeUpsertWithoutPreviewBuildInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutPreviewBuildInput, BuildModeUpdateWithoutPreviewBuildInput>, BuildModeUncheckedUpdateWithoutPreviewBuildInput>
  }

  export type BuildModeUpdateOneWithoutProductionBuildNestedInput = {
    create?: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProductionBuildInput
    upsert?: BuildModeUpsertWithoutProductionBuildInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutProductionBuildInput, BuildModeUpdateWithoutProductionBuildInput>, BuildModeUncheckedUpdateWithoutProductionBuildInput>
  }

  export type BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput> | BuildFeatureCreateWithoutBuildInput[] | BuildFeatureUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildFeatureCreateOrConnectWithoutBuildInput | BuildFeatureCreateOrConnectWithoutBuildInput[]
    upsert?: BuildFeatureUpsertWithWhereUniqueWithoutBuildInput | BuildFeatureUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildFeatureCreateManyBuildInputEnvelope
    set?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    disconnect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    delete?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    connect?: BuildFeatureWhereUniqueInput | BuildFeatureWhereUniqueInput[]
    update?: BuildFeatureUpdateWithWhereUniqueWithoutBuildInput | BuildFeatureUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildFeatureUpdateManyWithWhereWithoutBuildInput | BuildFeatureUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildFeatureScalarWhereInput | BuildFeatureScalarWhereInput[]
  }

  export type BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput> | BuildChangeLogCreateWithoutBuildInput[] | BuildChangeLogUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildChangeLogCreateOrConnectWithoutBuildInput | BuildChangeLogCreateOrConnectWithoutBuildInput[]
    upsert?: BuildChangeLogUpsertWithWhereUniqueWithoutBuildInput | BuildChangeLogUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildChangeLogCreateManyBuildInputEnvelope
    set?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    disconnect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    delete?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    connect?: BuildChangeLogWhereUniqueInput | BuildChangeLogWhereUniqueInput[]
    update?: BuildChangeLogUpdateWithWhereUniqueWithoutBuildInput | BuildChangeLogUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildChangeLogUpdateManyWithWhereWithoutBuildInput | BuildChangeLogUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildChangeLogScalarWhereInput | BuildChangeLogScalarWhereInput[]
  }

  export type BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput = {
    create?: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutPreviewBuildInput
    upsert?: BuildModeUpsertWithoutPreviewBuildInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutPreviewBuildInput, BuildModeUpdateWithoutPreviewBuildInput>, BuildModeUncheckedUpdateWithoutPreviewBuildInput>
  }

  export type BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput = {
    create?: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
    connectOrCreate?: BuildModeCreateOrConnectWithoutProductionBuildInput
    upsert?: BuildModeUpsertWithoutProductionBuildInput
    disconnect?: BuildModeWhereInput | boolean
    delete?: BuildModeWhereInput | boolean
    connect?: BuildModeWhereUniqueInput
    update?: XOR<XOR<BuildModeUpdateToOneWithWhereWithoutProductionBuildInput, BuildModeUpdateWithoutProductionBuildInput>, BuildModeUncheckedUpdateWithoutProductionBuildInput>
  }

  export type BuildCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<BuildCreateWithoutFeaturesInput, BuildUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: BuildCreateOrConnectWithoutFeaturesInput
    connect?: BuildWhereUniqueInput
  }

  export type BuildUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<BuildCreateWithoutFeaturesInput, BuildUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: BuildCreateOrConnectWithoutFeaturesInput
    upsert?: BuildUpsertWithoutFeaturesInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutFeaturesInput, BuildUpdateWithoutFeaturesInput>, BuildUncheckedUpdateWithoutFeaturesInput>
  }

  export type ProjectCreateNestedOneWithoutBuildModeInput = {
    create?: XOR<ProjectCreateWithoutBuildModeInput, ProjectUncheckedCreateWithoutBuildModeInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBuildModeInput
    connect?: ProjectWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutPreviewModeInput = {
    create?: XOR<BuildCreateWithoutPreviewModeInput, BuildUncheckedCreateWithoutPreviewModeInput>
    connectOrCreate?: BuildCreateOrConnectWithoutPreviewModeInput
    connect?: BuildWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutProductionModeInput = {
    create?: XOR<BuildCreateWithoutProductionModeInput, BuildUncheckedCreateWithoutProductionModeInput>
    connectOrCreate?: BuildCreateOrConnectWithoutProductionModeInput
    connect?: BuildWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutBuildModeNestedInput = {
    create?: XOR<ProjectCreateWithoutBuildModeInput, ProjectUncheckedCreateWithoutBuildModeInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBuildModeInput
    upsert?: ProjectUpsertWithoutBuildModeInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBuildModeInput, ProjectUpdateWithoutBuildModeInput>, ProjectUncheckedUpdateWithoutBuildModeInput>
  }

  export type BuildUpdateOneWithoutPreviewModeNestedInput = {
    create?: XOR<BuildCreateWithoutPreviewModeInput, BuildUncheckedCreateWithoutPreviewModeInput>
    connectOrCreate?: BuildCreateOrConnectWithoutPreviewModeInput
    upsert?: BuildUpsertWithoutPreviewModeInput
    disconnect?: BuildWhereInput | boolean
    delete?: BuildWhereInput | boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutPreviewModeInput, BuildUpdateWithoutPreviewModeInput>, BuildUncheckedUpdateWithoutPreviewModeInput>
  }

  export type BuildUpdateOneWithoutProductionModeNestedInput = {
    create?: XOR<BuildCreateWithoutProductionModeInput, BuildUncheckedCreateWithoutProductionModeInput>
    connectOrCreate?: BuildCreateOrConnectWithoutProductionModeInput
    upsert?: BuildUpsertWithoutProductionModeInput
    disconnect?: BuildWhereInput | boolean
    delete?: BuildWhereInput | boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutProductionModeInput, BuildUpdateWithoutProductionModeInput>, BuildUncheckedUpdateWithoutProductionModeInput>
  }

  export type BuildCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<BuildCreateWithoutChangeLogsInput, BuildUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: BuildCreateOrConnectWithoutChangeLogsInput
    connect?: BuildWhereUniqueInput
  }

  export type BuildUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<BuildCreateWithoutChangeLogsInput, BuildUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: BuildCreateOrConnectWithoutChangeLogsInput
    upsert?: BuildUpsertWithoutChangeLogsInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutChangeLogsInput, BuildUpdateWithoutChangeLogsInput>, BuildUncheckedUpdateWithoutChangeLogsInput>
  }

  export type MockEnvironmentCreatewhitelistInput = {
    set: string[]
  }

  export type MockEnvironmentCreateblacklistInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutMockEnvironmentsInput = {
    create?: XOR<ProjectCreateWithoutMockEnvironmentsInput, ProjectUncheckedCreateWithoutMockEnvironmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMockEnvironmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MockEndpointCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput> | MockEndpointCreateWithoutEnvironmentInput[] | MockEndpointUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: MockEndpointCreateOrConnectWithoutEnvironmentInput | MockEndpointCreateOrConnectWithoutEnvironmentInput[]
    createMany?: MockEndpointCreateManyEnvironmentInputEnvelope
    connect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
  }

  export type MockEndpointUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput> | MockEndpointCreateWithoutEnvironmentInput[] | MockEndpointUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: MockEndpointCreateOrConnectWithoutEnvironmentInput | MockEndpointCreateOrConnectWithoutEnvironmentInput[]
    createMany?: MockEndpointCreateManyEnvironmentInputEnvelope
    connect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
  }

  export type MockEnvironmentUpdatewhitelistInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MockEnvironmentUpdateblacklistInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutMockEnvironmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutMockEnvironmentsInput, ProjectUncheckedCreateWithoutMockEnvironmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMockEnvironmentsInput
    upsert?: ProjectUpsertWithoutMockEnvironmentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMockEnvironmentsInput, ProjectUpdateWithoutMockEnvironmentsInput>, ProjectUncheckedUpdateWithoutMockEnvironmentsInput>
  }

  export type MockEndpointUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput> | MockEndpointCreateWithoutEnvironmentInput[] | MockEndpointUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: MockEndpointCreateOrConnectWithoutEnvironmentInput | MockEndpointCreateOrConnectWithoutEnvironmentInput[]
    upsert?: MockEndpointUpsertWithWhereUniqueWithoutEnvironmentInput | MockEndpointUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: MockEndpointCreateManyEnvironmentInputEnvelope
    set?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    disconnect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    delete?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    connect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    update?: MockEndpointUpdateWithWhereUniqueWithoutEnvironmentInput | MockEndpointUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: MockEndpointUpdateManyWithWhereWithoutEnvironmentInput | MockEndpointUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: MockEndpointScalarWhereInput | MockEndpointScalarWhereInput[]
  }

  export type MockEndpointUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput> | MockEndpointCreateWithoutEnvironmentInput[] | MockEndpointUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: MockEndpointCreateOrConnectWithoutEnvironmentInput | MockEndpointCreateOrConnectWithoutEnvironmentInput[]
    upsert?: MockEndpointUpsertWithWhereUniqueWithoutEnvironmentInput | MockEndpointUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: MockEndpointCreateManyEnvironmentInputEnvelope
    set?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    disconnect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    delete?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    connect?: MockEndpointWhereUniqueInput | MockEndpointWhereUniqueInput[]
    update?: MockEndpointUpdateWithWhereUniqueWithoutEnvironmentInput | MockEndpointUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: MockEndpointUpdateManyWithWhereWithoutEnvironmentInput | MockEndpointUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: MockEndpointScalarWhereInput | MockEndpointScalarWhereInput[]
  }

  export type MockEnvironmentCreateNestedOneWithoutEndpointsInput = {
    create?: XOR<MockEnvironmentCreateWithoutEndpointsInput, MockEnvironmentUncheckedCreateWithoutEndpointsInput>
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutEndpointsInput
    connect?: MockEnvironmentWhereUniqueInput
  }

  export type MockResponseCreateNestedManyWithoutEndpointInput = {
    create?: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput> | MockResponseCreateWithoutEndpointInput[] | MockResponseUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockResponseCreateOrConnectWithoutEndpointInput | MockResponseCreateOrConnectWithoutEndpointInput[]
    createMany?: MockResponseCreateManyEndpointInputEnvelope
    connect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
  }

  export type MockConditionCreateNestedManyWithoutEndpointInput = {
    create?: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput> | MockConditionCreateWithoutEndpointInput[] | MockConditionUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutEndpointInput | MockConditionCreateOrConnectWithoutEndpointInput[]
    createMany?: MockConditionCreateManyEndpointInputEnvelope
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
  }

  export type MockResponseUncheckedCreateNestedManyWithoutEndpointInput = {
    create?: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput> | MockResponseCreateWithoutEndpointInput[] | MockResponseUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockResponseCreateOrConnectWithoutEndpointInput | MockResponseCreateOrConnectWithoutEndpointInput[]
    createMany?: MockResponseCreateManyEndpointInputEnvelope
    connect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
  }

  export type MockConditionUncheckedCreateNestedManyWithoutEndpointInput = {
    create?: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput> | MockConditionCreateWithoutEndpointInput[] | MockConditionUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutEndpointInput | MockConditionCreateOrConnectWithoutEndpointInput[]
    createMany?: MockConditionCreateManyEndpointInputEnvelope
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
  }

  export type MockEnvironmentUpdateOneRequiredWithoutEndpointsNestedInput = {
    create?: XOR<MockEnvironmentCreateWithoutEndpointsInput, MockEnvironmentUncheckedCreateWithoutEndpointsInput>
    connectOrCreate?: MockEnvironmentCreateOrConnectWithoutEndpointsInput
    upsert?: MockEnvironmentUpsertWithoutEndpointsInput
    connect?: MockEnvironmentWhereUniqueInput
    update?: XOR<XOR<MockEnvironmentUpdateToOneWithWhereWithoutEndpointsInput, MockEnvironmentUpdateWithoutEndpointsInput>, MockEnvironmentUncheckedUpdateWithoutEndpointsInput>
  }

  export type MockResponseUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput> | MockResponseCreateWithoutEndpointInput[] | MockResponseUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockResponseCreateOrConnectWithoutEndpointInput | MockResponseCreateOrConnectWithoutEndpointInput[]
    upsert?: MockResponseUpsertWithWhereUniqueWithoutEndpointInput | MockResponseUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: MockResponseCreateManyEndpointInputEnvelope
    set?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    disconnect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    delete?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    connect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    update?: MockResponseUpdateWithWhereUniqueWithoutEndpointInput | MockResponseUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: MockResponseUpdateManyWithWhereWithoutEndpointInput | MockResponseUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: MockResponseScalarWhereInput | MockResponseScalarWhereInput[]
  }

  export type MockConditionUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput> | MockConditionCreateWithoutEndpointInput[] | MockConditionUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutEndpointInput | MockConditionCreateOrConnectWithoutEndpointInput[]
    upsert?: MockConditionUpsertWithWhereUniqueWithoutEndpointInput | MockConditionUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: MockConditionCreateManyEndpointInputEnvelope
    set?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    disconnect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    delete?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    update?: MockConditionUpdateWithWhereUniqueWithoutEndpointInput | MockConditionUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: MockConditionUpdateManyWithWhereWithoutEndpointInput | MockConditionUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
  }

  export type MockResponseUncheckedUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput> | MockResponseCreateWithoutEndpointInput[] | MockResponseUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockResponseCreateOrConnectWithoutEndpointInput | MockResponseCreateOrConnectWithoutEndpointInput[]
    upsert?: MockResponseUpsertWithWhereUniqueWithoutEndpointInput | MockResponseUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: MockResponseCreateManyEndpointInputEnvelope
    set?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    disconnect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    delete?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    connect?: MockResponseWhereUniqueInput | MockResponseWhereUniqueInput[]
    update?: MockResponseUpdateWithWhereUniqueWithoutEndpointInput | MockResponseUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: MockResponseUpdateManyWithWhereWithoutEndpointInput | MockResponseUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: MockResponseScalarWhereInput | MockResponseScalarWhereInput[]
  }

  export type MockConditionUncheckedUpdateManyWithoutEndpointNestedInput = {
    create?: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput> | MockConditionCreateWithoutEndpointInput[] | MockConditionUncheckedCreateWithoutEndpointInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutEndpointInput | MockConditionCreateOrConnectWithoutEndpointInput[]
    upsert?: MockConditionUpsertWithWhereUniqueWithoutEndpointInput | MockConditionUpsertWithWhereUniqueWithoutEndpointInput[]
    createMany?: MockConditionCreateManyEndpointInputEnvelope
    set?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    disconnect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    delete?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    update?: MockConditionUpdateWithWhereUniqueWithoutEndpointInput | MockConditionUpdateWithWhereUniqueWithoutEndpointInput[]
    updateMany?: MockConditionUpdateManyWithWhereWithoutEndpointInput | MockConditionUpdateManyWithWhereWithoutEndpointInput[]
    deleteMany?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
  }

  export type MockEndpointCreateNestedOneWithoutResponsesInput = {
    create?: XOR<MockEndpointCreateWithoutResponsesInput, MockEndpointUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: MockEndpointCreateOrConnectWithoutResponsesInput
    connect?: MockEndpointWhereUniqueInput
  }

  export type MockConditionCreateNestedManyWithoutResponseInput = {
    create?: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput> | MockConditionCreateWithoutResponseInput[] | MockConditionUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutResponseInput | MockConditionCreateOrConnectWithoutResponseInput[]
    createMany?: MockConditionCreateManyResponseInputEnvelope
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
  }

  export type MockConditionUncheckedCreateNestedManyWithoutResponseInput = {
    create?: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput> | MockConditionCreateWithoutResponseInput[] | MockConditionUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutResponseInput | MockConditionCreateOrConnectWithoutResponseInput[]
    createMany?: MockConditionCreateManyResponseInputEnvelope
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
  }

  export type MockEndpointUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<MockEndpointCreateWithoutResponsesInput, MockEndpointUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: MockEndpointCreateOrConnectWithoutResponsesInput
    upsert?: MockEndpointUpsertWithoutResponsesInput
    connect?: MockEndpointWhereUniqueInput
    update?: XOR<XOR<MockEndpointUpdateToOneWithWhereWithoutResponsesInput, MockEndpointUpdateWithoutResponsesInput>, MockEndpointUncheckedUpdateWithoutResponsesInput>
  }

  export type MockConditionUpdateManyWithoutResponseNestedInput = {
    create?: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput> | MockConditionCreateWithoutResponseInput[] | MockConditionUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutResponseInput | MockConditionCreateOrConnectWithoutResponseInput[]
    upsert?: MockConditionUpsertWithWhereUniqueWithoutResponseInput | MockConditionUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: MockConditionCreateManyResponseInputEnvelope
    set?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    disconnect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    delete?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    update?: MockConditionUpdateWithWhereUniqueWithoutResponseInput | MockConditionUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: MockConditionUpdateManyWithWhereWithoutResponseInput | MockConditionUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
  }

  export type MockConditionUncheckedUpdateManyWithoutResponseNestedInput = {
    create?: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput> | MockConditionCreateWithoutResponseInput[] | MockConditionUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: MockConditionCreateOrConnectWithoutResponseInput | MockConditionCreateOrConnectWithoutResponseInput[]
    upsert?: MockConditionUpsertWithWhereUniqueWithoutResponseInput | MockConditionUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: MockConditionCreateManyResponseInputEnvelope
    set?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    disconnect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    delete?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    connect?: MockConditionWhereUniqueInput | MockConditionWhereUniqueInput[]
    update?: MockConditionUpdateWithWhereUniqueWithoutResponseInput | MockConditionUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: MockConditionUpdateManyWithWhereWithoutResponseInput | MockConditionUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
  }

  export type MockResponseCreateNestedOneWithoutConditionsInput = {
    create?: XOR<MockResponseCreateWithoutConditionsInput, MockResponseUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: MockResponseCreateOrConnectWithoutConditionsInput
    connect?: MockResponseWhereUniqueInput
  }

  export type MockEndpointCreateNestedOneWithoutConditionsInput = {
    create?: XOR<MockEndpointCreateWithoutConditionsInput, MockEndpointUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: MockEndpointCreateOrConnectWithoutConditionsInput
    connect?: MockEndpointWhereUniqueInput
  }

  export type MockResponseUpdateOneWithoutConditionsNestedInput = {
    create?: XOR<MockResponseCreateWithoutConditionsInput, MockResponseUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: MockResponseCreateOrConnectWithoutConditionsInput
    upsert?: MockResponseUpsertWithoutConditionsInput
    disconnect?: MockResponseWhereInput | boolean
    delete?: MockResponseWhereInput | boolean
    connect?: MockResponseWhereUniqueInput
    update?: XOR<XOR<MockResponseUpdateToOneWithWhereWithoutConditionsInput, MockResponseUpdateWithoutConditionsInput>, MockResponseUncheckedUpdateWithoutConditionsInput>
  }

  export type MockEndpointUpdateOneWithoutConditionsNestedInput = {
    create?: XOR<MockEndpointCreateWithoutConditionsInput, MockEndpointUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: MockEndpointCreateOrConnectWithoutConditionsInput
    upsert?: MockEndpointUpsertWithoutConditionsInput
    disconnect?: MockEndpointWhereInput | boolean
    delete?: MockEndpointWhereInput | boolean
    connect?: MockEndpointWhereUniqueInput
    update?: XOR<XOR<MockEndpointUpdateToOneWithWhereWithoutConditionsInput, MockEndpointUpdateWithoutConditionsInput>, MockEndpointUncheckedUpdateWithoutConditionsInput>
  }

  export type ProjectCreateNestedOneWithoutConfigAlertsInput = {
    create?: XOR<ProjectCreateWithoutConfigAlertsInput, ProjectUncheckedCreateWithoutConfigAlertsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigAlertsInput
    connect?: ProjectWhereUniqueInput
  }

  export type BusinessConfigCreateNestedOneWithoutAlertsInput = {
    create?: XOR<BusinessConfigCreateWithoutAlertsInput, BusinessConfigUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutAlertsInput
    connect?: BusinessConfigWhereUniqueInput
  }

  export type ConfigAlertEventCreateNestedManyWithoutAlertInput = {
    create?: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput> | ConfigAlertEventCreateWithoutAlertInput[] | ConfigAlertEventUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: ConfigAlertEventCreateOrConnectWithoutAlertInput | ConfigAlertEventCreateOrConnectWithoutAlertInput[]
    createMany?: ConfigAlertEventCreateManyAlertInputEnvelope
    connect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
  }

  export type ConfigAlertEventUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput> | ConfigAlertEventCreateWithoutAlertInput[] | ConfigAlertEventUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: ConfigAlertEventCreateOrConnectWithoutAlertInput | ConfigAlertEventCreateOrConnectWithoutAlertInput[]
    createMany?: ConfigAlertEventCreateManyAlertInputEnvelope
    connect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutConfigAlertsNestedInput = {
    create?: XOR<ProjectCreateWithoutConfigAlertsInput, ProjectUncheckedCreateWithoutConfigAlertsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigAlertsInput
    upsert?: ProjectUpsertWithoutConfigAlertsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutConfigAlertsInput, ProjectUpdateWithoutConfigAlertsInput>, ProjectUncheckedUpdateWithoutConfigAlertsInput>
  }

  export type BusinessConfigUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<BusinessConfigCreateWithoutAlertsInput, BusinessConfigUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutAlertsInput
    upsert?: BusinessConfigUpsertWithoutAlertsInput
    disconnect?: BusinessConfigWhereInput | boolean
    delete?: BusinessConfigWhereInput | boolean
    connect?: BusinessConfigWhereUniqueInput
    update?: XOR<XOR<BusinessConfigUpdateToOneWithWhereWithoutAlertsInput, BusinessConfigUpdateWithoutAlertsInput>, BusinessConfigUncheckedUpdateWithoutAlertsInput>
  }

  export type ConfigAlertEventUpdateManyWithoutAlertNestedInput = {
    create?: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput> | ConfigAlertEventCreateWithoutAlertInput[] | ConfigAlertEventUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: ConfigAlertEventCreateOrConnectWithoutAlertInput | ConfigAlertEventCreateOrConnectWithoutAlertInput[]
    upsert?: ConfigAlertEventUpsertWithWhereUniqueWithoutAlertInput | ConfigAlertEventUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: ConfigAlertEventCreateManyAlertInputEnvelope
    set?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    disconnect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    delete?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    connect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    update?: ConfigAlertEventUpdateWithWhereUniqueWithoutAlertInput | ConfigAlertEventUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: ConfigAlertEventUpdateManyWithWhereWithoutAlertInput | ConfigAlertEventUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: ConfigAlertEventScalarWhereInput | ConfigAlertEventScalarWhereInput[]
  }

  export type ConfigAlertEventUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput> | ConfigAlertEventCreateWithoutAlertInput[] | ConfigAlertEventUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: ConfigAlertEventCreateOrConnectWithoutAlertInput | ConfigAlertEventCreateOrConnectWithoutAlertInput[]
    upsert?: ConfigAlertEventUpsertWithWhereUniqueWithoutAlertInput | ConfigAlertEventUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: ConfigAlertEventCreateManyAlertInputEnvelope
    set?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    disconnect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    delete?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    connect?: ConfigAlertEventWhereUniqueInput | ConfigAlertEventWhereUniqueInput[]
    update?: ConfigAlertEventUpdateWithWhereUniqueWithoutAlertInput | ConfigAlertEventUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: ConfigAlertEventUpdateManyWithWhereWithoutAlertInput | ConfigAlertEventUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: ConfigAlertEventScalarWhereInput | ConfigAlertEventScalarWhereInput[]
  }

  export type ConfigAlertCreateNestedOneWithoutEventsInput = {
    create?: XOR<ConfigAlertCreateWithoutEventsInput, ConfigAlertUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutEventsInput
    connect?: ConfigAlertWhereUniqueInput
  }

  export type ConfigAlertUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ConfigAlertCreateWithoutEventsInput, ConfigAlertUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ConfigAlertCreateOrConnectWithoutEventsInput
    upsert?: ConfigAlertUpsertWithoutEventsInput
    connect?: ConfigAlertWhereUniqueInput
    update?: XOR<XOR<ConfigAlertUpdateToOneWithWhereWithoutEventsInput, ConfigAlertUpdateWithoutEventsInput>, ConfigAlertUncheckedUpdateWithoutEventsInput>
  }

  export type ProjectCreateNestedOneWithoutConfigApprovalsInput = {
    create?: XOR<ProjectCreateWithoutConfigApprovalsInput, ProjectUncheckedCreateWithoutConfigApprovalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigApprovalsInput
    connect?: ProjectWhereUniqueInput
  }

  export type BusinessConfigCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<BusinessConfigCreateWithoutApprovalsInput, BusinessConfigUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutApprovalsInput
    connect?: BusinessConfigWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutConfigApprovalsNestedInput = {
    create?: XOR<ProjectCreateWithoutConfigApprovalsInput, ProjectUncheckedCreateWithoutConfigApprovalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConfigApprovalsInput
    upsert?: ProjectUpsertWithoutConfigApprovalsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutConfigApprovalsInput, ProjectUpdateWithoutConfigApprovalsInput>, ProjectUncheckedUpdateWithoutConfigApprovalsInput>
  }

  export type BusinessConfigUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<BusinessConfigCreateWithoutApprovalsInput, BusinessConfigUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: BusinessConfigCreateOrConnectWithoutApprovalsInput
    upsert?: BusinessConfigUpsertWithoutApprovalsInput
    connect?: BusinessConfigWhereUniqueInput
    update?: XOR<XOR<BusinessConfigUpdateToOneWithWhereWithoutApprovalsInput, BusinessConfigUpdateWithoutApprovalsInput>, BusinessConfigUncheckedUpdateWithoutApprovalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    apiKey?: StringFilter<"Project"> | string
    userId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type DeviceCreateWithoutProjectInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogCreateNestedManyWithoutDeviceInput
    crashes?: CrashCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceCreateNestedManyWithoutDeviceInput
    sessions?: SessionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutProjectInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
    crashes?: CrashUncheckedCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutDeviceInput
    sessions?: SessionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutProjectInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput>
  }

  export type DeviceCreateManyProjectInputEnvelope = {
    data: DeviceCreateManyProjectInput | DeviceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutProjectInput = {
    id?: string
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    device?: DeviceCreateNestedOneWithoutLogsInput
    session?: SessionCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutProjectInput = {
    id?: string
    deviceId?: string | null
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutProjectInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput>
  }

  export type LogCreateManyProjectInputEnvelope = {
    data: LogCreateManyProjectInput | LogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CrashCreateWithoutProjectInput = {
    id?: string
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    device?: DeviceCreateNestedOneWithoutCrashesInput
  }

  export type CrashUncheckedCreateWithoutProjectInput = {
    id?: string
    deviceId?: string | null
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashCreateOrConnectWithoutProjectInput = {
    where: CrashWhereUniqueInput
    create: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput>
  }

  export type CrashCreateManyProjectInputEnvelope = {
    data: CrashCreateManyProjectInput | CrashCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ApiTraceCreateWithoutProjectInput = {
    id?: string
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    device?: DeviceCreateNestedOneWithoutApiTracesInput
    session?: SessionCreateNestedOneWithoutApiTracesInput
  }

  export type ApiTraceUncheckedCreateWithoutProjectInput = {
    id?: string
    deviceId?: string | null
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceCreateOrConnectWithoutProjectInput = {
    where: ApiTraceWhereUniqueInput
    create: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput>
  }

  export type ApiTraceCreateManyProjectInputEnvelope = {
    data: ApiTraceCreateManyProjectInput | ApiTraceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ApiConfigCreateWithoutProjectInput = {
    id?: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiConfigUncheckedCreateWithoutProjectInput = {
    id?: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiConfigCreateOrConnectWithoutProjectInput = {
    where: ApiConfigWhereUniqueInput
    create: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput>
  }

  export type ApiConfigCreateManyProjectInputEnvelope = {
    data: ApiConfigCreateManyProjectInput | ApiConfigCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutProjectInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutSessionsInput
    apiTraces?: ApiTraceCreateNestedManyWithoutSessionInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutProjectInput = {
    id?: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutSessionInput
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutProjectInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput>
  }

  export type SessionCreateManyProjectInputEnvelope = {
    data: SessionCreateManyProjectInput | SessionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutProjectInput = {
    id?: string
    emailEnabled?: boolean
    emailAddresses?: NotificationSettingsCreateemailAddressesInput | string[]
    pushEnabled?: boolean
    pushToken?: string | null
    smsEnabled?: boolean
    smsNumbers?: NotificationSettingsCreatesmsNumbersInput | string[]
    webhookEnabled?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUncheckedCreateWithoutProjectInput = {
    id?: string
    emailEnabled?: boolean
    emailAddresses?: NotificationSettingsCreateemailAddressesInput | string[]
    pushEnabled?: boolean
    pushToken?: string | null
    smsEnabled?: boolean
    smsNumbers?: NotificationSettingsCreatesmsNumbersInput | string[]
    webhookEnabled?: boolean
    webhookUrl?: string | null
    webhookSecret?: string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutProjectInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
  }

  export type ApiAlertCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    monitoredErrors?: MonitoredErrorCreateNestedManyWithoutAlertInput
  }

  export type ApiAlertUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    monitoredErrors?: MonitoredErrorUncheckedCreateNestedManyWithoutAlertInput
  }

  export type ApiAlertCreateOrConnectWithoutProjectInput = {
    where: ApiAlertWhereUniqueInput
    create: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput>
  }

  export type ApiAlertCreateManyProjectInputEnvelope = {
    data: ApiAlertCreateManyProjectInput | ApiAlertCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutProjectInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUncheckedCreateWithoutProjectInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureUncheckedCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildCreateOrConnectWithoutProjectInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput>
  }

  export type BuildCreateManyProjectInputEnvelope = {
    data: BuildCreateManyProjectInput | BuildCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BuildModeCreateWithoutProjectInput = {
    id?: string
    updatedAt?: Date | string
    previewBuild?: BuildCreateNestedOneWithoutPreviewModeInput
    productionBuild?: BuildCreateNestedOneWithoutProductionModeInput
  }

  export type BuildModeUncheckedCreateWithoutProjectInput = {
    id?: string
    previewBuildId?: string | null
    productionBuildId?: string | null
    updatedAt?: Date | string
  }

  export type BuildModeCreateOrConnectWithoutProjectInput = {
    where: BuildModeWhereUniqueInput
    create: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
  }

  export type MockEnvironmentCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoints?: MockEndpointCreateNestedManyWithoutEnvironmentInput
  }

  export type MockEnvironmentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoints?: MockEndpointUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type MockEnvironmentCreateOrConnectWithoutProjectInput = {
    where: MockEnvironmentWhereUniqueInput
    create: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput>
  }

  export type MockEnvironmentCreateManyProjectInputEnvelope = {
    data: MockEnvironmentCreateManyProjectInput | MockEnvironmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BusinessConfigCreateWithoutProjectInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: ConfigAlertCreateNestedManyWithoutConfigInput
    approvals?: ConfigApprovalCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigUncheckedCreateWithoutProjectInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: ConfigAlertUncheckedCreateNestedManyWithoutConfigInput
    approvals?: ConfigApprovalUncheckedCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigCreateOrConnectWithoutProjectInput = {
    where: BusinessConfigWhereUniqueInput
    create: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput>
  }

  export type BusinessConfigCreateManyProjectInputEnvelope = {
    data: BusinessConfigCreateManyProjectInput | BusinessConfigCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ConfigAlertCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    config?: BusinessConfigCreateNestedOneWithoutAlertsInput
    events?: ConfigAlertEventCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertUncheckedCreateWithoutProjectInput = {
    id?: string
    configId?: string | null
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ConfigAlertEventUncheckedCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertCreateOrConnectWithoutProjectInput = {
    where: ConfigAlertWhereUniqueInput
    create: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput>
  }

  export type ConfigAlertCreateManyProjectInputEnvelope = {
    data: ConfigAlertCreateManyProjectInput | ConfigAlertCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ConfigApprovalCreateWithoutProjectInput = {
    id?: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    config: BusinessConfigCreateNestedOneWithoutApprovalsInput
  }

  export type ConfigApprovalUncheckedCreateWithoutProjectInput = {
    id?: string
    configId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalCreateOrConnectWithoutProjectInput = {
    where: ConfigApprovalWhereUniqueInput
    create: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput>
  }

  export type ConfigApprovalCreateManyProjectInputEnvelope = {
    data: ConfigApprovalCreateManyProjectInput | ConfigApprovalCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LanguageCreateWithoutProjectInput = {
    id?: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateWithoutProjectInput = {
    id?: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageCreateOrConnectWithoutProjectInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput>
  }

  export type LanguageCreateManyProjectInputEnvelope = {
    data: LanguageCreateManyProjectInput | LanguageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LocalizationKeyCreateWithoutProjectInput = {
    id?: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutKeyInput
  }

  export type LocalizationKeyUncheckedCreateWithoutProjectInput = {
    id?: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutKeyInput
  }

  export type LocalizationKeyCreateOrConnectWithoutProjectInput = {
    where: LocalizationKeyWhereUniqueInput
    create: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput>
  }

  export type LocalizationKeyCreateManyProjectInputEnvelope = {
    data: LocalizationKeyCreateManyProjectInput | LocalizationKeyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FeatureFlagsCreateWithoutProjectInput = {
    id?: string
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagsUncheckedCreateWithoutProjectInput = {
    id?: string
    sdkEnabled?: boolean
    apiTracking?: boolean
    screenTracking?: boolean
    crashReporting?: boolean
    logging?: boolean
    deviceTracking?: boolean
    sessionTracking?: boolean
    businessConfig?: boolean
    localization?: boolean
    offlineSupport?: boolean
    batchEvents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagsCreateOrConnectWithoutProjectInput = {
    where: FeatureFlagsWhereUniqueInput
    create: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
  }

  export type SdkSettingsCreateWithoutProjectInput = {
    id?: string
    trackingMode?: string
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: SdkSettingsCreatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: number
    maxTraceQueueSize?: number
    flushIntervalSeconds?: number
    enableBatching?: boolean
    minLogLevel?: string
    verboseErrors?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdkSettingsUncheckedCreateWithoutProjectInput = {
    id?: string
    trackingMode?: string
    captureRequestBodies?: boolean
    captureResponseBodies?: boolean
    capturePrintStatements?: boolean
    sanitizeSensitiveData?: boolean
    sensitiveFieldPatterns?: SdkSettingsCreatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: number
    maxTraceQueueSize?: number
    flushIntervalSeconds?: number
    enableBatching?: boolean
    minLogLevel?: string
    verboseErrors?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SdkSettingsCreateOrConnectWithoutProjectInput = {
    where: SdkSettingsWhereUniqueInput
    create: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
  }

  export type ConfigCategoryCreateWithoutProjectInput = {
    id?: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigCategoryUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigCategoryCreateOrConnectWithoutProjectInput = {
    where: ConfigCategoryWhereUniqueInput
    create: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput>
  }

  export type ConfigCategoryCreateManyProjectInputEnvelope = {
    data: ConfigCategoryCreateManyProjectInput | ConfigCategoryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DeviceUpsertWithWhereUniqueWithoutProjectInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutProjectInput, DeviceUncheckedUpdateWithoutProjectInput>
    create: XOR<DeviceCreateWithoutProjectInput, DeviceUncheckedCreateWithoutProjectInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutProjectInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutProjectInput, DeviceUncheckedUpdateWithoutProjectInput>
  }

  export type DeviceUpdateManyWithWhereWithoutProjectInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutProjectInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: StringFilter<"Device"> | string
    projectId?: StringNullableFilter<"Device"> | string | null
    deviceId?: StringFilter<"Device"> | string
    platform?: StringFilter<"Device"> | string
    osVersion?: StringNullableFilter<"Device"> | string | null
    appVersion?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    manufacturer?: StringNullableFilter<"Device"> | string | null
    metadata?: JsonNullableFilter<"Device">
    lastSeenAt?: DateTimeFilter<"Device"> | Date | string
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    deviceCode?: StringNullableFilter<"Device"> | string | null
    userId?: StringNullableFilter<"Device"> | string | null
    userEmail?: StringNullableFilter<"Device"> | string | null
    userName?: StringNullableFilter<"Device"> | string | null
    debugModeEnabled?: BoolFilter<"Device"> | boolean
    debugModeEnabledAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeExpiresAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    debugModeEnabledBy?: StringNullableFilter<"Device"> | string | null
    status?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutProjectInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutProjectInput, LogUncheckedUpdateWithoutProjectInput>
    create: XOR<LogCreateWithoutProjectInput, LogUncheckedCreateWithoutProjectInput>
  }

  export type LogUpdateWithWhereUniqueWithoutProjectInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutProjectInput, LogUncheckedUpdateWithoutProjectInput>
  }

  export type LogUpdateManyWithWhereWithoutProjectInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutProjectInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    projectId?: StringFilter<"Log"> | string
    deviceId?: StringNullableFilter<"Log"> | string | null
    sessionId?: StringNullableFilter<"Log"> | string | null
    level?: StringFilter<"Log"> | string
    message?: StringFilter<"Log"> | string
    tag?: StringNullableFilter<"Log"> | string | null
    data?: JsonNullableFilter<"Log">
    fileName?: StringNullableFilter<"Log"> | string | null
    lineNumber?: IntNullableFilter<"Log"> | number | null
    functionName?: StringNullableFilter<"Log"> | string | null
    className?: StringNullableFilter<"Log"> | string | null
    screenName?: StringNullableFilter<"Log"> | string | null
    threadName?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
  }

  export type CrashUpsertWithWhereUniqueWithoutProjectInput = {
    where: CrashWhereUniqueInput
    update: XOR<CrashUpdateWithoutProjectInput, CrashUncheckedUpdateWithoutProjectInput>
    create: XOR<CrashCreateWithoutProjectInput, CrashUncheckedCreateWithoutProjectInput>
  }

  export type CrashUpdateWithWhereUniqueWithoutProjectInput = {
    where: CrashWhereUniqueInput
    data: XOR<CrashUpdateWithoutProjectInput, CrashUncheckedUpdateWithoutProjectInput>
  }

  export type CrashUpdateManyWithWhereWithoutProjectInput = {
    where: CrashScalarWhereInput
    data: XOR<CrashUpdateManyMutationInput, CrashUncheckedUpdateManyWithoutProjectInput>
  }

  export type CrashScalarWhereInput = {
    AND?: CrashScalarWhereInput | CrashScalarWhereInput[]
    OR?: CrashScalarWhereInput[]
    NOT?: CrashScalarWhereInput | CrashScalarWhereInput[]
    id?: StringFilter<"Crash"> | string
    projectId?: StringFilter<"Crash"> | string
    deviceId?: StringNullableFilter<"Crash"> | string | null
    message?: StringFilter<"Crash"> | string
    stackTrace?: StringNullableFilter<"Crash"> | string | null
    metadata?: JsonNullableFilter<"Crash">
    timestamp?: DateTimeFilter<"Crash"> | Date | string
    createdAt?: DateTimeFilter<"Crash"> | Date | string
  }

  export type ApiTraceUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiTraceWhereUniqueInput
    update: XOR<ApiTraceUpdateWithoutProjectInput, ApiTraceUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiTraceCreateWithoutProjectInput, ApiTraceUncheckedCreateWithoutProjectInput>
  }

  export type ApiTraceUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiTraceWhereUniqueInput
    data: XOR<ApiTraceUpdateWithoutProjectInput, ApiTraceUncheckedUpdateWithoutProjectInput>
  }

  export type ApiTraceUpdateManyWithWhereWithoutProjectInput = {
    where: ApiTraceScalarWhereInput
    data: XOR<ApiTraceUpdateManyMutationInput, ApiTraceUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiTraceScalarWhereInput = {
    AND?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
    OR?: ApiTraceScalarWhereInput[]
    NOT?: ApiTraceScalarWhereInput | ApiTraceScalarWhereInput[]
    id?: StringFilter<"ApiTrace"> | string
    projectId?: StringFilter<"ApiTrace"> | string
    deviceId?: StringNullableFilter<"ApiTrace"> | string | null
    sessionId?: StringNullableFilter<"ApiTrace"> | string | null
    url?: StringFilter<"ApiTrace"> | string
    method?: StringFilter<"ApiTrace"> | string
    statusCode?: IntNullableFilter<"ApiTrace"> | number | null
    requestHeaders?: JsonNullableFilter<"ApiTrace">
    requestBody?: StringNullableFilter<"ApiTrace"> | string | null
    responseHeaders?: JsonNullableFilter<"ApiTrace">
    responseBody?: StringNullableFilter<"ApiTrace"> | string | null
    duration?: IntNullableFilter<"ApiTrace"> | number | null
    error?: StringNullableFilter<"ApiTrace"> | string | null
    screenName?: StringNullableFilter<"ApiTrace"> | string | null
    networkType?: StringNullableFilter<"ApiTrace"> | string | null
    country?: StringNullableFilter<"ApiTrace"> | string | null
    carrier?: StringNullableFilter<"ApiTrace"> | string | null
    ipAddress?: StringNullableFilter<"ApiTrace"> | string | null
    userAgent?: StringNullableFilter<"ApiTrace"> | string | null
    cost?: FloatNullableFilter<"ApiTrace"> | number | null
    timestamp?: DateTimeFilter<"ApiTrace"> | Date | string
    createdAt?: DateTimeFilter<"ApiTrace"> | Date | string
  }

  export type ApiConfigUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiConfigWhereUniqueInput
    update: XOR<ApiConfigUpdateWithoutProjectInput, ApiConfigUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiConfigCreateWithoutProjectInput, ApiConfigUncheckedCreateWithoutProjectInput>
  }

  export type ApiConfigUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiConfigWhereUniqueInput
    data: XOR<ApiConfigUpdateWithoutProjectInput, ApiConfigUncheckedUpdateWithoutProjectInput>
  }

  export type ApiConfigUpdateManyWithWhereWithoutProjectInput = {
    where: ApiConfigScalarWhereInput
    data: XOR<ApiConfigUpdateManyMutationInput, ApiConfigUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiConfigScalarWhereInput = {
    AND?: ApiConfigScalarWhereInput | ApiConfigScalarWhereInput[]
    OR?: ApiConfigScalarWhereInput[]
    NOT?: ApiConfigScalarWhereInput | ApiConfigScalarWhereInput[]
    id?: StringFilter<"ApiConfig"> | string
    projectId?: StringFilter<"ApiConfig"> | string
    endpoint?: StringFilter<"ApiConfig"> | string
    method?: StringNullableFilter<"ApiConfig"> | string | null
    name?: StringNullableFilter<"ApiConfig"> | string | null
    description?: StringNullableFilter<"ApiConfig"> | string | null
    costPerRequest?: FloatFilter<"ApiConfig"> | number
    isEnabled?: BoolFilter<"ApiConfig"> | boolean
    enableLogs?: BoolFilter<"ApiConfig"> | boolean
    captureRequestBody?: BoolFilter<"ApiConfig"> | boolean
    captureResponseBody?: BoolFilter<"ApiConfig"> | boolean
    metadata?: JsonNullableFilter<"ApiConfig">
    createdAt?: DateTimeFilter<"ApiConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ApiConfig"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutProjectInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutProjectInput, SessionUncheckedUpdateWithoutProjectInput>
    create: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutProjectInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutProjectInput, SessionUncheckedUpdateWithoutProjectInput>
  }

  export type SessionUpdateManyWithWhereWithoutProjectInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutProjectInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    projectId?: StringFilter<"Session"> | string
    deviceId?: StringNullableFilter<"Session"> | string | null
    sessionToken?: StringFilter<"Session"> | string
    startedAt?: DateTimeFilter<"Session"> | Date | string
    endedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    isActive?: BoolFilter<"Session"> | boolean
    appVersion?: StringNullableFilter<"Session"> | string | null
    osVersion?: StringNullableFilter<"Session"> | string | null
    locale?: StringNullableFilter<"Session"> | string | null
    timezone?: StringNullableFilter<"Session"> | string | null
    networkType?: StringNullableFilter<"Session"> | string | null
    screenFlow?: StringNullableListFilter<"Session">
    entryScreen?: StringNullableFilter<"Session"> | string | null
    exitScreen?: StringNullableFilter<"Session"> | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    screenCount?: IntFilter<"Session"> | number
    eventCount?: IntFilter<"Session"> | number
    errorCount?: IntFilter<"Session"> | number
    metadata?: JsonNullableFilter<"Session">
    userProperties?: JsonNullableFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type NotificationSettingsUpsertWithoutProjectInput = {
    update: XOR<NotificationSettingsUpdateWithoutProjectInput, NotificationSettingsUncheckedUpdateWithoutProjectInput>
    create: XOR<NotificationSettingsCreateWithoutProjectInput, NotificationSettingsUncheckedCreateWithoutProjectInput>
    where?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsUpdateToOneWithWhereWithoutProjectInput = {
    where?: NotificationSettingsWhereInput
    data: XOR<NotificationSettingsUpdateWithoutProjectInput, NotificationSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type NotificationSettingsUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailAddresses?: NotificationSettingsUpdateemailAddressesInput | string[]
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsNumbers?: NotificationSettingsUpdatesmsNumbersInput | string[]
    webhookEnabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    webhookHeaders?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiAlertUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiAlertWhereUniqueInput
    update: XOR<ApiAlertUpdateWithoutProjectInput, ApiAlertUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiAlertCreateWithoutProjectInput, ApiAlertUncheckedCreateWithoutProjectInput>
  }

  export type ApiAlertUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiAlertWhereUniqueInput
    data: XOR<ApiAlertUpdateWithoutProjectInput, ApiAlertUncheckedUpdateWithoutProjectInput>
  }

  export type ApiAlertUpdateManyWithWhereWithoutProjectInput = {
    where: ApiAlertScalarWhereInput
    data: XOR<ApiAlertUpdateManyMutationInput, ApiAlertUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiAlertScalarWhereInput = {
    AND?: ApiAlertScalarWhereInput | ApiAlertScalarWhereInput[]
    OR?: ApiAlertScalarWhereInput[]
    NOT?: ApiAlertScalarWhereInput | ApiAlertScalarWhereInput[]
    id?: StringFilter<"ApiAlert"> | string
    projectId?: StringFilter<"ApiAlert"> | string
    title?: StringFilter<"ApiAlert"> | string
    description?: StringNullableFilter<"ApiAlert"> | string | null
    endpoint?: StringNullableFilter<"ApiAlert"> | string | null
    method?: StringNullableFilter<"ApiAlert"> | string | null
    isEnabled?: BoolFilter<"ApiAlert"> | boolean
    monitorStandardErrors?: BoolFilter<"ApiAlert"> | boolean
    standardErrorCodes?: IntNullableListFilter<"ApiAlert">
    customStatusCodes?: IntNullableListFilter<"ApiAlert">
    bodyErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    bodyErrorValues?: StringNullableListFilter<"ApiAlert">
    headerErrorField?: StringNullableFilter<"ApiAlert"> | string | null
    headerErrorValues?: StringNullableListFilter<"ApiAlert">
    notifyEmail?: BoolFilter<"ApiAlert"> | boolean
    notifyPush?: BoolFilter<"ApiAlert"> | boolean
    notifySms?: BoolFilter<"ApiAlert"> | boolean
    notifyWebhook?: BoolFilter<"ApiAlert"> | boolean
    cooldownMinutes?: IntFilter<"ApiAlert"> | number
    createdAt?: DateTimeFilter<"ApiAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ApiAlert"> | Date | string
  }

  export type BuildUpsertWithWhereUniqueWithoutProjectInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutProjectInput, BuildUncheckedUpdateWithoutProjectInput>
    create: XOR<BuildCreateWithoutProjectInput, BuildUncheckedCreateWithoutProjectInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutProjectInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutProjectInput, BuildUncheckedUpdateWithoutProjectInput>
  }

  export type BuildUpdateManyWithWhereWithoutProjectInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutProjectInput>
  }

  export type BuildScalarWhereInput = {
    AND?: BuildScalarWhereInput | BuildScalarWhereInput[]
    OR?: BuildScalarWhereInput[]
    NOT?: BuildScalarWhereInput | BuildScalarWhereInput[]
    id?: StringFilter<"Build"> | string
    projectId?: StringFilter<"Build"> | string
    version?: IntFilter<"Build"> | number
    name?: StringNullableFilter<"Build"> | string | null
    description?: StringNullableFilter<"Build"> | string | null
    mode?: StringNullableFilter<"Build"> | string | null
    isActive?: BoolFilter<"Build"> | boolean
    createdBy?: StringNullableFilter<"Build"> | string | null
    createdAt?: DateTimeFilter<"Build"> | Date | string
    businessConfigSnapshot?: JsonNullableFilter<"Build">
    localizationSnapshot?: JsonNullableFilter<"Build">
    configCount?: IntFilter<"Build"> | number
    translationCount?: IntFilter<"Build"> | number
  }

  export type BuildModeUpsertWithoutProjectInput = {
    update: XOR<BuildModeUpdateWithoutProjectInput, BuildModeUncheckedUpdateWithoutProjectInput>
    create: XOR<BuildModeCreateWithoutProjectInput, BuildModeUncheckedCreateWithoutProjectInput>
    where?: BuildModeWhereInput
  }

  export type BuildModeUpdateToOneWithWhereWithoutProjectInput = {
    where?: BuildModeWhereInput
    data: XOR<BuildModeUpdateWithoutProjectInput, BuildModeUncheckedUpdateWithoutProjectInput>
  }

  export type BuildModeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    previewBuild?: BuildUpdateOneWithoutPreviewModeNestedInput
    productionBuild?: BuildUpdateOneWithoutProductionModeNestedInput
  }

  export type BuildModeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    productionBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEnvironmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: MockEnvironmentWhereUniqueInput
    update: XOR<MockEnvironmentUpdateWithoutProjectInput, MockEnvironmentUncheckedUpdateWithoutProjectInput>
    create: XOR<MockEnvironmentCreateWithoutProjectInput, MockEnvironmentUncheckedCreateWithoutProjectInput>
  }

  export type MockEnvironmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: MockEnvironmentWhereUniqueInput
    data: XOR<MockEnvironmentUpdateWithoutProjectInput, MockEnvironmentUncheckedUpdateWithoutProjectInput>
  }

  export type MockEnvironmentUpdateManyWithWhereWithoutProjectInput = {
    where: MockEnvironmentScalarWhereInput
    data: XOR<MockEnvironmentUpdateManyMutationInput, MockEnvironmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type MockEnvironmentScalarWhereInput = {
    AND?: MockEnvironmentScalarWhereInput | MockEnvironmentScalarWhereInput[]
    OR?: MockEnvironmentScalarWhereInput[]
    NOT?: MockEnvironmentScalarWhereInput | MockEnvironmentScalarWhereInput[]
    id?: StringFilter<"MockEnvironment"> | string
    projectId?: StringFilter<"MockEnvironment"> | string
    name?: StringFilter<"MockEnvironment"> | string
    description?: StringNullableFilter<"MockEnvironment"> | string | null
    basePath?: StringNullableFilter<"MockEnvironment"> | string | null
    mode?: StringFilter<"MockEnvironment"> | string
    whitelist?: StringNullableListFilter<"MockEnvironment">
    blacklist?: StringNullableListFilter<"MockEnvironment">
    isEnabled?: BoolFilter<"MockEnvironment"> | boolean
    isDefault?: BoolFilter<"MockEnvironment"> | boolean
    createdBy?: StringNullableFilter<"MockEnvironment"> | string | null
    createdAt?: DateTimeFilter<"MockEnvironment"> | Date | string
    updatedAt?: DateTimeFilter<"MockEnvironment"> | Date | string
  }

  export type BusinessConfigUpsertWithWhereUniqueWithoutProjectInput = {
    where: BusinessConfigWhereUniqueInput
    update: XOR<BusinessConfigUpdateWithoutProjectInput, BusinessConfigUncheckedUpdateWithoutProjectInput>
    create: XOR<BusinessConfigCreateWithoutProjectInput, BusinessConfigUncheckedCreateWithoutProjectInput>
  }

  export type BusinessConfigUpdateWithWhereUniqueWithoutProjectInput = {
    where: BusinessConfigWhereUniqueInput
    data: XOR<BusinessConfigUpdateWithoutProjectInput, BusinessConfigUncheckedUpdateWithoutProjectInput>
  }

  export type BusinessConfigUpdateManyWithWhereWithoutProjectInput = {
    where: BusinessConfigScalarWhereInput
    data: XOR<BusinessConfigUpdateManyMutationInput, BusinessConfigUncheckedUpdateManyWithoutProjectInput>
  }

  export type BusinessConfigScalarWhereInput = {
    AND?: BusinessConfigScalarWhereInput | BusinessConfigScalarWhereInput[]
    OR?: BusinessConfigScalarWhereInput[]
    NOT?: BusinessConfigScalarWhereInput | BusinessConfigScalarWhereInput[]
    id?: StringFilter<"BusinessConfig"> | string
    projectId?: StringFilter<"BusinessConfig"> | string
    key?: StringFilter<"BusinessConfig"> | string
    label?: StringNullableFilter<"BusinessConfig"> | string | null
    description?: StringNullableFilter<"BusinessConfig"> | string | null
    valueType?: StringFilter<"BusinessConfig"> | string
    stringValue?: StringNullableFilter<"BusinessConfig"> | string | null
    integerValue?: IntNullableFilter<"BusinessConfig"> | number | null
    booleanValue?: BoolNullableFilter<"BusinessConfig"> | boolean | null
    decimalValue?: FloatNullableFilter<"BusinessConfig"> | number | null
    jsonValue?: JsonNullableFilter<"BusinessConfig">
    imageUrl?: StringNullableFilter<"BusinessConfig"> | string | null
    category?: StringNullableFilter<"BusinessConfig"> | string | null
    isEnabled?: BoolFilter<"BusinessConfig"> | boolean
    version?: IntFilter<"BusinessConfig"> | number
    metadata?: JsonNullableFilter<"BusinessConfig">
    createdAt?: DateTimeFilter<"BusinessConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessConfig"> | Date | string
  }

  export type ConfigAlertUpsertWithWhereUniqueWithoutProjectInput = {
    where: ConfigAlertWhereUniqueInput
    update: XOR<ConfigAlertUpdateWithoutProjectInput, ConfigAlertUncheckedUpdateWithoutProjectInput>
    create: XOR<ConfigAlertCreateWithoutProjectInput, ConfigAlertUncheckedCreateWithoutProjectInput>
  }

  export type ConfigAlertUpdateWithWhereUniqueWithoutProjectInput = {
    where: ConfigAlertWhereUniqueInput
    data: XOR<ConfigAlertUpdateWithoutProjectInput, ConfigAlertUncheckedUpdateWithoutProjectInput>
  }

  export type ConfigAlertUpdateManyWithWhereWithoutProjectInput = {
    where: ConfigAlertScalarWhereInput
    data: XOR<ConfigAlertUpdateManyMutationInput, ConfigAlertUncheckedUpdateManyWithoutProjectInput>
  }

  export type ConfigAlertScalarWhereInput = {
    AND?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
    OR?: ConfigAlertScalarWhereInput[]
    NOT?: ConfigAlertScalarWhereInput | ConfigAlertScalarWhereInput[]
    id?: StringFilter<"ConfigAlert"> | string
    projectId?: StringFilter<"ConfigAlert"> | string
    configId?: StringNullableFilter<"ConfigAlert"> | string | null
    name?: StringFilter<"ConfigAlert"> | string
    description?: StringNullableFilter<"ConfigAlert"> | string | null
    condition?: StringFilter<"ConfigAlert"> | string
    threshold?: FloatFilter<"ConfigAlert"> | number
    operator?: StringFilter<"ConfigAlert"> | string
    timeWindow?: IntFilter<"ConfigAlert"> | number
    minOccurrences?: IntFilter<"ConfigAlert"> | number
    enabled?: BoolFilter<"ConfigAlert"> | boolean
    webhookUrl?: StringNullableFilter<"ConfigAlert"> | string | null
    emailRecipients?: JsonNullableFilter<"ConfigAlert">
    lastTriggered?: DateTimeNullableFilter<"ConfigAlert"> | Date | string | null
    triggerCount?: IntFilter<"ConfigAlert"> | number
    createdAt?: DateTimeFilter<"ConfigAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigAlert"> | Date | string
  }

  export type ConfigApprovalUpsertWithWhereUniqueWithoutProjectInput = {
    where: ConfigApprovalWhereUniqueInput
    update: XOR<ConfigApprovalUpdateWithoutProjectInput, ConfigApprovalUncheckedUpdateWithoutProjectInput>
    create: XOR<ConfigApprovalCreateWithoutProjectInput, ConfigApprovalUncheckedCreateWithoutProjectInput>
  }

  export type ConfigApprovalUpdateWithWhereUniqueWithoutProjectInput = {
    where: ConfigApprovalWhereUniqueInput
    data: XOR<ConfigApprovalUpdateWithoutProjectInput, ConfigApprovalUncheckedUpdateWithoutProjectInput>
  }

  export type ConfigApprovalUpdateManyWithWhereWithoutProjectInput = {
    where: ConfigApprovalScalarWhereInput
    data: XOR<ConfigApprovalUpdateManyMutationInput, ConfigApprovalUncheckedUpdateManyWithoutProjectInput>
  }

  export type ConfigApprovalScalarWhereInput = {
    AND?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
    OR?: ConfigApprovalScalarWhereInput[]
    NOT?: ConfigApprovalScalarWhereInput | ConfigApprovalScalarWhereInput[]
    id?: StringFilter<"ConfigApproval"> | string
    projectId?: StringFilter<"ConfigApproval"> | string
    configId?: StringFilter<"ConfigApproval"> | string
    changeType?: StringFilter<"ConfigApproval"> | string
    changeData?: JsonFilter<"ConfigApproval">
    status?: StringFilter<"ConfigApproval"> | string
    requiredApprovals?: IntFilter<"ConfigApproval"> | number
    currentApprovals?: IntFilter<"ConfigApproval"> | number
    approvers?: JsonFilter<"ConfigApproval">
    approvals?: JsonFilter<"ConfigApproval">
    requestedBy?: StringFilter<"ConfigApproval"> | string
    requestedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    decidedBy?: StringNullableFilter<"ConfigApproval"> | string | null
    decidedAt?: DateTimeNullableFilter<"ConfigApproval"> | Date | string | null
    decisionComment?: StringNullableFilter<"ConfigApproval"> | string | null
    createdAt?: DateTimeFilter<"ConfigApproval"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigApproval"> | Date | string
  }

  export type LanguageUpsertWithWhereUniqueWithoutProjectInput = {
    where: LanguageWhereUniqueInput
    update: XOR<LanguageUpdateWithoutProjectInput, LanguageUncheckedUpdateWithoutProjectInput>
    create: XOR<LanguageCreateWithoutProjectInput, LanguageUncheckedCreateWithoutProjectInput>
  }

  export type LanguageUpdateWithWhereUniqueWithoutProjectInput = {
    where: LanguageWhereUniqueInput
    data: XOR<LanguageUpdateWithoutProjectInput, LanguageUncheckedUpdateWithoutProjectInput>
  }

  export type LanguageUpdateManyWithWhereWithoutProjectInput = {
    where: LanguageScalarWhereInput
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyWithoutProjectInput>
  }

  export type LanguageScalarWhereInput = {
    AND?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    OR?: LanguageScalarWhereInput[]
    NOT?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    id?: StringFilter<"Language"> | string
    projectId?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringNullableFilter<"Language"> | string | null
    isDefault?: BoolFilter<"Language"> | boolean
    isEnabled?: BoolFilter<"Language"> | boolean
    isRTL?: BoolFilter<"Language"> | boolean
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
  }

  export type LocalizationKeyUpsertWithWhereUniqueWithoutProjectInput = {
    where: LocalizationKeyWhereUniqueInput
    update: XOR<LocalizationKeyUpdateWithoutProjectInput, LocalizationKeyUncheckedUpdateWithoutProjectInput>
    create: XOR<LocalizationKeyCreateWithoutProjectInput, LocalizationKeyUncheckedCreateWithoutProjectInput>
  }

  export type LocalizationKeyUpdateWithWhereUniqueWithoutProjectInput = {
    where: LocalizationKeyWhereUniqueInput
    data: XOR<LocalizationKeyUpdateWithoutProjectInput, LocalizationKeyUncheckedUpdateWithoutProjectInput>
  }

  export type LocalizationKeyUpdateManyWithWhereWithoutProjectInput = {
    where: LocalizationKeyScalarWhereInput
    data: XOR<LocalizationKeyUpdateManyMutationInput, LocalizationKeyUncheckedUpdateManyWithoutProjectInput>
  }

  export type LocalizationKeyScalarWhereInput = {
    AND?: LocalizationKeyScalarWhereInput | LocalizationKeyScalarWhereInput[]
    OR?: LocalizationKeyScalarWhereInput[]
    NOT?: LocalizationKeyScalarWhereInput | LocalizationKeyScalarWhereInput[]
    id?: StringFilter<"LocalizationKey"> | string
    projectId?: StringFilter<"LocalizationKey"> | string
    key?: StringFilter<"LocalizationKey"> | string
    description?: StringNullableFilter<"LocalizationKey"> | string | null
    category?: StringNullableFilter<"LocalizationKey"> | string | null
    platform?: StringNullableFilter<"LocalizationKey"> | string | null
    maxLength?: IntNullableFilter<"LocalizationKey"> | number | null
    screenshot?: StringNullableFilter<"LocalizationKey"> | string | null
    createdAt?: DateTimeFilter<"LocalizationKey"> | Date | string
    updatedAt?: DateTimeFilter<"LocalizationKey"> | Date | string
  }

  export type FeatureFlagsUpsertWithoutProjectInput = {
    update: XOR<FeatureFlagsUpdateWithoutProjectInput, FeatureFlagsUncheckedUpdateWithoutProjectInput>
    create: XOR<FeatureFlagsCreateWithoutProjectInput, FeatureFlagsUncheckedCreateWithoutProjectInput>
    where?: FeatureFlagsWhereInput
  }

  export type FeatureFlagsUpdateToOneWithWhereWithoutProjectInput = {
    where?: FeatureFlagsWhereInput
    data: XOR<FeatureFlagsUpdateWithoutProjectInput, FeatureFlagsUncheckedUpdateWithoutProjectInput>
  }

  export type FeatureFlagsUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagsUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sdkEnabled?: BoolFieldUpdateOperationsInput | boolean
    apiTracking?: BoolFieldUpdateOperationsInput | boolean
    screenTracking?: BoolFieldUpdateOperationsInput | boolean
    crashReporting?: BoolFieldUpdateOperationsInput | boolean
    logging?: BoolFieldUpdateOperationsInput | boolean
    deviceTracking?: BoolFieldUpdateOperationsInput | boolean
    sessionTracking?: BoolFieldUpdateOperationsInput | boolean
    businessConfig?: BoolFieldUpdateOperationsInput | boolean
    localization?: BoolFieldUpdateOperationsInput | boolean
    offlineSupport?: BoolFieldUpdateOperationsInput | boolean
    batchEvents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdkSettingsUpsertWithoutProjectInput = {
    update: XOR<SdkSettingsUpdateWithoutProjectInput, SdkSettingsUncheckedUpdateWithoutProjectInput>
    create: XOR<SdkSettingsCreateWithoutProjectInput, SdkSettingsUncheckedCreateWithoutProjectInput>
    where?: SdkSettingsWhereInput
  }

  export type SdkSettingsUpdateToOneWithWhereWithoutProjectInput = {
    where?: SdkSettingsWhereInput
    data: XOR<SdkSettingsUpdateWithoutProjectInput, SdkSettingsUncheckedUpdateWithoutProjectInput>
  }

  export type SdkSettingsUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SdkSettingsUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingMode?: StringFieldUpdateOperationsInput | string
    captureRequestBodies?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBodies?: BoolFieldUpdateOperationsInput | boolean
    capturePrintStatements?: BoolFieldUpdateOperationsInput | boolean
    sanitizeSensitiveData?: BoolFieldUpdateOperationsInput | boolean
    sensitiveFieldPatterns?: SdkSettingsUpdatesensitiveFieldPatternsInput | string[]
    maxLogQueueSize?: IntFieldUpdateOperationsInput | number
    maxTraceQueueSize?: IntFieldUpdateOperationsInput | number
    flushIntervalSeconds?: IntFieldUpdateOperationsInput | number
    enableBatching?: BoolFieldUpdateOperationsInput | boolean
    minLogLevel?: StringFieldUpdateOperationsInput | string
    verboseErrors?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: ConfigCategoryWhereUniqueInput
    update: XOR<ConfigCategoryUpdateWithoutProjectInput, ConfigCategoryUncheckedUpdateWithoutProjectInput>
    create: XOR<ConfigCategoryCreateWithoutProjectInput, ConfigCategoryUncheckedCreateWithoutProjectInput>
  }

  export type ConfigCategoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: ConfigCategoryWhereUniqueInput
    data: XOR<ConfigCategoryUpdateWithoutProjectInput, ConfigCategoryUncheckedUpdateWithoutProjectInput>
  }

  export type ConfigCategoryUpdateManyWithWhereWithoutProjectInput = {
    where: ConfigCategoryScalarWhereInput
    data: XOR<ConfigCategoryUpdateManyMutationInput, ConfigCategoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ConfigCategoryScalarWhereInput = {
    AND?: ConfigCategoryScalarWhereInput | ConfigCategoryScalarWhereInput[]
    OR?: ConfigCategoryScalarWhereInput[]
    NOT?: ConfigCategoryScalarWhereInput | ConfigCategoryScalarWhereInput[]
    id?: StringFilter<"ConfigCategory"> | string
    projectId?: StringFilter<"ConfigCategory"> | string
    name?: StringFilter<"ConfigCategory"> | string
    label?: StringNullableFilter<"ConfigCategory"> | string | null
    description?: StringNullableFilter<"ConfigCategory"> | string | null
    icon?: StringNullableFilter<"ConfigCategory"> | string | null
    order?: IntFilter<"ConfigCategory"> | number
    isEnabled?: BoolFilter<"ConfigCategory"> | boolean
    createdAt?: DateTimeFilter<"ConfigCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigCategory"> | Date | string
  }

  export type ProjectCreateWithoutDevicesInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDevicesInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDevicesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDevicesInput, ProjectUncheckedCreateWithoutDevicesInput>
  }

  export type LogCreateWithoutDeviceInput = {
    id?: string
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutLogsInput
    session?: SessionCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutDeviceInput = {
    id?: string
    projectId: string
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutDeviceInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput>
  }

  export type LogCreateManyDeviceInputEnvelope = {
    data: LogCreateManyDeviceInput | LogCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type CrashCreateWithoutDeviceInput = {
    id?: string
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCrashesInput
  }

  export type CrashUncheckedCreateWithoutDeviceInput = {
    id?: string
    projectId: string
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashCreateOrConnectWithoutDeviceInput = {
    where: CrashWhereUniqueInput
    create: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput>
  }

  export type CrashCreateManyDeviceInputEnvelope = {
    data: CrashCreateManyDeviceInput | CrashCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type ApiTraceCreateWithoutDeviceInput = {
    id?: string
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiTracesInput
    session?: SessionCreateNestedOneWithoutApiTracesInput
  }

  export type ApiTraceUncheckedCreateWithoutDeviceInput = {
    id?: string
    projectId: string
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceCreateOrConnectWithoutDeviceInput = {
    where: ApiTraceWhereUniqueInput
    create: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput>
  }

  export type ApiTraceCreateManyDeviceInputEnvelope = {
    data: ApiTraceCreateManyDeviceInput | ApiTraceCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutDeviceInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSessionsInput
    apiTraces?: ApiTraceCreateNestedManyWithoutSessionInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutDeviceInput = {
    id?: string
    projectId: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutSessionInput
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutDeviceInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput>
  }

  export type SessionCreateManyDeviceInputEnvelope = {
    data: SessionCreateManyDeviceInput | SessionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDevicesInput = {
    update: XOR<ProjectUpdateWithoutDevicesInput, ProjectUncheckedUpdateWithoutDevicesInput>
    create: XOR<ProjectCreateWithoutDevicesInput, ProjectUncheckedCreateWithoutDevicesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDevicesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDevicesInput, ProjectUncheckedUpdateWithoutDevicesInput>
  }

  export type ProjectUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type LogUpsertWithWhereUniqueWithoutDeviceInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutDeviceInput, LogUncheckedUpdateWithoutDeviceInput>
    create: XOR<LogCreateWithoutDeviceInput, LogUncheckedCreateWithoutDeviceInput>
  }

  export type LogUpdateWithWhereUniqueWithoutDeviceInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutDeviceInput, LogUncheckedUpdateWithoutDeviceInput>
  }

  export type LogUpdateManyWithWhereWithoutDeviceInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutDeviceInput>
  }

  export type CrashUpsertWithWhereUniqueWithoutDeviceInput = {
    where: CrashWhereUniqueInput
    update: XOR<CrashUpdateWithoutDeviceInput, CrashUncheckedUpdateWithoutDeviceInput>
    create: XOR<CrashCreateWithoutDeviceInput, CrashUncheckedCreateWithoutDeviceInput>
  }

  export type CrashUpdateWithWhereUniqueWithoutDeviceInput = {
    where: CrashWhereUniqueInput
    data: XOR<CrashUpdateWithoutDeviceInput, CrashUncheckedUpdateWithoutDeviceInput>
  }

  export type CrashUpdateManyWithWhereWithoutDeviceInput = {
    where: CrashScalarWhereInput
    data: XOR<CrashUpdateManyMutationInput, CrashUncheckedUpdateManyWithoutDeviceInput>
  }

  export type ApiTraceUpsertWithWhereUniqueWithoutDeviceInput = {
    where: ApiTraceWhereUniqueInput
    update: XOR<ApiTraceUpdateWithoutDeviceInput, ApiTraceUncheckedUpdateWithoutDeviceInput>
    create: XOR<ApiTraceCreateWithoutDeviceInput, ApiTraceUncheckedCreateWithoutDeviceInput>
  }

  export type ApiTraceUpdateWithWhereUniqueWithoutDeviceInput = {
    where: ApiTraceWhereUniqueInput
    data: XOR<ApiTraceUpdateWithoutDeviceInput, ApiTraceUncheckedUpdateWithoutDeviceInput>
  }

  export type ApiTraceUpdateManyWithWhereWithoutDeviceInput = {
    where: ApiTraceScalarWhereInput
    data: XOR<ApiTraceUpdateManyMutationInput, ApiTraceUncheckedUpdateManyWithoutDeviceInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutDeviceInput, SessionUncheckedUpdateWithoutDeviceInput>
    create: XOR<SessionCreateWithoutDeviceInput, SessionUncheckedCreateWithoutDeviceInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutDeviceInput, SessionUncheckedUpdateWithoutDeviceInput>
  }

  export type SessionUpdateManyWithWhereWithoutDeviceInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type ProjectCreateWithoutLogsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
  }

  export type DeviceCreateWithoutLogsInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutDevicesInput
    crashes?: CrashCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceCreateNestedManyWithoutDeviceInput
    sessions?: SessionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutLogsInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    crashes?: CrashUncheckedCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutDeviceInput
    sessions?: SessionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutLogsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
  }

  export type SessionCreateWithoutLogsInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSessionsInput
    device?: DeviceCreateNestedOneWithoutSessionsInput
    apiTraces?: ApiTraceCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutLogsInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutLogsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
  }

  export type ProjectUpsertWithoutLogsInput = {
    update: XOR<ProjectUpdateWithoutLogsInput, ProjectUncheckedUpdateWithoutLogsInput>
    create: XOR<ProjectCreateWithoutLogsInput, ProjectUncheckedCreateWithoutLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLogsInput, ProjectUncheckedUpdateWithoutLogsInput>
  }

  export type ProjectUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DeviceUpsertWithoutLogsInput = {
    update: XOR<DeviceUpdateWithoutLogsInput, DeviceUncheckedUpdateWithoutLogsInput>
    create: XOR<DeviceCreateWithoutLogsInput, DeviceUncheckedCreateWithoutLogsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutLogsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutLogsInput, DeviceUncheckedUpdateWithoutLogsInput>
  }

  export type DeviceUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutDevicesNestedInput
    crashes?: CrashUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    crashes?: CrashUncheckedUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type SessionUpsertWithoutLogsInput = {
    update: XOR<SessionUpdateWithoutLogsInput, SessionUncheckedUpdateWithoutLogsInput>
    create: XOR<SessionCreateWithoutLogsInput, SessionUncheckedCreateWithoutLogsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutLogsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutLogsInput, SessionUncheckedUpdateWithoutLogsInput>
  }

  export type SessionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
    device?: DeviceUpdateOneWithoutSessionsNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ProjectCreateWithoutCrashesInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCrashesInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCrashesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCrashesInput, ProjectUncheckedCreateWithoutCrashesInput>
  }

  export type DeviceCreateWithoutCrashesInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutDevicesInput
    logs?: LogCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceCreateNestedManyWithoutDeviceInput
    sessions?: SessionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutCrashesInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutDeviceInput
    sessions?: SessionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutCrashesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutCrashesInput, DeviceUncheckedCreateWithoutCrashesInput>
  }

  export type ProjectUpsertWithoutCrashesInput = {
    update: XOR<ProjectUpdateWithoutCrashesInput, ProjectUncheckedUpdateWithoutCrashesInput>
    create: XOR<ProjectCreateWithoutCrashesInput, ProjectUncheckedCreateWithoutCrashesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCrashesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCrashesInput, ProjectUncheckedUpdateWithoutCrashesInput>
  }

  export type ProjectUpdateWithoutCrashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCrashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DeviceUpsertWithoutCrashesInput = {
    update: XOR<DeviceUpdateWithoutCrashesInput, DeviceUncheckedUpdateWithoutCrashesInput>
    create: XOR<DeviceCreateWithoutCrashesInput, DeviceUncheckedCreateWithoutCrashesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutCrashesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutCrashesInput, DeviceUncheckedUpdateWithoutCrashesInput>
  }

  export type DeviceUpdateWithoutCrashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutDevicesNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutCrashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type ProjectCreateWithoutApiTracesInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiTracesInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiTracesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiTracesInput, ProjectUncheckedCreateWithoutApiTracesInput>
  }

  export type DeviceCreateWithoutApiTracesInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutDevicesInput
    logs?: LogCreateNestedManyWithoutDeviceInput
    crashes?: CrashCreateNestedManyWithoutDeviceInput
    sessions?: SessionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutApiTracesInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
    crashes?: CrashUncheckedCreateNestedManyWithoutDeviceInput
    sessions?: SessionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutApiTracesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutApiTracesInput, DeviceUncheckedCreateWithoutApiTracesInput>
  }

  export type SessionCreateWithoutApiTracesInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSessionsInput
    device?: DeviceCreateNestedOneWithoutSessionsInput
    logs?: LogCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutApiTracesInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutApiTracesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutApiTracesInput, SessionUncheckedCreateWithoutApiTracesInput>
  }

  export type ProjectUpsertWithoutApiTracesInput = {
    update: XOR<ProjectUpdateWithoutApiTracesInput, ProjectUncheckedUpdateWithoutApiTracesInput>
    create: XOR<ProjectCreateWithoutApiTracesInput, ProjectUncheckedCreateWithoutApiTracesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiTracesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiTracesInput, ProjectUncheckedUpdateWithoutApiTracesInput>
  }

  export type ProjectUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DeviceUpsertWithoutApiTracesInput = {
    update: XOR<DeviceUpdateWithoutApiTracesInput, DeviceUncheckedUpdateWithoutApiTracesInput>
    create: XOR<DeviceCreateWithoutApiTracesInput, DeviceUncheckedCreateWithoutApiTracesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutApiTracesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutApiTracesInput, DeviceUncheckedUpdateWithoutApiTracesInput>
  }

  export type DeviceUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutDevicesNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type SessionUpsertWithoutApiTracesInput = {
    update: XOR<SessionUpdateWithoutApiTracesInput, SessionUncheckedUpdateWithoutApiTracesInput>
    create: XOR<SessionCreateWithoutApiTracesInput, SessionUncheckedCreateWithoutApiTracesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutApiTracesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutApiTracesInput, SessionUncheckedUpdateWithoutApiTracesInput>
  }

  export type SessionUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
    device?: DeviceUpdateOneWithoutSessionsNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutApiTracesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ProjectCreateWithoutApiConfigsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiConfigsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiConfigsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiConfigsInput, ProjectUncheckedCreateWithoutApiConfigsInput>
  }

  export type ProjectUpsertWithoutApiConfigsInput = {
    update: XOR<ProjectUpdateWithoutApiConfigsInput, ProjectUncheckedUpdateWithoutApiConfigsInput>
    create: XOR<ProjectCreateWithoutApiConfigsInput, ProjectUncheckedCreateWithoutApiConfigsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiConfigsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiConfigsInput, ProjectUncheckedUpdateWithoutApiConfigsInput>
  }

  export type ProjectUpdateWithoutApiConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSessionsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSessionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
  }

  export type DeviceCreateWithoutSessionsInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutDevicesInput
    logs?: LogCreateNestedManyWithoutDeviceInput
    crashes?: CrashCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSessionsInput = {
    id?: string
    projectId?: string | null
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
    logs?: LogUncheckedCreateNestedManyWithoutDeviceInput
    crashes?: CrashUncheckedCreateNestedManyWithoutDeviceInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSessionsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSessionsInput, DeviceUncheckedCreateWithoutSessionsInput>
  }

  export type ApiTraceCreateWithoutSessionInput = {
    id?: string
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiTracesInput
    device?: DeviceCreateNestedOneWithoutApiTracesInput
  }

  export type ApiTraceUncheckedCreateWithoutSessionInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceCreateOrConnectWithoutSessionInput = {
    where: ApiTraceWhereUniqueInput
    create: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput>
  }

  export type ApiTraceCreateManySessionInputEnvelope = {
    data: ApiTraceCreateManySessionInput | ApiTraceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutSessionInput = {
    id?: string
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutLogsInput
    device?: DeviceCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutSessionInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutSessionInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput>
  }

  export type LogCreateManySessionInputEnvelope = {
    data: LogCreateManySessionInput | LogCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSessionsInput = {
    update: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DeviceUpsertWithoutSessionsInput = {
    update: XOR<DeviceUpdateWithoutSessionsInput, DeviceUncheckedUpdateWithoutSessionsInput>
    create: XOR<DeviceCreateWithoutSessionsInput, DeviceUncheckedCreateWithoutSessionsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutSessionsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutSessionsInput, DeviceUncheckedUpdateWithoutSessionsInput>
  }

  export type DeviceUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutDevicesNestedInput
    logs?: LogUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type ApiTraceUpsertWithWhereUniqueWithoutSessionInput = {
    where: ApiTraceWhereUniqueInput
    update: XOR<ApiTraceUpdateWithoutSessionInput, ApiTraceUncheckedUpdateWithoutSessionInput>
    create: XOR<ApiTraceCreateWithoutSessionInput, ApiTraceUncheckedCreateWithoutSessionInput>
  }

  export type ApiTraceUpdateWithWhereUniqueWithoutSessionInput = {
    where: ApiTraceWhereUniqueInput
    data: XOR<ApiTraceUpdateWithoutSessionInput, ApiTraceUncheckedUpdateWithoutSessionInput>
  }

  export type ApiTraceUpdateManyWithWhereWithoutSessionInput = {
    where: ApiTraceScalarWhereInput
    data: XOR<ApiTraceUpdateManyMutationInput, ApiTraceUncheckedUpdateManyWithoutSessionInput>
  }

  export type LogUpsertWithWhereUniqueWithoutSessionInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutSessionInput, LogUncheckedUpdateWithoutSessionInput>
    create: XOR<LogCreateWithoutSessionInput, LogUncheckedCreateWithoutSessionInput>
  }

  export type LogUpdateWithWhereUniqueWithoutSessionInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutSessionInput, LogUncheckedUpdateWithoutSessionInput>
  }

  export type LogUpdateManyWithWhereWithoutSessionInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutSessionInput>
  }

  export type ProjectCreateWithoutNotificationSettingsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNotificationSettingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNotificationSettingsInput, ProjectUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type ProjectUpsertWithoutNotificationSettingsInput = {
    update: XOR<ProjectUpdateWithoutNotificationSettingsInput, ProjectUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<ProjectCreateWithoutNotificationSettingsInput, ProjectUncheckedCreateWithoutNotificationSettingsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutNotificationSettingsInput, ProjectUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type ProjectUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutApiAlertsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiAlertsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiAlertsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiAlertsInput, ProjectUncheckedCreateWithoutApiAlertsInput>
  }

  export type MonitoredErrorCreateWithoutAlertInput = {
    id?: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredErrorUncheckedCreateWithoutAlertInput = {
    id?: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredErrorCreateOrConnectWithoutAlertInput = {
    where: MonitoredErrorWhereUniqueInput
    create: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput>
  }

  export type MonitoredErrorCreateManyAlertInputEnvelope = {
    data: MonitoredErrorCreateManyAlertInput | MonitoredErrorCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutApiAlertsInput = {
    update: XOR<ProjectUpdateWithoutApiAlertsInput, ProjectUncheckedUpdateWithoutApiAlertsInput>
    create: XOR<ProjectCreateWithoutApiAlertsInput, ProjectUncheckedCreateWithoutApiAlertsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiAlertsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiAlertsInput, ProjectUncheckedUpdateWithoutApiAlertsInput>
  }

  export type ProjectUpdateWithoutApiAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MonitoredErrorUpsertWithWhereUniqueWithoutAlertInput = {
    where: MonitoredErrorWhereUniqueInput
    update: XOR<MonitoredErrorUpdateWithoutAlertInput, MonitoredErrorUncheckedUpdateWithoutAlertInput>
    create: XOR<MonitoredErrorCreateWithoutAlertInput, MonitoredErrorUncheckedCreateWithoutAlertInput>
  }

  export type MonitoredErrorUpdateWithWhereUniqueWithoutAlertInput = {
    where: MonitoredErrorWhereUniqueInput
    data: XOR<MonitoredErrorUpdateWithoutAlertInput, MonitoredErrorUncheckedUpdateWithoutAlertInput>
  }

  export type MonitoredErrorUpdateManyWithWhereWithoutAlertInput = {
    where: MonitoredErrorScalarWhereInput
    data: XOR<MonitoredErrorUpdateManyMutationInput, MonitoredErrorUncheckedUpdateManyWithoutAlertInput>
  }

  export type MonitoredErrorScalarWhereInput = {
    AND?: MonitoredErrorScalarWhereInput | MonitoredErrorScalarWhereInput[]
    OR?: MonitoredErrorScalarWhereInput[]
    NOT?: MonitoredErrorScalarWhereInput | MonitoredErrorScalarWhereInput[]
    id?: StringFilter<"MonitoredError"> | string
    alertId?: StringFilter<"MonitoredError"> | string
    projectId?: StringFilter<"MonitoredError"> | string
    errorType?: StringFilter<"MonitoredError"> | string
    errorCode?: StringFilter<"MonitoredError"> | string
    endpoint?: StringFilter<"MonitoredError"> | string
    method?: StringFilter<"MonitoredError"> | string
    statusCode?: IntNullableFilter<"MonitoredError"> | number | null
    requestBody?: StringNullableFilter<"MonitoredError"> | string | null
    responseBody?: StringNullableFilter<"MonitoredError"> | string | null
    firstOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    lastOccurrence?: DateTimeFilter<"MonitoredError"> | Date | string
    occurrenceCount?: IntFilter<"MonitoredError"> | number
    affectedDevices?: StringNullableListFilter<"MonitoredError">
    affectedSessions?: StringNullableListFilter<"MonitoredError">
    lastTraceId?: StringNullableFilter<"MonitoredError"> | string | null
    lastNotifiedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    notificationCount?: IntFilter<"MonitoredError"> | number
    isResolved?: BoolFilter<"MonitoredError"> | boolean
    resolvedAt?: DateTimeNullableFilter<"MonitoredError"> | Date | string | null
    resolvedBy?: StringNullableFilter<"MonitoredError"> | string | null
    notes?: StringNullableFilter<"MonitoredError"> | string | null
    createdAt?: DateTimeFilter<"MonitoredError"> | Date | string
    updatedAt?: DateTimeFilter<"MonitoredError"> | Date | string
  }

  export type ApiAlertCreateWithoutMonitoredErrorsInput = {
    id?: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiAlertsInput
  }

  export type ApiAlertUncheckedCreateWithoutMonitoredErrorsInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiAlertCreateOrConnectWithoutMonitoredErrorsInput = {
    where: ApiAlertWhereUniqueInput
    create: XOR<ApiAlertCreateWithoutMonitoredErrorsInput, ApiAlertUncheckedCreateWithoutMonitoredErrorsInput>
  }

  export type ApiAlertUpsertWithoutMonitoredErrorsInput = {
    update: XOR<ApiAlertUpdateWithoutMonitoredErrorsInput, ApiAlertUncheckedUpdateWithoutMonitoredErrorsInput>
    create: XOR<ApiAlertCreateWithoutMonitoredErrorsInput, ApiAlertUncheckedCreateWithoutMonitoredErrorsInput>
    where?: ApiAlertWhereInput
  }

  export type ApiAlertUpdateToOneWithWhereWithoutMonitoredErrorsInput = {
    where?: ApiAlertWhereInput
    data: XOR<ApiAlertUpdateWithoutMonitoredErrorsInput, ApiAlertUncheckedUpdateWithoutMonitoredErrorsInput>
  }

  export type ApiAlertUpdateWithoutMonitoredErrorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiAlertsNestedInput
  }

  export type ApiAlertUncheckedUpdateWithoutMonitoredErrorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutBusinessConfigsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBusinessConfigsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBusinessConfigsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBusinessConfigsInput, ProjectUncheckedCreateWithoutBusinessConfigsInput>
  }

  export type ConfigAlertCreateWithoutConfigInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigAlertsInput
    events?: ConfigAlertEventCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertUncheckedCreateWithoutConfigInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ConfigAlertEventUncheckedCreateNestedManyWithoutAlertInput
  }

  export type ConfigAlertCreateOrConnectWithoutConfigInput = {
    where: ConfigAlertWhereUniqueInput
    create: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput>
  }

  export type ConfigAlertCreateManyConfigInputEnvelope = {
    data: ConfigAlertCreateManyConfigInput | ConfigAlertCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type ConfigApprovalCreateWithoutConfigInput = {
    id?: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigApprovalsInput
  }

  export type ConfigApprovalUncheckedCreateWithoutConfigInput = {
    id?: string
    projectId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalCreateOrConnectWithoutConfigInput = {
    where: ConfigApprovalWhereUniqueInput
    create: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput>
  }

  export type ConfigApprovalCreateManyConfigInputEnvelope = {
    data: ConfigApprovalCreateManyConfigInput | ConfigApprovalCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutBusinessConfigsInput = {
    update: XOR<ProjectUpdateWithoutBusinessConfigsInput, ProjectUncheckedUpdateWithoutBusinessConfigsInput>
    create: XOR<ProjectCreateWithoutBusinessConfigsInput, ProjectUncheckedCreateWithoutBusinessConfigsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBusinessConfigsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBusinessConfigsInput, ProjectUncheckedUpdateWithoutBusinessConfigsInput>
  }

  export type ProjectUpdateWithoutBusinessConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBusinessConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ConfigAlertUpsertWithWhereUniqueWithoutConfigInput = {
    where: ConfigAlertWhereUniqueInput
    update: XOR<ConfigAlertUpdateWithoutConfigInput, ConfigAlertUncheckedUpdateWithoutConfigInput>
    create: XOR<ConfigAlertCreateWithoutConfigInput, ConfigAlertUncheckedCreateWithoutConfigInput>
  }

  export type ConfigAlertUpdateWithWhereUniqueWithoutConfigInput = {
    where: ConfigAlertWhereUniqueInput
    data: XOR<ConfigAlertUpdateWithoutConfigInput, ConfigAlertUncheckedUpdateWithoutConfigInput>
  }

  export type ConfigAlertUpdateManyWithWhereWithoutConfigInput = {
    where: ConfigAlertScalarWhereInput
    data: XOR<ConfigAlertUpdateManyMutationInput, ConfigAlertUncheckedUpdateManyWithoutConfigInput>
  }

  export type ConfigApprovalUpsertWithWhereUniqueWithoutConfigInput = {
    where: ConfigApprovalWhereUniqueInput
    update: XOR<ConfigApprovalUpdateWithoutConfigInput, ConfigApprovalUncheckedUpdateWithoutConfigInput>
    create: XOR<ConfigApprovalCreateWithoutConfigInput, ConfigApprovalUncheckedCreateWithoutConfigInput>
  }

  export type ConfigApprovalUpdateWithWhereUniqueWithoutConfigInput = {
    where: ConfigApprovalWhereUniqueInput
    data: XOR<ConfigApprovalUpdateWithoutConfigInput, ConfigApprovalUncheckedUpdateWithoutConfigInput>
  }

  export type ConfigApprovalUpdateManyWithWhereWithoutConfigInput = {
    where: ConfigApprovalScalarWhereInput
    data: XOR<ConfigApprovalUpdateManyMutationInput, ConfigApprovalUncheckedUpdateManyWithoutConfigInput>
  }

  export type ProjectCreateWithoutLanguagesInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLanguagesInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLanguagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLanguagesInput, ProjectUncheckedCreateWithoutLanguagesInput>
  }

  export type TranslationCreateWithoutLanguageInput = {
    id?: string
    projectId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    key: LocalizationKeyCreateNestedOneWithoutTranslationsInput
  }

  export type TranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    projectId: string
    keyId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationCreateOrConnectWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TranslationCreateManyLanguageInputEnvelope = {
    data: TranslationCreateManyLanguageInput | TranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutLanguagesInput = {
    update: XOR<ProjectUpdateWithoutLanguagesInput, ProjectUncheckedUpdateWithoutLanguagesInput>
    create: XOR<ProjectCreateWithoutLanguagesInput, ProjectUncheckedCreateWithoutLanguagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLanguagesInput, ProjectUncheckedUpdateWithoutLanguagesInput>
  }

  export type ProjectUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutLanguageInput, TranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutLanguageInput, TranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type TranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type TranslationScalarWhereInput = {
    AND?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    OR?: TranslationScalarWhereInput[]
    NOT?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    id?: StringFilter<"Translation"> | string
    projectId?: StringFilter<"Translation"> | string
    keyId?: StringFilter<"Translation"> | string
    languageId?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    isReviewed?: BoolFilter<"Translation"> | boolean
    reviewedBy?: StringNullableFilter<"Translation"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
  }

  export type ProjectCreateWithoutLocalizationKeysInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLocalizationKeysInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLocalizationKeysInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLocalizationKeysInput, ProjectUncheckedCreateWithoutLocalizationKeysInput>
  }

  export type TranslationCreateWithoutKeyInput = {
    id?: string
    projectId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutTranslationsInput
  }

  export type TranslationUncheckedCreateWithoutKeyInput = {
    id?: string
    projectId: string
    languageId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationCreateOrConnectWithoutKeyInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput>
  }

  export type TranslationCreateManyKeyInputEnvelope = {
    data: TranslationCreateManyKeyInput | TranslationCreateManyKeyInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutLocalizationKeysInput = {
    update: XOR<ProjectUpdateWithoutLocalizationKeysInput, ProjectUncheckedUpdateWithoutLocalizationKeysInput>
    create: XOR<ProjectCreateWithoutLocalizationKeysInput, ProjectUncheckedCreateWithoutLocalizationKeysInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLocalizationKeysInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLocalizationKeysInput, ProjectUncheckedUpdateWithoutLocalizationKeysInput>
  }

  export type ProjectUpdateWithoutLocalizationKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLocalizationKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TranslationUpsertWithWhereUniqueWithoutKeyInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutKeyInput, TranslationUncheckedUpdateWithoutKeyInput>
    create: XOR<TranslationCreateWithoutKeyInput, TranslationUncheckedCreateWithoutKeyInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutKeyInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutKeyInput, TranslationUncheckedUpdateWithoutKeyInput>
  }

  export type TranslationUpdateManyWithWhereWithoutKeyInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutKeyInput>
  }

  export type LocalizationKeyCreateWithoutTranslationsInput = {
    id?: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLocalizationKeysInput
  }

  export type LocalizationKeyUncheckedCreateWithoutTranslationsInput = {
    id?: string
    projectId: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalizationKeyCreateOrConnectWithoutTranslationsInput = {
    where: LocalizationKeyWhereUniqueInput
    create: XOR<LocalizationKeyCreateWithoutTranslationsInput, LocalizationKeyUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageCreateWithoutTranslationsInput = {
    id?: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLanguagesInput
  }

  export type LanguageUncheckedCreateWithoutTranslationsInput = {
    id?: string
    projectId: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageCreateOrConnectWithoutTranslationsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
  }

  export type LocalizationKeyUpsertWithoutTranslationsInput = {
    update: XOR<LocalizationKeyUpdateWithoutTranslationsInput, LocalizationKeyUncheckedUpdateWithoutTranslationsInput>
    create: XOR<LocalizationKeyCreateWithoutTranslationsInput, LocalizationKeyUncheckedCreateWithoutTranslationsInput>
    where?: LocalizationKeyWhereInput
  }

  export type LocalizationKeyUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: LocalizationKeyWhereInput
    data: XOR<LocalizationKeyUpdateWithoutTranslationsInput, LocalizationKeyUncheckedUpdateWithoutTranslationsInput>
  }

  export type LocalizationKeyUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLocalizationKeysNestedInput
  }

  export type LocalizationKeyUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUpsertWithoutTranslationsInput = {
    update: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type LanguageUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutFeatureFlagsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFeatureFlagsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFeatureFlagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFeatureFlagsInput, ProjectUncheckedCreateWithoutFeatureFlagsInput>
  }

  export type ProjectUpsertWithoutFeatureFlagsInput = {
    update: XOR<ProjectUpdateWithoutFeatureFlagsInput, ProjectUncheckedUpdateWithoutFeatureFlagsInput>
    create: XOR<ProjectCreateWithoutFeatureFlagsInput, ProjectUncheckedCreateWithoutFeatureFlagsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFeatureFlagsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFeatureFlagsInput, ProjectUncheckedUpdateWithoutFeatureFlagsInput>
  }

  export type ProjectUpdateWithoutFeatureFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFeatureFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSdkSettingsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSdkSettingsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSdkSettingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSdkSettingsInput, ProjectUncheckedCreateWithoutSdkSettingsInput>
  }

  export type ProjectUpsertWithoutSdkSettingsInput = {
    update: XOR<ProjectUpdateWithoutSdkSettingsInput, ProjectUncheckedUpdateWithoutSdkSettingsInput>
    create: XOR<ProjectCreateWithoutSdkSettingsInput, ProjectUncheckedCreateWithoutSdkSettingsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSdkSettingsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSdkSettingsInput, ProjectUncheckedUpdateWithoutSdkSettingsInput>
  }

  export type ProjectUpdateWithoutSdkSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSdkSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutConfigCategoriesInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutConfigCategoriesInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutConfigCategoriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutConfigCategoriesInput, ProjectUncheckedCreateWithoutConfigCategoriesInput>
  }

  export type ProjectUpsertWithoutConfigCategoriesInput = {
    update: XOR<ProjectUpdateWithoutConfigCategoriesInput, ProjectUncheckedUpdateWithoutConfigCategoriesInput>
    create: XOR<ProjectCreateWithoutConfigCategoriesInput, ProjectUncheckedCreateWithoutConfigCategoriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutConfigCategoriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutConfigCategoriesInput, ProjectUncheckedUpdateWithoutConfigCategoriesInput>
  }

  export type ProjectUpdateWithoutConfigCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutConfigCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    enforcementState?: EnforcementStateUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    enabled?: BoolFilter<"Subscription"> | boolean
    trialStartDate?: DateTimeFilter<"Subscription"> | Date | string
    trialEndDate?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Subscription"> | string | null
    disabledBy?: StringNullableFilter<"Subscription"> | string | null
    disabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    enabledBy?: StringNullableFilter<"Subscription"> | string | null
    enabledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    quotaMaxProjects?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxDevices?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxMockEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiEndpoints?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxApiRequests?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLogs?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxSessions?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxCrashes?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxBusinessConfigKeys?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationLanguages?: IntNullableFilter<"Subscription"> | number | null
    quotaMaxLocalizationKeys?: IntNullableFilter<"Subscription"> | number | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    isAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    price?: number
    currency?: string
    interval?: string
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: number | null
    maxDevices?: number | null
    maxMockEndpoints?: number | null
    maxApiEndpoints?: number | null
    maxApiRequests?: number | null
    maxLogs?: number | null
    maxSessions?: number | null
    maxCrashes?: number | null
    maxBusinessConfigKeys?: number | null
    maxLocalizationLanguages?: number | null
    maxLocalizationKeys?: number | null
    retentionDays?: number | null
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    price?: number
    currency?: string
    interval?: string
    isActive?: boolean
    isPublic?: boolean
    maxProjects?: number | null
    maxDevices?: number | null
    maxMockEndpoints?: number | null
    maxApiEndpoints?: number | null
    maxApiRequests?: number | null
    maxLogs?: number | null
    maxSessions?: number | null
    maxCrashes?: number | null
    maxBusinessConfigKeys?: number | null
    maxLocalizationLanguages?: number | null
    maxLocalizationKeys?: number | null
    retentionDays?: number | null
    allowApiTracking?: boolean
    allowScreenTracking?: boolean
    allowCrashReporting?: boolean
    allowLogging?: boolean
    allowBusinessConfig?: boolean
    allowLocalization?: boolean
    allowCustomDomains?: boolean
    allowWebhooks?: boolean
    allowTeamMembers?: boolean
    allowPrioritySupport?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type EnforcementStateCreateWithoutSubscriptionInput = {
    id?: string
    state?: string
    warnEnteredAt?: Date | string | null
    graceEnteredAt?: Date | string | null
    graceEndsAt?: Date | string | null
    degradedEnteredAt?: Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: Date | string
    nextEvaluationAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnforcementStateUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    state?: string
    warnEnteredAt?: Date | string | null
    graceEnteredAt?: Date | string | null
    graceEndsAt?: Date | string | null
    degradedEnteredAt?: Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: Date | string
    nextEvaluationAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnforcementStateCreateOrConnectWithoutSubscriptionInput = {
    where: EnforcementStateWhereUniqueInput
    create: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    maxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    maxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    maxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    maxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    maxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    maxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    maxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    maxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    retentionDays?: NullableIntFieldUpdateOperationsInput | number | null
    allowApiTracking?: BoolFieldUpdateOperationsInput | boolean
    allowScreenTracking?: BoolFieldUpdateOperationsInput | boolean
    allowCrashReporting?: BoolFieldUpdateOperationsInput | boolean
    allowLogging?: BoolFieldUpdateOperationsInput | boolean
    allowBusinessConfig?: BoolFieldUpdateOperationsInput | boolean
    allowLocalization?: BoolFieldUpdateOperationsInput | boolean
    allowCustomDomains?: BoolFieldUpdateOperationsInput | boolean
    allowWebhooks?: BoolFieldUpdateOperationsInput | boolean
    allowTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    allowPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    enforcementConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    subscriptionId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    periodStart?: DateTimeFilter<"Invoice"> | Date | string
    periodEnd?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    lineItems?: JsonNullableFilter<"Invoice">
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type EnforcementStateUpsertWithoutSubscriptionInput = {
    update: XOR<EnforcementStateUpdateWithoutSubscriptionInput, EnforcementStateUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<EnforcementStateCreateWithoutSubscriptionInput, EnforcementStateUncheckedCreateWithoutSubscriptionInput>
    where?: EnforcementStateWhereInput
  }

  export type EnforcementStateUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: EnforcementStateWhereInput
    data: XOR<EnforcementStateUpdateWithoutSubscriptionInput, EnforcementStateUncheckedUpdateWithoutSubscriptionInput>
  }

  export type EnforcementStateUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnforcementStateUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    warnEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    graceEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    degradedEnteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectivePolicy?: NullableJsonNullValueInput | InputJsonValue
    triggeredMetrics?: NullableJsonNullValueInput | InputJsonValue
    lastEvaluatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextEvaluationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateWithoutEnforcementStateInput = {
    id?: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutEnforcementStateInput = {
    id?: string
    userId: string
    planId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutEnforcementStateInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutEnforcementStateInput, SubscriptionUncheckedCreateWithoutEnforcementStateInput>
  }

  export type SubscriptionUpsertWithoutEnforcementStateInput = {
    update: XOR<SubscriptionUpdateWithoutEnforcementStateInput, SubscriptionUncheckedUpdateWithoutEnforcementStateInput>
    create: XOR<SubscriptionCreateWithoutEnforcementStateInput, SubscriptionUncheckedCreateWithoutEnforcementStateInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutEnforcementStateInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutEnforcementStateInput, SubscriptionUncheckedUpdateWithoutEnforcementStateInput>
  }

  export type SubscriptionUpdateWithoutEnforcementStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutEnforcementStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    enforcementState?: EnforcementStateCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    planId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enforcementState?: EnforcementStateUncheckedCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    enforcementState?: EnforcementStateUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enforcementState?: EnforcementStateUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type ProjectCreateWithoutBuildsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBuildsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBuildsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBuildsInput, ProjectUncheckedCreateWithoutBuildsInput>
  }

  export type BuildFeatureCreateWithoutBuildInput = {
    id?: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
  }

  export type BuildFeatureUncheckedCreateWithoutBuildInput = {
    id?: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
  }

  export type BuildFeatureCreateOrConnectWithoutBuildInput = {
    where: BuildFeatureWhereUniqueInput
    create: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput>
  }

  export type BuildFeatureCreateManyBuildInputEnvelope = {
    data: BuildFeatureCreateManyBuildInput | BuildFeatureCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type BuildChangeLogCreateWithoutBuildInput = {
    id?: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type BuildChangeLogUncheckedCreateWithoutBuildInput = {
    id?: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type BuildChangeLogCreateOrConnectWithoutBuildInput = {
    where: BuildChangeLogWhereUniqueInput
    create: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput>
  }

  export type BuildChangeLogCreateManyBuildInputEnvelope = {
    data: BuildChangeLogCreateManyBuildInput | BuildChangeLogCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type BuildModeCreateWithoutPreviewBuildInput = {
    id?: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBuildModeInput
    productionBuild?: BuildCreateNestedOneWithoutProductionModeInput
  }

  export type BuildModeUncheckedCreateWithoutPreviewBuildInput = {
    id?: string
    projectId: string
    productionBuildId?: string | null
    updatedAt?: Date | string
  }

  export type BuildModeCreateOrConnectWithoutPreviewBuildInput = {
    where: BuildModeWhereUniqueInput
    create: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
  }

  export type BuildModeCreateWithoutProductionBuildInput = {
    id?: string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBuildModeInput
    previewBuild?: BuildCreateNestedOneWithoutPreviewModeInput
  }

  export type BuildModeUncheckedCreateWithoutProductionBuildInput = {
    id?: string
    projectId: string
    previewBuildId?: string | null
    updatedAt?: Date | string
  }

  export type BuildModeCreateOrConnectWithoutProductionBuildInput = {
    where: BuildModeWhereUniqueInput
    create: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
  }

  export type ProjectUpsertWithoutBuildsInput = {
    update: XOR<ProjectUpdateWithoutBuildsInput, ProjectUncheckedUpdateWithoutBuildsInput>
    create: XOR<ProjectCreateWithoutBuildsInput, ProjectUncheckedCreateWithoutBuildsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBuildsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBuildsInput, ProjectUncheckedUpdateWithoutBuildsInput>
  }

  export type ProjectUpdateWithoutBuildsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBuildsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BuildFeatureUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildFeatureWhereUniqueInput
    update: XOR<BuildFeatureUpdateWithoutBuildInput, BuildFeatureUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildFeatureCreateWithoutBuildInput, BuildFeatureUncheckedCreateWithoutBuildInput>
  }

  export type BuildFeatureUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildFeatureWhereUniqueInput
    data: XOR<BuildFeatureUpdateWithoutBuildInput, BuildFeatureUncheckedUpdateWithoutBuildInput>
  }

  export type BuildFeatureUpdateManyWithWhereWithoutBuildInput = {
    where: BuildFeatureScalarWhereInput
    data: XOR<BuildFeatureUpdateManyMutationInput, BuildFeatureUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildFeatureScalarWhereInput = {
    AND?: BuildFeatureScalarWhereInput | BuildFeatureScalarWhereInput[]
    OR?: BuildFeatureScalarWhereInput[]
    NOT?: BuildFeatureScalarWhereInput | BuildFeatureScalarWhereInput[]
    id?: StringFilter<"BuildFeature"> | string
    buildId?: StringFilter<"BuildFeature"> | string
    featureType?: StringFilter<"BuildFeature"> | string
    snapshotData?: JsonFilter<"BuildFeature">
    itemCount?: IntFilter<"BuildFeature"> | number
    createdAt?: DateTimeFilter<"BuildFeature"> | Date | string
  }

  export type BuildChangeLogUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildChangeLogWhereUniqueInput
    update: XOR<BuildChangeLogUpdateWithoutBuildInput, BuildChangeLogUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildChangeLogCreateWithoutBuildInput, BuildChangeLogUncheckedCreateWithoutBuildInput>
  }

  export type BuildChangeLogUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildChangeLogWhereUniqueInput
    data: XOR<BuildChangeLogUpdateWithoutBuildInput, BuildChangeLogUncheckedUpdateWithoutBuildInput>
  }

  export type BuildChangeLogUpdateManyWithWhereWithoutBuildInput = {
    where: BuildChangeLogScalarWhereInput
    data: XOR<BuildChangeLogUpdateManyMutationInput, BuildChangeLogUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildChangeLogScalarWhereInput = {
    AND?: BuildChangeLogScalarWhereInput | BuildChangeLogScalarWhereInput[]
    OR?: BuildChangeLogScalarWhereInput[]
    NOT?: BuildChangeLogScalarWhereInput | BuildChangeLogScalarWhereInput[]
    id?: StringFilter<"BuildChangeLog"> | string
    buildId?: StringFilter<"BuildChangeLog"> | string
    featureType?: StringFilter<"BuildChangeLog"> | string
    changeType?: StringFilter<"BuildChangeLog"> | string
    itemKey?: StringFilter<"BuildChangeLog"> | string
    itemLabel?: StringNullableFilter<"BuildChangeLog"> | string | null
    oldValue?: JsonNullableFilter<"BuildChangeLog">
    newValue?: JsonNullableFilter<"BuildChangeLog">
    changedBy?: StringNullableFilter<"BuildChangeLog"> | string | null
    changedAt?: DateTimeFilter<"BuildChangeLog"> | Date | string
  }

  export type BuildModeUpsertWithoutPreviewBuildInput = {
    update: XOR<BuildModeUpdateWithoutPreviewBuildInput, BuildModeUncheckedUpdateWithoutPreviewBuildInput>
    create: XOR<BuildModeCreateWithoutPreviewBuildInput, BuildModeUncheckedCreateWithoutPreviewBuildInput>
    where?: BuildModeWhereInput
  }

  export type BuildModeUpdateToOneWithWhereWithoutPreviewBuildInput = {
    where?: BuildModeWhereInput
    data: XOR<BuildModeUpdateWithoutPreviewBuildInput, BuildModeUncheckedUpdateWithoutPreviewBuildInput>
  }

  export type BuildModeUpdateWithoutPreviewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBuildModeNestedInput
    productionBuild?: BuildUpdateOneWithoutProductionModeNestedInput
  }

  export type BuildModeUncheckedUpdateWithoutPreviewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    productionBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildModeUpsertWithoutProductionBuildInput = {
    update: XOR<BuildModeUpdateWithoutProductionBuildInput, BuildModeUncheckedUpdateWithoutProductionBuildInput>
    create: XOR<BuildModeCreateWithoutProductionBuildInput, BuildModeUncheckedCreateWithoutProductionBuildInput>
    where?: BuildModeWhereInput
  }

  export type BuildModeUpdateToOneWithWhereWithoutProductionBuildInput = {
    where?: BuildModeWhereInput
    data: XOR<BuildModeUpdateWithoutProductionBuildInput, BuildModeUncheckedUpdateWithoutProductionBuildInput>
  }

  export type BuildModeUpdateWithoutProductionBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBuildModeNestedInput
    previewBuild?: BuildUpdateOneWithoutPreviewModeNestedInput
  }

  export type BuildModeUncheckedUpdateWithoutProductionBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    previewBuildId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildCreateWithoutFeaturesInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    project: ProjectCreateNestedOneWithoutBuildsInput
    changeLogs?: BuildChangeLogCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUncheckedCreateWithoutFeaturesInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    changeLogs?: BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildCreateOrConnectWithoutFeaturesInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutFeaturesInput, BuildUncheckedCreateWithoutFeaturesInput>
  }

  export type BuildUpsertWithoutFeaturesInput = {
    update: XOR<BuildUpdateWithoutFeaturesInput, BuildUncheckedUpdateWithoutFeaturesInput>
    create: XOR<BuildCreateWithoutFeaturesInput, BuildUncheckedCreateWithoutFeaturesInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutFeaturesInput, BuildUncheckedUpdateWithoutFeaturesInput>
  }

  export type BuildUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBuildsNestedInput
    changeLogs?: BuildChangeLogUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    changeLogs?: BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput
  }

  export type ProjectCreateWithoutBuildModeInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBuildModeInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBuildModeInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBuildModeInput, ProjectUncheckedCreateWithoutBuildModeInput>
  }

  export type BuildCreateWithoutPreviewModeInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    project: ProjectCreateNestedOneWithoutBuildsInput
    features?: BuildFeatureCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogCreateNestedManyWithoutBuildInput
    productionMode?: BuildModeCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUncheckedCreateWithoutPreviewModeInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureUncheckedCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput
    productionMode?: BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildCreateOrConnectWithoutPreviewModeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutPreviewModeInput, BuildUncheckedCreateWithoutPreviewModeInput>
  }

  export type BuildCreateWithoutProductionModeInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    project: ProjectCreateNestedOneWithoutBuildsInput
    features?: BuildFeatureCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeCreateNestedOneWithoutPreviewBuildInput
  }

  export type BuildUncheckedCreateWithoutProductionModeInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureUncheckedCreateNestedManyWithoutBuildInput
    changeLogs?: BuildChangeLogUncheckedCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput
  }

  export type BuildCreateOrConnectWithoutProductionModeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutProductionModeInput, BuildUncheckedCreateWithoutProductionModeInput>
  }

  export type ProjectUpsertWithoutBuildModeInput = {
    update: XOR<ProjectUpdateWithoutBuildModeInput, ProjectUncheckedUpdateWithoutBuildModeInput>
    create: XOR<ProjectCreateWithoutBuildModeInput, ProjectUncheckedCreateWithoutBuildModeInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBuildModeInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBuildModeInput, ProjectUncheckedUpdateWithoutBuildModeInput>
  }

  export type ProjectUpdateWithoutBuildModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBuildModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BuildUpsertWithoutPreviewModeInput = {
    update: XOR<BuildUpdateWithoutPreviewModeInput, BuildUncheckedUpdateWithoutPreviewModeInput>
    create: XOR<BuildCreateWithoutPreviewModeInput, BuildUncheckedCreateWithoutPreviewModeInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutPreviewModeInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutPreviewModeInput, BuildUncheckedUpdateWithoutPreviewModeInput>
  }

  export type BuildUpdateWithoutPreviewModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBuildsNestedInput
    features?: BuildFeatureUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUpdateManyWithoutBuildNestedInput
    productionMode?: BuildModeUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutPreviewModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput
    productionMode?: BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUpsertWithoutProductionModeInput = {
    update: XOR<BuildUpdateWithoutProductionModeInput, BuildUncheckedUpdateWithoutProductionModeInput>
    create: XOR<BuildCreateWithoutProductionModeInput, BuildUncheckedCreateWithoutProductionModeInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutProductionModeInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutProductionModeInput, BuildUncheckedUpdateWithoutProductionModeInput>
  }

  export type BuildUpdateWithoutProductionModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBuildsNestedInput
    features?: BuildFeatureUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUpdateOneWithoutPreviewBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutProductionModeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput
  }

  export type BuildCreateWithoutChangeLogsInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    project: ProjectCreateNestedOneWithoutBuildsInput
    features?: BuildFeatureCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildUncheckedCreateWithoutChangeLogsInput = {
    id?: string
    projectId: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
    features?: BuildFeatureUncheckedCreateNestedManyWithoutBuildInput
    previewMode?: BuildModeUncheckedCreateNestedOneWithoutPreviewBuildInput
    productionMode?: BuildModeUncheckedCreateNestedOneWithoutProductionBuildInput
  }

  export type BuildCreateOrConnectWithoutChangeLogsInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutChangeLogsInput, BuildUncheckedCreateWithoutChangeLogsInput>
  }

  export type BuildUpsertWithoutChangeLogsInput = {
    update: XOR<BuildUpdateWithoutChangeLogsInput, BuildUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<BuildCreateWithoutChangeLogsInput, BuildUncheckedCreateWithoutChangeLogsInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutChangeLogsInput, BuildUncheckedUpdateWithoutChangeLogsInput>
  }

  export type BuildUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBuildsNestedInput
    features?: BuildFeatureUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput
  }

  export type ProjectCreateWithoutMockEnvironmentsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMockEnvironmentsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMockEnvironmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMockEnvironmentsInput, ProjectUncheckedCreateWithoutMockEnvironmentsInput>
  }

  export type MockEndpointCreateWithoutEnvironmentInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: MockResponseCreateNestedManyWithoutEndpointInput
    conditions?: MockConditionCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointUncheckedCreateWithoutEnvironmentInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: MockResponseUncheckedCreateNestedManyWithoutEndpointInput
    conditions?: MockConditionUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointCreateOrConnectWithoutEnvironmentInput = {
    where: MockEndpointWhereUniqueInput
    create: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput>
  }

  export type MockEndpointCreateManyEnvironmentInputEnvelope = {
    data: MockEndpointCreateManyEnvironmentInput | MockEndpointCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMockEnvironmentsInput = {
    update: XOR<ProjectUpdateWithoutMockEnvironmentsInput, ProjectUncheckedUpdateWithoutMockEnvironmentsInput>
    create: XOR<ProjectCreateWithoutMockEnvironmentsInput, ProjectUncheckedCreateWithoutMockEnvironmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMockEnvironmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMockEnvironmentsInput, ProjectUncheckedUpdateWithoutMockEnvironmentsInput>
  }

  export type ProjectUpdateWithoutMockEnvironmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMockEnvironmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MockEndpointUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: MockEndpointWhereUniqueInput
    update: XOR<MockEndpointUpdateWithoutEnvironmentInput, MockEndpointUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<MockEndpointCreateWithoutEnvironmentInput, MockEndpointUncheckedCreateWithoutEnvironmentInput>
  }

  export type MockEndpointUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: MockEndpointWhereUniqueInput
    data: XOR<MockEndpointUpdateWithoutEnvironmentInput, MockEndpointUncheckedUpdateWithoutEnvironmentInput>
  }

  export type MockEndpointUpdateManyWithWhereWithoutEnvironmentInput = {
    where: MockEndpointScalarWhereInput
    data: XOR<MockEndpointUpdateManyMutationInput, MockEndpointUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type MockEndpointScalarWhereInput = {
    AND?: MockEndpointScalarWhereInput | MockEndpointScalarWhereInput[]
    OR?: MockEndpointScalarWhereInput[]
    NOT?: MockEndpointScalarWhereInput | MockEndpointScalarWhereInput[]
    id?: StringFilter<"MockEndpoint"> | string
    environmentId?: StringFilter<"MockEndpoint"> | string
    path?: StringFilter<"MockEndpoint"> | string
    method?: StringFilter<"MockEndpoint"> | string
    description?: StringNullableFilter<"MockEndpoint"> | string | null
    isEnabled?: BoolFilter<"MockEndpoint"> | boolean
    order?: IntFilter<"MockEndpoint"> | number
    createdAt?: DateTimeFilter<"MockEndpoint"> | Date | string
    updatedAt?: DateTimeFilter<"MockEndpoint"> | Date | string
  }

  export type MockEnvironmentCreateWithoutEndpointsInput = {
    id?: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMockEnvironmentsInput
  }

  export type MockEnvironmentUncheckedCreateWithoutEndpointsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockEnvironmentCreateOrConnectWithoutEndpointsInput = {
    where: MockEnvironmentWhereUniqueInput
    create: XOR<MockEnvironmentCreateWithoutEndpointsInput, MockEnvironmentUncheckedCreateWithoutEndpointsInput>
  }

  export type MockResponseCreateWithoutEndpointInput = {
    id?: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: MockConditionCreateNestedManyWithoutResponseInput
  }

  export type MockResponseUncheckedCreateWithoutEndpointInput = {
    id?: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: MockConditionUncheckedCreateNestedManyWithoutResponseInput
  }

  export type MockResponseCreateOrConnectWithoutEndpointInput = {
    where: MockResponseWhereUniqueInput
    create: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput>
  }

  export type MockResponseCreateManyEndpointInputEnvelope = {
    data: MockResponseCreateManyEndpointInput | MockResponseCreateManyEndpointInput[]
    skipDuplicates?: boolean
  }

  export type MockConditionCreateWithoutEndpointInput = {
    id?: string
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
    response?: MockResponseCreateNestedOneWithoutConditionsInput
  }

  export type MockConditionUncheckedCreateWithoutEndpointInput = {
    id?: string
    responseId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockConditionCreateOrConnectWithoutEndpointInput = {
    where: MockConditionWhereUniqueInput
    create: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput>
  }

  export type MockConditionCreateManyEndpointInputEnvelope = {
    data: MockConditionCreateManyEndpointInput | MockConditionCreateManyEndpointInput[]
    skipDuplicates?: boolean
  }

  export type MockEnvironmentUpsertWithoutEndpointsInput = {
    update: XOR<MockEnvironmentUpdateWithoutEndpointsInput, MockEnvironmentUncheckedUpdateWithoutEndpointsInput>
    create: XOR<MockEnvironmentCreateWithoutEndpointsInput, MockEnvironmentUncheckedCreateWithoutEndpointsInput>
    where?: MockEnvironmentWhereInput
  }

  export type MockEnvironmentUpdateToOneWithWhereWithoutEndpointsInput = {
    where?: MockEnvironmentWhereInput
    data: XOR<MockEnvironmentUpdateWithoutEndpointsInput, MockEnvironmentUncheckedUpdateWithoutEndpointsInput>
  }

  export type MockEnvironmentUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMockEnvironmentsNestedInput
  }

  export type MockEnvironmentUncheckedUpdateWithoutEndpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockResponseUpsertWithWhereUniqueWithoutEndpointInput = {
    where: MockResponseWhereUniqueInput
    update: XOR<MockResponseUpdateWithoutEndpointInput, MockResponseUncheckedUpdateWithoutEndpointInput>
    create: XOR<MockResponseCreateWithoutEndpointInput, MockResponseUncheckedCreateWithoutEndpointInput>
  }

  export type MockResponseUpdateWithWhereUniqueWithoutEndpointInput = {
    where: MockResponseWhereUniqueInput
    data: XOR<MockResponseUpdateWithoutEndpointInput, MockResponseUncheckedUpdateWithoutEndpointInput>
  }

  export type MockResponseUpdateManyWithWhereWithoutEndpointInput = {
    where: MockResponseScalarWhereInput
    data: XOR<MockResponseUpdateManyMutationInput, MockResponseUncheckedUpdateManyWithoutEndpointInput>
  }

  export type MockResponseScalarWhereInput = {
    AND?: MockResponseScalarWhereInput | MockResponseScalarWhereInput[]
    OR?: MockResponseScalarWhereInput[]
    NOT?: MockResponseScalarWhereInput | MockResponseScalarWhereInput[]
    id?: StringFilter<"MockResponse"> | string
    endpointId?: StringFilter<"MockResponse"> | string
    statusCode?: IntFilter<"MockResponse"> | number
    name?: StringNullableFilter<"MockResponse"> | string | null
    description?: StringNullableFilter<"MockResponse"> | string | null
    responseBody?: JsonNullableFilter<"MockResponse">
    responseHeaders?: JsonNullableFilter<"MockResponse">
    delay?: IntFilter<"MockResponse"> | number
    isDefault?: BoolFilter<"MockResponse"> | boolean
    isEnabled?: BoolFilter<"MockResponse"> | boolean
    order?: IntFilter<"MockResponse"> | number
    createdAt?: DateTimeFilter<"MockResponse"> | Date | string
    updatedAt?: DateTimeFilter<"MockResponse"> | Date | string
  }

  export type MockConditionUpsertWithWhereUniqueWithoutEndpointInput = {
    where: MockConditionWhereUniqueInput
    update: XOR<MockConditionUpdateWithoutEndpointInput, MockConditionUncheckedUpdateWithoutEndpointInput>
    create: XOR<MockConditionCreateWithoutEndpointInput, MockConditionUncheckedCreateWithoutEndpointInput>
  }

  export type MockConditionUpdateWithWhereUniqueWithoutEndpointInput = {
    where: MockConditionWhereUniqueInput
    data: XOR<MockConditionUpdateWithoutEndpointInput, MockConditionUncheckedUpdateWithoutEndpointInput>
  }

  export type MockConditionUpdateManyWithWhereWithoutEndpointInput = {
    where: MockConditionScalarWhereInput
    data: XOR<MockConditionUpdateManyMutationInput, MockConditionUncheckedUpdateManyWithoutEndpointInput>
  }

  export type MockConditionScalarWhereInput = {
    AND?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
    OR?: MockConditionScalarWhereInput[]
    NOT?: MockConditionScalarWhereInput | MockConditionScalarWhereInput[]
    id?: StringFilter<"MockCondition"> | string
    responseId?: StringNullableFilter<"MockCondition"> | string | null
    endpointId?: StringNullableFilter<"MockCondition"> | string | null
    type?: StringFilter<"MockCondition"> | string
    key?: StringFilter<"MockCondition"> | string
    operator?: StringFilter<"MockCondition"> | string
    value?: StringNullableFilter<"MockCondition"> | string | null
    isCaseSensitive?: BoolFilter<"MockCondition"> | boolean
    order?: IntFilter<"MockCondition"> | number
    createdAt?: DateTimeFilter<"MockCondition"> | Date | string
  }

  export type MockEndpointCreateWithoutResponsesInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: MockEnvironmentCreateNestedOneWithoutEndpointsInput
    conditions?: MockConditionCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointUncheckedCreateWithoutResponsesInput = {
    id?: string
    environmentId: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conditions?: MockConditionUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointCreateOrConnectWithoutResponsesInput = {
    where: MockEndpointWhereUniqueInput
    create: XOR<MockEndpointCreateWithoutResponsesInput, MockEndpointUncheckedCreateWithoutResponsesInput>
  }

  export type MockConditionCreateWithoutResponseInput = {
    id?: string
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
    endpoint?: MockEndpointCreateNestedOneWithoutConditionsInput
  }

  export type MockConditionUncheckedCreateWithoutResponseInput = {
    id?: string
    endpointId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockConditionCreateOrConnectWithoutResponseInput = {
    where: MockConditionWhereUniqueInput
    create: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput>
  }

  export type MockConditionCreateManyResponseInputEnvelope = {
    data: MockConditionCreateManyResponseInput | MockConditionCreateManyResponseInput[]
    skipDuplicates?: boolean
  }

  export type MockEndpointUpsertWithoutResponsesInput = {
    update: XOR<MockEndpointUpdateWithoutResponsesInput, MockEndpointUncheckedUpdateWithoutResponsesInput>
    create: XOR<MockEndpointCreateWithoutResponsesInput, MockEndpointUncheckedCreateWithoutResponsesInput>
    where?: MockEndpointWhereInput
  }

  export type MockEndpointUpdateToOneWithWhereWithoutResponsesInput = {
    where?: MockEndpointWhereInput
    data: XOR<MockEndpointUpdateWithoutResponsesInput, MockEndpointUncheckedUpdateWithoutResponsesInput>
  }

  export type MockEndpointUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: MockEnvironmentUpdateOneRequiredWithoutEndpointsNestedInput
    conditions?: MockConditionUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: MockConditionUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type MockConditionUpsertWithWhereUniqueWithoutResponseInput = {
    where: MockConditionWhereUniqueInput
    update: XOR<MockConditionUpdateWithoutResponseInput, MockConditionUncheckedUpdateWithoutResponseInput>
    create: XOR<MockConditionCreateWithoutResponseInput, MockConditionUncheckedCreateWithoutResponseInput>
  }

  export type MockConditionUpdateWithWhereUniqueWithoutResponseInput = {
    where: MockConditionWhereUniqueInput
    data: XOR<MockConditionUpdateWithoutResponseInput, MockConditionUncheckedUpdateWithoutResponseInput>
  }

  export type MockConditionUpdateManyWithWhereWithoutResponseInput = {
    where: MockConditionScalarWhereInput
    data: XOR<MockConditionUpdateManyMutationInput, MockConditionUncheckedUpdateManyWithoutResponseInput>
  }

  export type MockResponseCreateWithoutConditionsInput = {
    id?: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    endpoint: MockEndpointCreateNestedOneWithoutResponsesInput
  }

  export type MockResponseUncheckedCreateWithoutConditionsInput = {
    id?: string
    endpointId: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockResponseCreateOrConnectWithoutConditionsInput = {
    where: MockResponseWhereUniqueInput
    create: XOR<MockResponseCreateWithoutConditionsInput, MockResponseUncheckedCreateWithoutConditionsInput>
  }

  export type MockEndpointCreateWithoutConditionsInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: MockEnvironmentCreateNestedOneWithoutEndpointsInput
    responses?: MockResponseCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointUncheckedCreateWithoutConditionsInput = {
    id?: string
    environmentId: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: MockResponseUncheckedCreateNestedManyWithoutEndpointInput
  }

  export type MockEndpointCreateOrConnectWithoutConditionsInput = {
    where: MockEndpointWhereUniqueInput
    create: XOR<MockEndpointCreateWithoutConditionsInput, MockEndpointUncheckedCreateWithoutConditionsInput>
  }

  export type MockResponseUpsertWithoutConditionsInput = {
    update: XOR<MockResponseUpdateWithoutConditionsInput, MockResponseUncheckedUpdateWithoutConditionsInput>
    create: XOR<MockResponseCreateWithoutConditionsInput, MockResponseUncheckedCreateWithoutConditionsInput>
    where?: MockResponseWhereInput
  }

  export type MockResponseUpdateToOneWithWhereWithoutConditionsInput = {
    where?: MockResponseWhereInput
    data: XOR<MockResponseUpdateWithoutConditionsInput, MockResponseUncheckedUpdateWithoutConditionsInput>
  }

  export type MockResponseUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoint?: MockEndpointUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type MockResponseUncheckedUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEndpointUpsertWithoutConditionsInput = {
    update: XOR<MockEndpointUpdateWithoutConditionsInput, MockEndpointUncheckedUpdateWithoutConditionsInput>
    create: XOR<MockEndpointCreateWithoutConditionsInput, MockEndpointUncheckedCreateWithoutConditionsInput>
    where?: MockEndpointWhereInput
  }

  export type MockEndpointUpdateToOneWithWhereWithoutConditionsInput = {
    where?: MockEndpointWhereInput
    data: XOR<MockEndpointUpdateWithoutConditionsInput, MockEndpointUncheckedUpdateWithoutConditionsInput>
  }

  export type MockEndpointUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: MockEnvironmentUpdateOneRequiredWithoutEndpointsNestedInput
    responses?: MockResponseUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointUncheckedUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: MockResponseUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type ProjectCreateWithoutConfigAlertsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutConfigAlertsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configApprovals?: ConfigApprovalUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutConfigAlertsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutConfigAlertsInput, ProjectUncheckedCreateWithoutConfigAlertsInput>
  }

  export type BusinessConfigCreateWithoutAlertsInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBusinessConfigsInput
    approvals?: ConfigApprovalCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigUncheckedCreateWithoutAlertsInput = {
    id?: string
    projectId: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    approvals?: ConfigApprovalUncheckedCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigCreateOrConnectWithoutAlertsInput = {
    where: BusinessConfigWhereUniqueInput
    create: XOR<BusinessConfigCreateWithoutAlertsInput, BusinessConfigUncheckedCreateWithoutAlertsInput>
  }

  export type ConfigAlertEventCreateWithoutAlertInput = {
    id?: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConfigAlertEventUncheckedCreateWithoutAlertInput = {
    id?: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConfigAlertEventCreateOrConnectWithoutAlertInput = {
    where: ConfigAlertEventWhereUniqueInput
    create: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput>
  }

  export type ConfigAlertEventCreateManyAlertInputEnvelope = {
    data: ConfigAlertEventCreateManyAlertInput | ConfigAlertEventCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutConfigAlertsInput = {
    update: XOR<ProjectUpdateWithoutConfigAlertsInput, ProjectUncheckedUpdateWithoutConfigAlertsInput>
    create: XOR<ProjectCreateWithoutConfigAlertsInput, ProjectUncheckedCreateWithoutConfigAlertsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutConfigAlertsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutConfigAlertsInput, ProjectUncheckedUpdateWithoutConfigAlertsInput>
  }

  export type ProjectUpdateWithoutConfigAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutConfigAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BusinessConfigUpsertWithoutAlertsInput = {
    update: XOR<BusinessConfigUpdateWithoutAlertsInput, BusinessConfigUncheckedUpdateWithoutAlertsInput>
    create: XOR<BusinessConfigCreateWithoutAlertsInput, BusinessConfigUncheckedCreateWithoutAlertsInput>
    where?: BusinessConfigWhereInput
  }

  export type BusinessConfigUpdateToOneWithWhereWithoutAlertsInput = {
    where?: BusinessConfigWhereInput
    data: XOR<BusinessConfigUpdateWithoutAlertsInput, BusinessConfigUncheckedUpdateWithoutAlertsInput>
  }

  export type BusinessConfigUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBusinessConfigsNestedInput
    approvals?: ConfigApprovalUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: ConfigApprovalUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type ConfigAlertEventUpsertWithWhereUniqueWithoutAlertInput = {
    where: ConfigAlertEventWhereUniqueInput
    update: XOR<ConfigAlertEventUpdateWithoutAlertInput, ConfigAlertEventUncheckedUpdateWithoutAlertInput>
    create: XOR<ConfigAlertEventCreateWithoutAlertInput, ConfigAlertEventUncheckedCreateWithoutAlertInput>
  }

  export type ConfigAlertEventUpdateWithWhereUniqueWithoutAlertInput = {
    where: ConfigAlertEventWhereUniqueInput
    data: XOR<ConfigAlertEventUpdateWithoutAlertInput, ConfigAlertEventUncheckedUpdateWithoutAlertInput>
  }

  export type ConfigAlertEventUpdateManyWithWhereWithoutAlertInput = {
    where: ConfigAlertEventScalarWhereInput
    data: XOR<ConfigAlertEventUpdateManyMutationInput, ConfigAlertEventUncheckedUpdateManyWithoutAlertInput>
  }

  export type ConfigAlertEventScalarWhereInput = {
    AND?: ConfigAlertEventScalarWhereInput | ConfigAlertEventScalarWhereInput[]
    OR?: ConfigAlertEventScalarWhereInput[]
    NOT?: ConfigAlertEventScalarWhereInput | ConfigAlertEventScalarWhereInput[]
    id?: StringFilter<"ConfigAlertEvent"> | string
    alertId?: StringFilter<"ConfigAlertEvent"> | string
    projectId?: StringFilter<"ConfigAlertEvent"> | string
    configId?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    severity?: StringFilter<"ConfigAlertEvent"> | string
    message?: StringFilter<"ConfigAlertEvent"> | string
    metadata?: JsonNullableFilter<"ConfigAlertEvent">
    acknowledged?: BoolFilter<"ConfigAlertEvent"> | boolean
    acknowledgedBy?: StringNullableFilter<"ConfigAlertEvent"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConfigAlertEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"ConfigAlertEvent"> | Date | string
  }

  export type ConfigAlertCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutConfigAlertsInput
    config?: BusinessConfigCreateNestedOneWithoutAlertsInput
  }

  export type ConfigAlertUncheckedCreateWithoutEventsInput = {
    id?: string
    projectId: string
    configId?: string | null
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigAlertCreateOrConnectWithoutEventsInput = {
    where: ConfigAlertWhereUniqueInput
    create: XOR<ConfigAlertCreateWithoutEventsInput, ConfigAlertUncheckedCreateWithoutEventsInput>
  }

  export type ConfigAlertUpsertWithoutEventsInput = {
    update: XOR<ConfigAlertUpdateWithoutEventsInput, ConfigAlertUncheckedUpdateWithoutEventsInput>
    create: XOR<ConfigAlertCreateWithoutEventsInput, ConfigAlertUncheckedCreateWithoutEventsInput>
    where?: ConfigAlertWhereInput
  }

  export type ConfigAlertUpdateToOneWithWhereWithoutEventsInput = {
    where?: ConfigAlertWhereInput
    data: XOR<ConfigAlertUpdateWithoutEventsInput, ConfigAlertUncheckedUpdateWithoutEventsInput>
  }

  export type ConfigAlertUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigAlertsNestedInput
    config?: BusinessConfigUpdateOneWithoutAlertsNestedInput
  }

  export type ConfigAlertUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutConfigApprovalsInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    devices?: DeviceCreateNestedManyWithoutProjectInput
    logs?: LogCreateNestedManyWithoutProjectInput
    crashes?: CrashCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertCreateNestedManyWithoutProjectInput
    builds?: BuildCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertCreateNestedManyWithoutProjectInput
    languages?: LanguageCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutConfigApprovalsInput = {
    id?: string
    name: string
    apiKey?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutProjectInput
    logs?: LogUncheckedCreateNestedManyWithoutProjectInput
    crashes?: CrashUncheckedCreateNestedManyWithoutProjectInput
    apiTraces?: ApiTraceUncheckedCreateNestedManyWithoutProjectInput
    apiConfigs?: ApiConfigUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutProjectInput
    apiAlerts?: ApiAlertUncheckedCreateNestedManyWithoutProjectInput
    builds?: BuildUncheckedCreateNestedManyWithoutProjectInput
    buildMode?: BuildModeUncheckedCreateNestedOneWithoutProjectInput
    mockEnvironments?: MockEnvironmentUncheckedCreateNestedManyWithoutProjectInput
    businessConfigs?: BusinessConfigUncheckedCreateNestedManyWithoutProjectInput
    configAlerts?: ConfigAlertUncheckedCreateNestedManyWithoutProjectInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProjectInput
    localizationKeys?: LocalizationKeyUncheckedCreateNestedManyWithoutProjectInput
    featureFlags?: FeatureFlagsUncheckedCreateNestedOneWithoutProjectInput
    sdkSettings?: SdkSettingsUncheckedCreateNestedOneWithoutProjectInput
    configCategories?: ConfigCategoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutConfigApprovalsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutConfigApprovalsInput, ProjectUncheckedCreateWithoutConfigApprovalsInput>
  }

  export type BusinessConfigCreateWithoutApprovalsInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBusinessConfigsInput
    alerts?: ConfigAlertCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigUncheckedCreateWithoutApprovalsInput = {
    id?: string
    projectId: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: ConfigAlertUncheckedCreateNestedManyWithoutConfigInput
  }

  export type BusinessConfigCreateOrConnectWithoutApprovalsInput = {
    where: BusinessConfigWhereUniqueInput
    create: XOR<BusinessConfigCreateWithoutApprovalsInput, BusinessConfigUncheckedCreateWithoutApprovalsInput>
  }

  export type ProjectUpsertWithoutConfigApprovalsInput = {
    update: XOR<ProjectUpdateWithoutConfigApprovalsInput, ProjectUncheckedUpdateWithoutConfigApprovalsInput>
    create: XOR<ProjectCreateWithoutConfigApprovalsInput, ProjectUncheckedCreateWithoutConfigApprovalsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutConfigApprovalsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutConfigApprovalsInput, ProjectUncheckedUpdateWithoutConfigApprovalsInput>
  }

  export type ProjectUpdateWithoutConfigApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutConfigApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BusinessConfigUpsertWithoutApprovalsInput = {
    update: XOR<BusinessConfigUpdateWithoutApprovalsInput, BusinessConfigUncheckedUpdateWithoutApprovalsInput>
    create: XOR<BusinessConfigCreateWithoutApprovalsInput, BusinessConfigUncheckedCreateWithoutApprovalsInput>
    where?: BusinessConfigWhereInput
  }

  export type BusinessConfigUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: BusinessConfigWhereInput
    data: XOR<BusinessConfigUpdateWithoutApprovalsInput, BusinessConfigUncheckedUpdateWithoutApprovalsInput>
  }

  export type BusinessConfigUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBusinessConfigsNestedInput
    alerts?: ConfigAlertUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: ConfigAlertUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    apiKey?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUpdateManyWithoutProjectNestedInput
    logs?: LogUpdateManyWithoutProjectNestedInput
    crashes?: CrashUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUpdateManyWithoutProjectNestedInput
    builds?: BuildUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUpdateManyWithoutProjectNestedInput
    languages?: LanguageUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutProjectNestedInput
    logs?: LogUncheckedUpdateManyWithoutProjectNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutProjectNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutProjectNestedInput
    apiConfigs?: ApiConfigUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutProjectNestedInput
    apiAlerts?: ApiAlertUncheckedUpdateManyWithoutProjectNestedInput
    builds?: BuildUncheckedUpdateManyWithoutProjectNestedInput
    buildMode?: BuildModeUncheckedUpdateOneWithoutProjectNestedInput
    mockEnvironments?: MockEnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    businessConfigs?: BusinessConfigUncheckedUpdateManyWithoutProjectNestedInput
    configAlerts?: ConfigAlertUncheckedUpdateManyWithoutProjectNestedInput
    configApprovals?: ConfigApprovalUncheckedUpdateManyWithoutProjectNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProjectNestedInput
    localizationKeys?: LocalizationKeyUncheckedUpdateManyWithoutProjectNestedInput
    featureFlags?: FeatureFlagsUncheckedUpdateOneWithoutProjectNestedInput
    sdkSettings?: SdkSettingsUncheckedUpdateOneWithoutProjectNestedInput
    configCategories?: ConfigCategoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManyProjectInput = {
    id?: string
    deviceId: string
    platform: string
    osVersion?: string | null
    appVersion?: string | null
    model?: string | null
    manufacturer?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceCode?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    debugModeEnabled?: boolean
    debugModeEnabledAt?: Date | string | null
    debugModeExpiresAt?: Date | string | null
    debugModeEnabledBy?: string | null
    status?: string
    deletedAt?: Date | string | null
  }

  export type LogCreateManyProjectInput = {
    id?: string
    deviceId?: string | null
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashCreateManyProjectInput = {
    id?: string
    deviceId?: string | null
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceCreateManyProjectInput = {
    id?: string
    deviceId?: string | null
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiConfigCreateManyProjectInput = {
    id?: string
    endpoint: string
    method?: string | null
    name?: string | null
    description?: string | null
    costPerRequest?: number
    isEnabled?: boolean
    enableLogs?: boolean
    captureRequestBody?: boolean
    captureResponseBody?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyProjectInput = {
    id?: string
    deviceId?: string | null
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiAlertCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    endpoint?: string | null
    method?: string | null
    isEnabled?: boolean
    monitorStandardErrors?: boolean
    standardErrorCodes?: ApiAlertCreatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertCreatecustomStatusCodesInput | number[]
    bodyErrorField?: string | null
    bodyErrorValues?: ApiAlertCreatebodyErrorValuesInput | string[]
    headerErrorField?: string | null
    headerErrorValues?: ApiAlertCreateheaderErrorValuesInput | string[]
    notifyEmail?: boolean
    notifyPush?: boolean
    notifySms?: boolean
    notifyWebhook?: boolean
    cooldownMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildCreateManyProjectInput = {
    id?: string
    version: number
    name?: string | null
    description?: string | null
    mode?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: number
    translationCount?: number
  }

  export type MockEnvironmentCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    basePath?: string | null
    mode?: string
    whitelist?: MockEnvironmentCreatewhitelistInput | string[]
    blacklist?: MockEnvironmentCreateblacklistInput | string[]
    isEnabled?: boolean
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessConfigCreateManyProjectInput = {
    id?: string
    key: string
    label?: string | null
    description?: string | null
    valueType: string
    stringValue?: string | null
    integerValue?: number | null
    booleanValue?: boolean | null
    decimalValue?: number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    category?: string | null
    isEnabled?: boolean
    version?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigAlertCreateManyProjectInput = {
    id?: string
    configId?: string | null
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalCreateManyProjectInput = {
    id?: string
    configId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageCreateManyProjectInput = {
    id?: string
    code: string
    name: string
    nativeName?: string | null
    isDefault?: boolean
    isEnabled?: boolean
    isRTL?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalizationKeyCreateManyProjectInput = {
    id?: string
    key: string
    description?: string | null
    category?: string | null
    platform?: string | null
    maxLength?: number | null
    screenshot?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigCategoryCreateManyProjectInput = {
    id?: string
    name: string
    label?: string | null
    description?: string | null
    icon?: string | null
    order?: number
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogUncheckedUpdateManyWithoutDeviceNestedInput
    crashes?: CrashUncheckedUpdateManyWithoutDeviceNestedInput
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutDeviceNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    debugModeEnabled?: BoolFieldUpdateOperationsInput | boolean
    debugModeEnabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debugModeEnabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutLogsNestedInput
    session?: SessionUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutCrashesNestedInput
  }

  export type CrashUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutApiTracesNestedInput
    session?: SessionUpdateOneWithoutApiTracesNestedInput
  }

  export type ApiTraceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiConfigUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerRequest?: FloatFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enableLogs?: BoolFieldUpdateOperationsInput | boolean
    captureRequestBody?: BoolFieldUpdateOperationsInput | boolean
    captureResponseBody?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutSessionsNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutSessionNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutSessionNestedInput
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiAlertUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitoredErrors?: MonitoredErrorUpdateManyWithoutAlertNestedInput
  }

  export type ApiAlertUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitoredErrors?: MonitoredErrorUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type ApiAlertUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    monitorStandardErrors?: BoolFieldUpdateOperationsInput | boolean
    standardErrorCodes?: ApiAlertUpdatestandardErrorCodesInput | number[]
    customStatusCodes?: ApiAlertUpdatecustomStatusCodesInput | number[]
    bodyErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    bodyErrorValues?: ApiAlertUpdatebodyErrorValuesInput | string[]
    headerErrorField?: NullableStringFieldUpdateOperationsInput | string | null
    headerErrorValues?: ApiAlertUpdateheaderErrorValuesInput | string[]
    notifyEmail?: BoolFieldUpdateOperationsInput | boolean
    notifyPush?: BoolFieldUpdateOperationsInput | boolean
    notifySms?: BoolFieldUpdateOperationsInput | boolean
    notifyWebhook?: BoolFieldUpdateOperationsInput | boolean
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
    features?: BuildFeatureUncheckedUpdateManyWithoutBuildNestedInput
    changeLogs?: BuildChangeLogUncheckedUpdateManyWithoutBuildNestedInput
    previewMode?: BuildModeUncheckedUpdateOneWithoutPreviewBuildNestedInput
    productionMode?: BuildModeUncheckedUpdateOneWithoutProductionBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessConfigSnapshot?: NullableJsonNullValueInput | InputJsonValue
    localizationSnapshot?: NullableJsonNullValueInput | InputJsonValue
    configCount?: IntFieldUpdateOperationsInput | number
    translationCount?: IntFieldUpdateOperationsInput | number
  }

  export type MockEnvironmentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoints?: MockEndpointUpdateManyWithoutEnvironmentNestedInput
  }

  export type MockEnvironmentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoints?: MockEndpointUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type MockEnvironmentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: StringFieldUpdateOperationsInput | string
    whitelist?: MockEnvironmentUpdatewhitelistInput | string[]
    blacklist?: MockEnvironmentUpdateblacklistInput | string[]
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessConfigUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: ConfigAlertUpdateManyWithoutConfigNestedInput
    approvals?: ConfigApprovalUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: ConfigAlertUncheckedUpdateManyWithoutConfigNestedInput
    approvals?: ConfigApprovalUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type BusinessConfigUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: StringFieldUpdateOperationsInput | string
    stringValue?: NullableStringFieldUpdateOperationsInput | string | null
    integerValue?: NullableIntFieldUpdateOperationsInput | number | null
    booleanValue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decimalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    jsonValue?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: BusinessConfigUpdateOneWithoutAlertsNestedInput
    events?: ConfigAlertEventUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ConfigAlertEventUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: BusinessConfigUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ConfigApprovalUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isRTL?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizationKeyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutKeyNestedInput
  }

  export type LocalizationKeyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutKeyNestedInput
  }

  export type LocalizationKeyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigCategoryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyDeviceInput = {
    id?: string
    projectId: string
    sessionId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type CrashCreateManyDeviceInput = {
    id?: string
    projectId: string
    message: string
    stackTrace?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceCreateManyDeviceInput = {
    id?: string
    projectId: string
    sessionId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateManyDeviceInput = {
    id?: string
    projectId: string
    sessionToken: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    isActive?: boolean
    appVersion?: string | null
    osVersion?: string | null
    locale?: string | null
    timezone?: string | null
    networkType?: string | null
    screenFlow?: SessionCreatescreenFlowInput | string[]
    entryScreen?: string | null
    exitScreen?: string | null
    duration?: number | null
    screenCount?: number
    eventCount?: number
    errorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
    session?: SessionUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCrashesNestedInput
  }

  export type CrashUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stackTrace?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiTracesNestedInput
    session?: SessionUpdateOneWithoutApiTracesNestedInput
  }

  export type ApiTraceUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
    apiTraces?: ApiTraceUpdateManyWithoutSessionNestedInput
    logs?: LogUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiTraces?: ApiTraceUncheckedUpdateManyWithoutSessionNestedInput
    logs?: LogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    screenFlow?: SessionUpdatescreenFlowInput | string[]
    entryScreen?: NullableStringFieldUpdateOperationsInput | string | null
    exitScreen?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    screenCount?: IntFieldUpdateOperationsInput | number
    eventCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userProperties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceCreateManySessionInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    url: string
    method: string
    statusCode?: number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: string | null
    duration?: number | null
    error?: string | null
    screenName?: string | null
    networkType?: string | null
    country?: string | null
    carrier?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    cost?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type LogCreateManySessionInput = {
    id?: string
    projectId: string
    deviceId?: string | null
    level?: string
    message: string
    tag?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: string | null
    lineNumber?: number | null
    functionName?: string | null
    className?: string | null
    screenName?: string | null
    threadName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ApiTraceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiTracesNestedInput
    device?: DeviceUpdateOneWithoutApiTracesNestedInput
  }

  export type ApiTraceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiTraceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    networkType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLogsNestedInput
    device?: DeviceUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    lineNumber?: NullableIntFieldUpdateOperationsInput | number | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    screenName?: NullableStringFieldUpdateOperationsInput | string | null
    threadName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorCreateManyAlertInput = {
    id?: string
    projectId: string
    errorType: string
    errorCode: string
    endpoint: string
    method: string
    statusCode?: number | null
    requestBody?: string | null
    responseBody?: string | null
    firstOccurrence?: Date | string
    lastOccurrence?: Date | string
    occurrenceCount?: number
    affectedDevices?: MonitoredErrorCreateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorCreateaffectedSessionsInput | string[]
    lastTraceId?: string | null
    lastNotifiedAt?: Date | string | null
    notificationCount?: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonitoredErrorUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonitoredErrorUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    errorType?: StringFieldUpdateOperationsInput | string
    errorCode?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    firstOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    affectedDevices?: MonitoredErrorUpdateaffectedDevicesInput | string[]
    affectedSessions?: MonitoredErrorUpdateaffectedSessionsInput | string[]
    lastTraceId?: NullableStringFieldUpdateOperationsInput | string | null
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationCount?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertCreateManyConfigInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    condition: string
    threshold: number
    operator?: string
    timeWindow?: number
    minOccurrences?: number
    enabled?: boolean
    webhookUrl?: string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: Date | string | null
    triggerCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigApprovalCreateManyConfigInput = {
    id?: string
    projectId: string
    changeType: string
    changeData: JsonNullValueInput | InputJsonValue
    status?: string
    requiredApprovals?: number
    currentApprovals?: number
    approvers: JsonNullValueInput | InputJsonValue
    approvals: JsonNullValueInput | InputJsonValue
    requestedBy: string
    requestedAt?: Date | string
    decidedBy?: string | null
    decidedAt?: Date | string | null
    decisionComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigAlertUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigAlertsNestedInput
    events?: ConfigAlertEventUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ConfigAlertEventUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type ConfigAlertUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    operator?: StringFieldUpdateOperationsInput | string
    timeWindow?: IntFieldUpdateOperationsInput | number
    minOccurrences?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailRecipients?: NullableJsonNullValueInput | InputJsonValue
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    triggerCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutConfigApprovalsNestedInput
  }

  export type ConfigApprovalUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigApprovalUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeData?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    requiredApprovals?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    approvers?: JsonNullValueInput | InputJsonValue
    approvals?: JsonNullValueInput | InputJsonValue
    requestedBy?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedBy?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decisionComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyLanguageInput = {
    id?: string
    projectId: string
    keyId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: LocalizationKeyUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyKeyInput = {
    id?: string
    projectId: string
    languageId: string
    value: string
    isReviewed?: boolean
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateWithoutKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TranslationUncheckedUpdateWithoutKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyWithoutKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    status?: string
    enabled?: boolean
    trialStartDate?: Date | string
    trialEndDate: Date | string
    currentPeriodStart?: Date | string
    currentPeriodEnd: Date | string
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    disabledBy?: string | null
    disabledAt?: Date | string | null
    enabledBy?: string | null
    enabledAt?: Date | string | null
    quotaMaxProjects?: number | null
    quotaMaxDevices?: number | null
    quotaMaxMockEndpoints?: number | null
    quotaMaxApiEndpoints?: number | null
    quotaMaxApiRequests?: number | null
    quotaMaxLogs?: number | null
    quotaMaxSessions?: number | null
    quotaMaxCrashes?: number | null
    quotaMaxBusinessConfigKeys?: number | null
    quotaMaxLocalizationLanguages?: number | null
    quotaMaxLocalizationKeys?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    enforcementState?: EnforcementStateUncheckedUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    trialStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    disabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    disabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabledBy?: NullableStringFieldUpdateOperationsInput | string | null
    enabledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotaMaxProjects?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxDevices?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxMockEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiEndpoints?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxApiRequests?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLogs?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxSessions?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxCrashes?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxBusinessConfigKeys?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationLanguages?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMaxLocalizationKeys?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: string
    invoiceNumber: string
    status?: string
    amount: number
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    pdfUrl?: string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineItems?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildFeatureCreateManyBuildInput = {
    id?: string
    featureType: string
    snapshotData: JsonNullValueInput | InputJsonValue
    itemCount: number
    createdAt?: Date | string
  }

  export type BuildChangeLogCreateManyBuildInput = {
    id?: string
    featureType: string
    changeType: string
    itemKey: string
    itemLabel?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type BuildFeatureUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildFeatureUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildFeatureUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    snapshotData?: JsonNullValueInput | InputJsonValue
    itemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildChangeLogUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureType?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    itemKey?: StringFieldUpdateOperationsInput | string
    itemLabel?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockEndpointCreateManyEnvironmentInput = {
    id?: string
    path: string
    method: string
    description?: string | null
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockEndpointUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: MockResponseUpdateManyWithoutEndpointNestedInput
    conditions?: MockConditionUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointUncheckedUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: MockResponseUncheckedUpdateManyWithoutEndpointNestedInput
    conditions?: MockConditionUncheckedUpdateManyWithoutEndpointNestedInput
  }

  export type MockEndpointUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockResponseCreateManyEndpointInput = {
    id?: string
    statusCode: number
    name?: string | null
    description?: string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: number
    isDefault?: boolean
    isEnabled?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockConditionCreateManyEndpointInput = {
    id?: string
    responseId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockResponseUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: MockConditionUpdateManyWithoutResponseNestedInput
  }

  export type MockResponseUncheckedUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: MockConditionUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type MockResponseUncheckedUpdateManyWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    delay?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: MockResponseUpdateOneWithoutConditionsNestedInput
  }

  export type MockConditionUncheckedUpdateWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionUncheckedUpdateManyWithoutEndpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionCreateManyResponseInput = {
    id?: string
    endpointId?: string | null
    type: string
    key: string
    operator: string
    value?: string | null
    isCaseSensitive?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type MockConditionUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endpoint?: MockEndpointUpdateOneWithoutConditionsNestedInput
  }

  export type MockConditionUncheckedUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockConditionUncheckedUpdateManyWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpointId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    isCaseSensitive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventCreateManyAlertInput = {
    id?: string
    projectId: string
    configId?: string | null
    severity?: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConfigAlertEventUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigAlertEventUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    configId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceCountOutputTypeDefaultArgs instead
     */
    export type DeviceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionCountOutputTypeDefaultArgs instead
     */
    export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiAlertCountOutputTypeDefaultArgs instead
     */
    export type ApiAlertCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiAlertCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessConfigCountOutputTypeDefaultArgs instead
     */
    export type BusinessConfigCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessConfigCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalizationKeyCountOutputTypeDefaultArgs instead
     */
    export type LocalizationKeyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalizationKeyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildCountOutputTypeDefaultArgs instead
     */
    export type BuildCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockEnvironmentCountOutputTypeDefaultArgs instead
     */
    export type MockEnvironmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockEnvironmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockEndpointCountOutputTypeDefaultArgs instead
     */
    export type MockEndpointCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockEndpointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockResponseCountOutputTypeDefaultArgs instead
     */
    export type MockResponseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockResponseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigAlertCountOutputTypeDefaultArgs instead
     */
    export type ConfigAlertCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigAlertCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceDefaultArgs instead
     */
    export type DeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashDefaultArgs instead
     */
    export type CrashArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiTraceDefaultArgs instead
     */
    export type ApiTraceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiTraceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiConfigDefaultArgs instead
     */
    export type ApiConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSettingsDefaultArgs instead
     */
    export type NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiAlertDefaultArgs instead
     */
    export type ApiAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonitoredErrorDefaultArgs instead
     */
    export type MonitoredErrorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonitoredErrorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessConfigDefaultArgs instead
     */
    export type BusinessConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UploadedFileDefaultArgs instead
     */
    export type UploadedFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UploadedFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalizationKeyDefaultArgs instead
     */
    export type LocalizationKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalizationKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationDefaultArgs instead
     */
    export type TranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeatureFlagsDefaultArgs instead
     */
    export type FeatureFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeatureFlagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SdkSettingsDefaultArgs instead
     */
    export type SdkSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SdkSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigCategoryDefaultArgs instead
     */
    export type ConfigCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnforcementStateDefaultArgs instead
     */
    export type EnforcementStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnforcementStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildDefaultArgs instead
     */
    export type BuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildFeatureDefaultArgs instead
     */
    export type BuildFeatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildFeatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildModeDefaultArgs instead
     */
    export type BuildModeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildModeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildChangeLogDefaultArgs instead
     */
    export type BuildChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockEnvironmentDefaultArgs instead
     */
    export type MockEnvironmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockEnvironmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockEndpointDefaultArgs instead
     */
    export type MockEndpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockEndpointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockResponseDefaultArgs instead
     */
    export type MockResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MockConditionDefaultArgs instead
     */
    export type MockConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MockConditionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigAlertDefaultArgs instead
     */
    export type ConfigAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigAlertEventDefaultArgs instead
     */
    export type ConfigAlertEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigAlertEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigApprovalDefaultArgs instead
     */
    export type ConfigApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigurationDefaultArgs instead
     */
    export type SystemConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigurationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}